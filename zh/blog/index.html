<!doctype html>
<html lang="zh" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.4">
<link rel="alternate" type="application/rss+xml" href="/zh/blog/rss.xml" title="Apache ShenYu (Incubating) Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/zh/blog/atom.xml" title="Apache ShenYu (Incubating) Blog Atom Feed">
<link rel="search" type="application/opensearchdescription+xml" title="Apache ShenYu (Incubating)" href="/zh/opensearch.xml">
<link rel="alternate" type="application/rss+xml" href="/zh/news/rss.xml" title="Apache ShenYu (Incubating) Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/zh/news/atom.xml" title="Apache ShenYu (Incubating) Blog Atom Feed"><title data-react-helmet="true">Blog | Apache ShenYu (Incubating)</title><meta data-react-helmet="true" property="og:title" content="Blog | Apache ShenYu (Incubating)"><meta data-react-helmet="true" name="description" content="Blog"><meta data-react-helmet="true" property="og:description" content="Blog"><meta data-react-helmet="true" property="og:url" content="https://shenyu.apache.org//zh/blog"><meta data-react-helmet="true" name="docsearch:language" content="zh"><meta data-react-helmet="true" name="docsearch:docusaurus_tag" content="blog_posts_list"><link data-react-helmet="true" rel="shortcut icon" href="/zh/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://shenyu.apache.org//zh/blog"><link data-react-helmet="true" rel="alternate" href="https://shenyu.apache.org//blog" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://shenyu.apache.org//zh/blog" hreflang="zh"><link data-react-helmet="true" rel="alternate" href="https://shenyu.apache.org//blog" hreflang="x-default"><link data-react-helmet="true" rel="preconnect" href="https://BH4D9OD16A-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/zh/assets/css/styles.32e5b75e.css">
<link rel="preload" href="/zh/assets/js/runtime~main.9f932cca.js" as="script">
<link rel="preload" href="/zh/assets/js/main.26b40e3d.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_OuoZ">Skip to main content</a></div><div class="announcementBar_axC9" role="banner"><div class="announcementBarContent_6uhP announcementBarCloseable_y4cp">⭐️ &nbsp; If you like Apache ShenYu (Incubating), give it a star on <a target="_blank" rel="noopener noreferrer" href="https://github.com/apache/incubator-shenyu">GitHub</a></div><button type="button" class="announcementBarClose_A3A1 clean-btn" aria-label="Close"><span aria-hidden="true">×</span></button></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/zh/"><img src="/zh/img/logo.png" alt="Apache ShenYu Logo" class="themedImage_TMUO themedImage--light_4Vu1 navbar__logo"><img src="/zh/img/logo.png" alt="Apache ShenYu Logo" class="themedImage_TMUO themedImage--dark_uzRr navbar__logo"></a><a class="navbar__item navbar__link" href="/zh/download">下载</a><a class="navbar__item navbar__link" href="/zh/docs/index">文档</a><a class="navbar__item navbar__link" href="/zh/community/subscribe-email">社区</a><a class="navbar__item navbar__link" href="/zh/event/2.4.1-release">事件</a><a class="navbar__item navbar__link" href="/zh/news">新闻</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/zh/blog">博客</a><a class="navbar__item navbar__link" href="/zh/users">用户</a><div class="navbar__item dropdown dropdown--hoverable"><a class="navbar__item navbar__link">ASF</a><ul class="dropdown__menu"><li><a href="https://www.apache.org/" target="_blank" rel="noopener noreferrer" class="dropdown__link">Foundation</a></li><li><a href="https://www.apache.org/licenses/" target="_blank" rel="noopener noreferrer" class="dropdown__link">License</a></li><li><a href="https://www.apache.org/events/" target="_blank" rel="noopener noreferrer" class="dropdown__link">Events</a></li><li><a href="https://www.apache.org/security/" target="_blank" rel="noopener noreferrer" class="dropdown__link">Security</a></li><li><a href="https://www.apache.org/foundation/sponsorship.html" target="_blank" rel="noopener noreferrer" class="dropdown__link">Sponsorship</a></li><li><a href="https://www.apache.org/foundation/thanks.html" target="_blank" rel="noopener noreferrer" class="dropdown__link">Thanks</a></li></ul></div></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__item navbar__link" href="/zh/docs/index">2.4.1</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/zh/docs/next/index">当前版本</a></li><li><a class="dropdown__link" href="/zh/docs/index">2.4.1</a></li><li><a class="dropdown__link" href="/zh/docs/2.4.0/index">2.4.0</a></li><li><a class="dropdown__link" href="/zh/docs/2.3.0/index">2.3.0</a></li><li><a class="dropdown__link" href="/zh/versions">All versions</a></li></ul></div><a href="https://github.com/apache/incubator-shenyu" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" class="navbar__item navbar__link"><span><svg t="1631348384596" class="icon" viewBox="0 0 1024 1024" version="1.1" style="vertical-align:text-bottom;margin-right:5px" p-id="557" width="20" height="20"><path d="M547.797333 638.208l-104.405333-103.168 1.237333-1.28a720.170667 720.170667 0 0 0 152.490667-268.373333h120.448V183.082667h-287.744V100.906667H347.605333v82.218666H59.818667V265.386667h459.178666a648.234667 648.234667 0 0 1-130.304 219.946666 643.242667 643.242667 0 0 1-94.976-137.728H211.541333a722.048 722.048 0 0 0 122.453334 187.434667l-209.194667 206.378667 58.368 58.368 205.525333-205.525334 127.872 127.829334 31.232-83.84m231.424-208.426667h-82.218666l-184.96 493.312h82.218666l46.037334-123.306667h195.242666l46.464 123.306667h82.218667l-185.002667-493.312m-107.690666 287.744l66.56-178.005333 66.602666 178.005333z" fill="currentColor" p-id="558"></path></svg><span>简体中文</span></span></a><ul class="dropdown__menu"><li><a href="/blog" target="_self" rel="noopener noreferrer" class="dropdown__link" style="text-transform:capitalize">English</a></li><li><a href="/zh/blog" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" style="text-transform:capitalize">简体中文</a></li></ul></div><div class="react-toggle toggle_2i4l react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_iYfV">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_iYfV">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div><div class="searchBox_Bc3W"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper blog-wrapper blog-list-page"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_SrOn thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_jISh margin-bottom--md">All Blog Posts</div><ul class="sidebarItemList_UfcF"><h4 class="categoryHeader_Xx2W">DataSync</h4><li class="sidebarItem_v502"><a class="sidebarItemLink_yJnx" href="/zh/blog/DataSync-SourceCode-Analysis-Http-Data-Sync">Http长轮询数据同步源码分析</a></li><li class="sidebarItem_v502"><a class="sidebarItemLink_yJnx" href="/zh/blog/DataSync-SourceCode-Analysis-WebSocket-Data-Sync">WebSocket数据同步源码分析</a></li><li class="sidebarItem_v502"><a class="sidebarItemLink_yJnx" href="/zh/blog/DataSync-SourceCode-Analysis-ZooKeeper-Data-Sync">ZooKeeper数据同步源码分析</a></li><h4 class="categoryHeader_Xx2W">Plugin</h4><li class="sidebarItem_v502"><a class="sidebarItemLink_yJnx" href="/zh/blog/Plugin-SourceCode-Analysis-Context-Path-Plugin">Context-Path插件源码分析</a></li><li class="sidebarItem_v502"><a class="sidebarItemLink_yJnx" href="/zh/blog/Plugin-SourceCode-Analysis-Param-Mapping-Plugin">Param-Mapping插件源码分析</a></li><h4 class="categoryHeader_Xx2W">RegisterCenter</h4><li class="sidebarItem_v502"><a class="sidebarItemLink_yJnx" href="/zh/blog/RegisterCenter-SourceCode-Analysis-Http-Register">注册中心实现原理之Http注册</a></li><h4 class="categoryHeader_Xx2W">SPI</h4><li class="sidebarItem_v502"><a class="sidebarItemLink_yJnx" href="/zh/blog/SPI-SourceCode-Analysis-LoadBalance-SPI">LoadBalance SPI 代码分析</a></li><li class="sidebarItem_v502"><a class="sidebarItemLink_yJnx" href="/zh/blog/SPI-SourceCode-Analysis-MatchStrategy-SPI">MatchStrategy--基于SPI的代码分析</a></li><li class="sidebarItem_v502"><a class="sidebarItemLink_yJnx" href="/zh/blog/SPI-SourceCode-Analysis-PredicateJudge-SPI">PredicateJudge-- 基于SPI的设计实现分析</a></li><h4 class="categoryHeader_Xx2W">code</h4><li class="sidebarItem_v502"><a class="sidebarItemLink_yJnx" href="/zh/blog/code-analysis-ratelimiter-spi">RateLimiter SPI 代码分析</a></li><h4 class="categoryHeader_Xx2W">Start</h4><li class="sidebarItem_v502"><a class="sidebarItemLink_yJnx" href="/zh/blog/Start-SourceCode-Analysis-Start-Demo">Apache ShenYu 启动示例</a></li></ul></nav></aside><main class="col col--7"><article class="margin-bottom--xl"><header><h2 class="blogPostTitle_d4p0"><a href="/zh/blog/DataSync-SourceCode-Analysis-Http-Data-Sync">Http长轮询数据同步源码分析</a></h2><div class="blogPostData_-Im+ margin-vert--md"><time datetime="2021-12-14T03:31:25.749Z">2021年12月14日</time> · One min read</div><div class="avatar margin-vert--md"><div class="avatar__intro"><div class="avatar__name"><a href="https://github.com/midnight2104" target="_blank" rel="noopener noreferrer">midnight2104</a></div><small class="avatar__subtitle">Apache ShenYu Committer</small></div></div></header><div class="markdown"><blockquote><p><a href="https://shenyu.apache.org/zh/docs/index" target="_blank" rel="noopener noreferrer">Apache ShenYu</a> 是一个异步的，高性能的，跨语言的，响应式的 <code>API</code> 网关。</p></blockquote><p>在<code>ShenYu</code>网关中，数据同步是指，当在后台管理系统中，数据发送了更新后，如何将更新的数据同步到网关中。<code>Apache ShenYu</code> 网关当前支持<code>ZooKeeper</code>、<code>WebSocket</code>、<code>Http长轮询</code>、<code>Nacos</code> 、<code>Etcd</code> 和 <code>Consul</code> 进行数据同步。本文的主要内容是基于<code>Http长轮询</code>的数据同步源码分析。</p><blockquote><p>本文基于<code>shenyu-2.4.0</code>版本进行源码分析，官网的介绍请参考 <a href="https://shenyu.apache.org/zh/docs/design/data-sync" target="_blank" rel="noopener noreferrer">数据同步原理</a> 。</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="1-http长轮询"></a>1. Http长轮询<a class="hash-link" href="#1-http长轮询" title="Direct link to heading">#</a></h3><p>这里直接引用官网的相关描述：</p><blockquote><p><code>Zookeeper</code>和<code>WebSocket</code> 数据同步的机制比较简单，而 <code>Http长轮询</code>则比较复杂。 <code>Apache ShenYu</code> 借鉴了 <code>Apollo</code>、<code>Nacos</code> 的设计思想，取其精华，自己实现了 <code>Http长轮询</code>数据同步功能。注意，这里并非传统的 <code>ajax</code> 长轮询！</p></blockquote><p><img src="/zh/assets/images/http-long-polling-zh-32f8ebfb4e3ecd2bc3b2bb3f9b2edd2d.png"></p><p><code>Http长轮询</code> 机制如上所示，<code>Apache ShenYu</code>网关主动请求 <code>shenyu-admin</code> 的配置服务，读取超时时间为 <code>90s</code>，意味着网关层请求配置服务最多会等待 <code>90s</code>，这样便于 <code>shenyu-admin</code> 配置服务及时响应变更数据，从而实现准实时推送。</p><p><code>Http长轮询</code> 机制是由网关主动请求 <code>shenyu-admin</code> ，所以这次的源码分析，我们从网关这一侧开始。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="2-网关数据同步"></a>2. 网关数据同步<a class="hash-link" href="#2-网关数据同步" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="21-加载配置"></a>2.1 加载配置<a class="hash-link" href="#21-加载配置" title="Direct link to heading">#</a></h4><p><code>Http长轮询</code> 数据同步配置的加载是通过<code>spring boot</code>的<code>starter</code>机制，当我们引入相关依赖和在配置文件中有如下配置时，就会加载。</p><p>在<code>pom</code>文件中引入依赖：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI xm"><pre tabindex="0" class="prism-code language-xm codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;!--shenyu data sync start use http--&gt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;dependency&gt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;groupId&gt;org.apache.shenyu&lt;/groupId&gt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;artifactId&gt;shenyu-spring-boot-starter-sync-data-http&lt;/artifactId&gt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;version&gt;${project.version}&lt;/version&gt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;/dependency&gt;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在<code>application.yml</code>配置文件中添加配置：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI yaml"><pre tabindex="0" class="prism-code language-yaml codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token key atrule" style="color:#00a4db">shenyu</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">sync</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">       </span><span class="token key atrule" style="color:#00a4db">http</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">          </span><span class="token key atrule" style="color:#00a4db">url</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> http</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain">//localhost</span><span class="token punctuation" style="color:#393A34">:</span><span class="token number" style="color:#36acaa">9095</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>当网关启动时，配置类<code>HttpSyncDataConfiguration</code>就会执行，加载相应的<code>Bean</code>。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Http sync data configuration for spring boot.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Configuration</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@ConditionalOnClass(HttpSyncDataService.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@ConditionalOnProperty(prefix = &quot;shenyu.sync.http&quot;, name = &quot;url&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Slf4j</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class HttpSyncDataConfiguration {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Http sync data service.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 创建 HttpSyncDataService </span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param httpConfig         http的配置</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param pluginSubscriber   插件数据订阅</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param metaSubscribers    元数据订阅</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param authSubscribers    认证数据订阅</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the sync data service</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public SyncDataService httpSyncDataService(final ObjectProvider&lt;HttpConfig&gt; httpConfig, final ObjectProvider&lt;PluginDataSubscriber&gt; pluginSubscriber,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                           final ObjectProvider&lt;List&lt;MetaDataSubscriber&gt;&gt; metaSubscribers, final ObjectProvider&lt;List&lt;AuthDataSubscriber&gt;&gt; authSubscribers) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        log.info(&quot;you use http long pull sync shenyu data&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new HttpSyncDataService(Objects.requireNonNull(httpConfig.getIfAvailable()), Objects.requireNonNull(pluginSubscriber.getIfAvailable()),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                metaSubscribers.getIfAvailable(Collections::emptyList), authSubscribers.getIfAvailable(Collections::emptyList));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Http config http config.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 读取http的配置</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the http config</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @ConfigurationProperties(prefix = &quot;shenyu.sync.http&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public HttpConfig httpConfig() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new HttpConfig();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><code>HttpSyncDataConfiguration</code>是<code>Http长轮询</code>数据同步的配置类，负责创建<code>HttpSyncDataService</code>（负责<code>http</code>数据同步的具体实现）和<code>HttpConfig</code>（<code>admin</code>属性配置）。它的注解如下：</p><ul><li><code>@Configuration</code>：表示这是一个配置类；</li><li><code>@ConditionalOnClass(HttpSyncDataService.class)</code>：条件注解，表示要有<code>HttpSyncDataService</code>这个类；</li><li><code>@ConditionalOnProperty(prefix = &quot;shenyu.sync.http&quot;, name = &quot;url&quot;)</code>：条件注解，要有<code>shenyu.sync.http.url</code>这个属性配置。</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="22-属性初始化"></a>2.2 属性初始化<a class="hash-link" href="#22-属性初始化" title="Direct link to heading">#</a></h4><ul><li>HttpSyncDataService</li></ul><p>在<code>HttpSyncDataService</code>的构造函数中，完成属性初始化。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public class HttpSyncDataService implements SyncDataService, AutoCloseable {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 省略了属性字段......</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public HttpSyncDataService(final HttpConfig httpConfig, final PluginDataSubscriber pluginDataSubscriber, final List&lt;MetaDataSubscriber&gt; metaDataSubscribers, final List&lt;AuthDataSubscriber&gt; authDataSubscribers) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 1.创建数据处理器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.factory = new DataRefreshFactory(pluginDataSubscriber, metaDataSubscribers, authDataSubscribers);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 2.获取admin属性配置</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.httpConfig = httpConfig;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // shenyu-admin的url， 多个用逗号(,)分割</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.serverList = Lists.newArrayList(Splitter.on(&quot;,&quot;).split(httpConfig.getUrl()));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 3.创建httpClient，用于向admin发起请求</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.httpClient = createRestTemplate();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 4.开始执行长轮询任务</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.start();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>上面代码中省略了其他函数和相关字段，在构造函数中完成属性的初始化，主要是：</p><ul><li><p>创建数据处理器，用于后续缓存各种类型的数据（插件、选择器、规则、元数据和认证数据）；</p></li><li><p>获取<code>admin</code>属性配置，主要是获取<code>admin</code>的<code>url</code>，<code>admin</code>有可能是集群，多个用逗号<code>(,)</code>分割；</p></li><li><p>创建<code>httpClient</code>，使用的是<code>RestTemplate</code>，用于向<code>admin</code>发起请求；</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    private RestTemplate createRestTemplate() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        OkHttp3ClientHttpRequestFactory factory = new OkHttp3ClientHttpRequestFactory();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 建立连接超时时间为 10s</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        factory.setConnectTimeout((int) this.connectionTimeout.toMillis());</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 网关主动请求 shenyu-admin 的配置服务，读取超时时间为 90s</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        factory.setReadTimeout((int) HttpConstants.CLIENT_POLLING_READ_TIMEOUT);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new RestTemplate(factory);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></li><li><p>开始执行长轮询任务。</p></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="23-开始长轮询"></a>2.3 开始长轮询<a class="hash-link" href="#23-开始长轮询" title="Direct link to heading">#</a></h4><ul><li>HttpSyncDataService#start()</li></ul><p>在<code>start()</code>方法中，干了两件事情，一个是获取全量数据，即请求<code>admin</code>端获取所有需要同步的数据，然后将获取到的数据缓存到网关内存中。另一个是开启多线程执行长轮询任务。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">private void start() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 只初始化一次，通过原子类实现。 </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        RUNNING = new AtomicBoolean(false);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // It could be initialized multiple times, so you need to control that.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (RUNNING.compareAndSet(false, true)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // fetch all group configs.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 初次启动，获取全量数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.fetchGroupConfig(ConfigGroupEnum.values());</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 一个后台服务，一个线程</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            int threadSize = serverList.size();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 自定义线程池</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.executor = new ThreadPoolExecutor(threadSize, threadSize, 60L, TimeUnit.SECONDS,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    new LinkedBlockingQueue&lt;&gt;(),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ShenyuThreadFactory.create(&quot;http-long-polling&quot;, true));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // start long polling, each server creates a thread to listen for changes.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 开始长轮询，一个admin服务，创建一个线程用于数据同步</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.serverList.forEach(server -&gt; this.executor.execute(new HttpLongPollingTask(server)));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            log.info(&quot;shenyu http long polling was started, executor=[{}]&quot;, executor);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="231-获取全量数据"></a>2.3.1 获取全量数据<a class="hash-link" href="#231-获取全量数据" title="Direct link to heading">#</a></h5><ul><li>HttpSyncDataService#fetchGroupConfig()</li></ul><p><code>ShenYu</code>将所有需要同步的数据进行了分组，一共有5种数据类型，分别是插件、选择器、规则、元数据和认证数据。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public enum ConfigGroupEnum {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    APP_AUTH, // 认证数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    PLUGIN, //插件</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    RULE, // 规则</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    SELECTOR, // 选择器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    META_DATA; // 元数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><code>admin</code>有可能是集群，这里通过循环的方式向每个<code>admin</code>发起请求，有一个执行成功了，那么向<code>admin</code>获取全量数据并缓存到网关的操作就执行成功。如果出现了异常，就向下一个<code>admin</code>发起请求。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">private void fetchGroupConfig(final ConfigGroupEnum... groups) throws ShenyuException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // admin有可能是集群，这里通过循环的方式向每个admin发起请求</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int index = 0; index &lt; this.serverList.size(); index++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            String server = serverList.get(index);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 真正去执行</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                this.doFetchGroupConfig(server, groups);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 有一个成功，就成功了，可以退出循环</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (ShenyuException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 出现异常，尝试执行下一个</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 最后一个也执行失败了，抛出异常</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // no available server, throw exception.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (index &gt;= serverList.size() - 1) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    throw e;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                log.warn(&quot;fetch config fail, try another one: {}&quot;, serverList.get(index + 1));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>HttpSyncDataService#doFetchGroupConfig()</li></ul><p>在此方法中，首先拼装请求参数，然后通过<code>httpClient</code>发起请求，到<code>admin</code>中获取数据，最后将获取到的数据更新到网关内存中。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// 向admin后台管理系统发起请求，获取所有同步数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">private void doFetchGroupConfig(final String server, final ConfigGroupEnum... groups) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 1. 拼请求参数，所有分组枚举类型</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    StringBuilder params = new StringBuilder();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (ConfigGroupEnum groupKey : groups) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        params.append(&quot;groupKeys&quot;).append(&quot;=&quot;).append(groupKey.name()).append(&quot;&amp;&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // admin端提供的接口  /configs/fetch</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    String url = server + &quot;/configs/fetch?&quot; + StringUtils.removeEnd(params.toString(), &quot;&amp;&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    log.info(&quot;request configs: [{}]&quot;, url);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    String json = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 2. 发起请求，获取变更数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        json = this.httpClient.getForObject(url, String.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (RestClientException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String message = String.format(&quot;fetch config fail from server[%s], %s&quot;, url, e.getMessage());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        log.warn(message);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new ShenyuException(message, e);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // update local cache</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 3. 更新网关内存中数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean updated = this.updateCacheWithJson(json);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 更新成功，此方法就执行完成了</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (updated) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        log.info(&quot;get latest configs: [{}]&quot;, json);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // not updated. it is likely that the current config server has not been updated yet. wait a moment.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    log.info(&quot;The config of the server[{}] has not been updated or is out of date. Wait for 30s to listen for changes again.&quot;, server);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 服务端没有数据更新，就等30s</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ThreadUtils.sleep(TimeUnit.SECONDS, 30);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>从代码中，可以看到 <code>admin</code>端提供的获取全量数据接口是  <code>/configs/fetch</code>，这里先不进一步深入，放在后文再分析。</p><p>获取到<code>admin</code>返回结果数据，并成功更新，那么此方法就执行结束了。如果没有更新成功，那么有可能是服务端没有数据更新，就等待<code>30s</code>。</p><p>这里需要提前说明一下，网关在判断是否更新成功时，有比对数据的操作，马上就会提到。</p><ul><li>HttpSyncDataService#updateCacheWithJson()</li></ul><p>更新网关内存中的数据。使用<code>GSON</code>进行反序列化，从属性<code>data</code>中拿真正的数据，然后交给<code>DataRefreshFactory</code>去做更新。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    private boolean updateCacheWithJson(final String json) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 使用GSON进行反序列化</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        JsonObject jsonObject = GSON.fromJson(json, JsonObject.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        JsonObject data = jsonObject.getAsJsonObject(&quot;data&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // if the config cache will be updated?</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return factory.executor(data);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>DataRefreshFactory#executor()</li></ul><p>根据不同数据类型去更新数据，返回更新结果。这里采用了<code>parallelStream()</code>进行并行更新，具体更新逻辑交给了<code>dataRefresh.refresh()</code>方法。在更新结果中，有一种数据类型进行了更新，就表示此次操作发生了更新。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean executor(final JsonObject data) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //并行更新数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;Boolean&gt; result = ENUM_MAP.values().parallelStream()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .map(dataRefresh -&gt; dataRefresh.refresh(data))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .collect(Collectors.toList());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //有一个更新就表示此次发生了更新操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return result.stream().anyMatch(Boolean.TRUE::equals);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>AbstractDataRefresh#refresh()</li></ul><p>数据更新逻辑采用的是模板方法设计模式，通用操作在抽象方法中完成，不同的实现逻辑由子类完成。5种数据类型具体的更新逻辑有些差异，但是也存在通用的更新逻辑，类图关系如下：</p><p><img src="/zh/assets/images/data-refresh-02251aec949f57ecc3083659fafc0313.png"></p><p>在通用的<code>refresh()</code>方法中，负责数据类型转换，判断是否需要更新，和实际的数据刷新操作。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Boolean refresh(final JsonObject data) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean updated = false;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 数据类型转换</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        JsonObject jsonObject = convert(data);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (null != jsonObject) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 得到数据类型</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            ConfigData&lt;T&gt; result = fromJson(jsonObject);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 是否需要更新</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (this.updateCacheIfNeed(result)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                updated = true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 真正的更新逻辑，数据刷新操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                refresh(result.getData());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return updated;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>AbstractDataRefresh#updateCacheIfNeed()</li></ul><p>数据转换的过程，就是根据不同的数据类型进行转换，我们就不再进一步追踪了，看看数据是否需要更新的逻辑。方法名是<code>updateCacheIfNeed()</code>，通过方法重载实现。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// result是数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">protected abstract boolean updateCacheIfNeed(ConfigData&lt;T&gt; result);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// newVal是获取到的最新的值</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// groupEnum 是哪种数据类型</span></span><span class="token-line" style="color:#393A34"><span class="token plain">protected boolean updateCacheIfNeed(final ConfigData&lt;T&gt; newVal, final ConfigGroupEnum groupEnum) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果是第一次，那么直接放到cache中，返回 true，表示此次进行了更新</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (GROUP_CACHE.putIfAbsent(groupEnum, newVal) == null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ResultHolder holder = new ResultHolder(false);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        GROUP_CACHE.merge(groupEnum, newVal, (oldVal, value) -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // md5 值相同，不需要更新</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (StringUtils.equals(oldVal.getMd5(), newVal.getMd5())) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                log.info(&quot;Get the same config, the [{}] config cache will not be updated, md5:{}&quot;, groupEnum, oldVal.getMd5());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                return oldVal;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 当前缓存的数据修改时间大于 新来的数据，不需要更新</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // must compare the last update time</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (oldVal.getLastModifyTime() &gt;= newVal.getLastModifyTime()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                log.info(&quot;Last update time earlier than the current configuration, the [{}] config cache will not be updated&quot;, groupEnum);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                return oldVal;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            log.info(&quot;update {} config: {}&quot;, groupEnum, newVal);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            holder.result = true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return newVal;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return holder.result;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>从上面的源码中可以看到，有两种情况不需要更新：</p><ul><li>两个的数据的<code>md5</code> 值相同，不需要更新;</li><li>当前缓存的数据修改时间大于 新来的数据，不需要更新。</li></ul><p>其他情况需要更新数据。</p><p>分析到这里，就将<code>start()</code> 方法中初次启动，获取全量数据的逻辑分析完了，接下来是长轮询的操作。为了方便，我将<code>start()</code>方法再粘贴一次：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    private void start() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // It could be initialized multiple times, so you need to control that.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (RUNNING.compareAndSet(false, true)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // fetch all group configs.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 初次启动，获取全量数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.fetchGroupConfig(ConfigGroupEnum.values());</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 一个后台服务，一个线程</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            int threadSize = serverList.size();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 自定义线程池</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.executor = new ThreadPoolExecutor(threadSize, threadSize, 60L, TimeUnit.SECONDS,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    new LinkedBlockingQueue&lt;&gt;(),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ShenyuThreadFactory.create(&quot;http-long-polling&quot;, true));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // start long polling, each server creates a thread to listen for changes.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 开始长轮询，一个admin服务，创建一个线程用于数据同步</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.serverList.forEach(server -&gt; this.executor.execute(new HttpLongPollingTask(server)));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            log.info(&quot;shenyu http long polling was started, executor=[{}]&quot;, executor);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="232-执行长轮询任务"></a>2.3.2 执行长轮询任务<a class="hash-link" href="#232-执行长轮询任务" title="Direct link to heading">#</a></h5><ul><li>HttpLongPollingTask#run()</li></ul><p>长轮询任务是<code>HttpLongPollingTask</code>，它实现了<code>Runnable</code>接口，任务逻辑在<code>run()</code>方法中。通过<code>while()</code>循环实现不断执行任务，即长轮询。在每一次的轮询中有三次重试逻辑，一次轮询任务失败了，等 <code>5s</code> 再继续，<code>3</code> 次都失败了，等<code>5</code> 分钟再试。</p><p>开始长轮询，一个<code>admin</code>服务，创建一个线程用于数据同步。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">class HttpLongPollingTask implements Runnable {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        private String server;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 默认重试 3 次</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        private final int retryTimes = 3;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        HttpLongPollingTask(final String server) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.server = server;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 一直轮询</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (RUNNING.get()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (int time = 1; time &lt;= retryTimes; time++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        doLongPolling(server);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } catch (Exception e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // print warnning log.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if (time &lt; retryTimes) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            log.warn(&quot;Long polling failed, tried {} times, {} times left, will be suspended for a while! {}&quot;,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    time, retryTimes - time, e.getMessage());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            // 长轮询失败了，等 5s 再继续</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            ThreadUtils.sleep(TimeUnit.SECONDS, 5);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            continue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // print error, then suspended for a while.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        log.error(&quot;Long polling failed, try again after 5 minutes!&quot;, e);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 3 次都失败了，等 5 分钟再试</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ThreadUtils.sleep(TimeUnit.MINUTES, 5);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            log.warn(&quot;Stop http long polling.&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>HttpSyncDataService#doLongPolling()</li></ul><p>执行长轮询任务的核心逻辑：</p><ul><li>根据数据类型组装请求参数：<code>md5</code> 和 <code>lastModifyTime</code>；</li><li>组装请求头和请求体；</li><li>向<code>admin</code>发起请求，判断组数据是否发生变更；</li><li>根据发生变更的组，再去获取数据。</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">private void doLongPolling(final String server) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 组装请求参数：md5 和 lastModifyTime</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        MultiValueMap&lt;String, String&gt; params = new LinkedMultiValueMap&lt;&gt;(8);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (ConfigGroupEnum group : ConfigGroupEnum.values()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            ConfigData&lt;?&gt; cacheConfig = factory.cacheConfigData(group);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (cacheConfig != null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                String value = String.join(&quot;,&quot;, cacheConfig.getMd5(), String.valueOf(cacheConfig.getLastModifyTime()));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                params.put(group.name(), Lists.newArrayList(value));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 组装请求头和请求体</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        HttpHeaders headers = new HttpHeaders();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        HttpEntity httpEntity = new HttpEntity(params, headers);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String listenerUrl = server + &quot;/configs/listener&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        log.debug(&quot;request listener configs: [{}]&quot;, listenerUrl);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        JsonArray groupJson = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //向admin发起请求，判断组数据是否发生变更</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //这里只是判断了某个组是否发生变更</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            String json = this.httpClient.postForEntity(listenerUrl, httpEntity, String.class).getBody();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            log.debug(&quot;listener result: [{}]&quot;, json);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            groupJson = GSON.fromJson(json, JsonObject.class).getAsJsonArray(&quot;data&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (RestClientException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            String message = String.format(&quot;listener configs fail, server:[%s], %s&quot;, server, e.getMessage());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new ShenyuException(message, e);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 根据发生变更的组，再去获取数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 官网对此处的解释：</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 网关收到响应信息之后，只知道是哪个 Group 发生了配置变更，还需要再次请求该 Group 的配置数据。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 这里可能会存在一个疑问：为什么不是直接将变更的数据写出？</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 我们在开发的时候，也深入讨论过该问题，因为 http 长轮询机制只能保证准实时，如果在网关层处理不及时，</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 或者管理员频繁更新配置，很有可能便错过了某个配置变更的推送，安全起见，我们只告知某个 Group 信息发生了变更。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 个人理解：</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 如果将变更数据直接写出，当管理员频繁更新配置时，第一次更新了，将client移除阻塞队列，返回响应信息给网关。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 如果这个时候进行了第二次更新，那么当前的client是不在阻塞队列中，所以这一次的变更就会错过。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 网关层处理不及时，也是同理。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 这是一个长轮询，一个网关一个同步线程，可能存在耗时的过程。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 如果admin有数据变更，当前网关client是没有在阻塞队列中，就不到数据。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (groupJson != null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // fetch group configuration async.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            ConfigGroupEnum[] changedGroups = GSON.fromJson(groupJson, ConfigGroupEnum[].class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ArrayUtils.isNotEmpty(changedGroups)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                log.info(&quot;Group config changed: {}&quot;, Arrays.toString(changedGroups));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 主动向admin获取变更的数据，根据分组不同，全量拿数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                this.doFetchGroupConfig(server, changedGroups);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这里需要特别解释一点的是：在长轮询任务中，为什么不直接拿到变更的数据？而是先判断哪个分组数据发生了变更，然后再次请求<code>admin</code>，获取变更数据？</p><p>官网对此处的解释是：</p><blockquote><p>网关收到响应信息之后，只知道是哪个 Group 发生了配置变更，还需要再次请求该 Group 的配置数据。
这里可能会存在一个疑问：为什么不是直接将变更的数据写出？
我们在开发的时候，也深入讨论过该问题，因为 <code>http</code> 长轮询机制只能保证准实时，如果在网关层处理不及时，
或者管理员频繁更新配置，很有可能便错过了某个配置变更的推送，安全起见，我们只告知某个 Group 信息发生了变更。</p></blockquote><p>个人理解是：</p><blockquote><p>如果将变更数据直接写出，管理员频繁更新配置时，第一次更新了，将<code>client</code>移除阻塞队列，返回响应信息给网关。如果这个时候进行了第二次更新，那么当前的<code>client</code>是不在阻塞队列中，所以这一次的变更就会错过。网关层处理不及时，也是同理。 这是一个长轮询，一个网关一个同步线程，可能存在耗时的过程。如果<code>admin</code>有数据变更，当前网关client是没有在阻塞队列中，就不到数据。</p></blockquote><p>我们还没有分析到<code>admin</code>端的处理逻辑，先大概说一下。在<code>admin</code>端，会将网关<code>client</code>放到阻塞队列，有数据变更，网关<code>client</code>就会出队列，发送变更数据。所以，如果有数据变更时，网关<code>client</code>不在阻塞队列，那么就无法得到当前变更的数据。</p><p>知道哪个分组数据发生变更时，主动再向<code>admin</code>获取变更的数据，根据分组不同，全量拿数据。调用方法是<code>doFetchGroupConfig()</code>，这个在前面已经分析过了。</p><p>分析到这里，网关端的数据同步操作就完成了。长轮询任务就是不断向<code>admin</code>发起请求，看看数据是否发生变更，如果有分组数据发生变更，那么就再主动向<code>admin</code>发起请求，获取变更数据，然后更新网关内存中的数据。</p><p>网关端长轮询任务流程：</p><p><img src="/zh/assets/images/http-long-polling-sequence-zh-6a86a913a7f604f509bcda7ea4d07aa5.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="3-admin数据同步"></a>3. admin数据同步<a class="hash-link" href="#3-admin数据同步" title="Direct link to heading">#</a></h3><p>从前面分析的过程中，可以看到，网关端主要调用<code>admin</code>的两个接口：</p><ul><li><code>/configs/listener</code>：判断组数据是否发生变更；</li><li><code>/configs/fetch</code>：获取变更组数据。</li></ul><p>直接从这两个接口分析的话，可能有的地方不好理解，所以我们还是从<code>admin</code>启动流程开始分析数据同步过程。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="31-加载配置"></a>3.1 加载配置<a class="hash-link" href="#31-加载配置" title="Direct link to heading">#</a></h4><p>如果在配置文件<code>application.yml</code>中，进行了如下配置，就表示通过<code>http长轮询</code>的方式进行数据同步。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI yaml"><pre tabindex="0" class="prism-code language-yaml codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token key atrule" style="color:#00a4db">shenyu</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">sync</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">http</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token key atrule" style="color:#00a4db">enabled</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token boolean important" style="color:#36acaa">true</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>程序启动时，通过<code>springboot</code>条件装配实现数据同步类的配置加载。在这个过程中，会创建<code>HttpLongPollingDataChangedListener</code>，负责处理长轮询的相关实现逻辑。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 数据同步配置类</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 通过springboot条件装配实现</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * The type Data sync configuration.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Configuration</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class DataSyncConfiguration {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * http长轮询</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * http long polling.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Configuration</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @ConditionalOnProperty(name = &quot;shenyu.sync.http.enabled&quot;, havingValue = &quot;true&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @EnableConfigurationProperties(HttpSyncProperties.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    static class HttpLongPollingListener {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @ConditionalOnMissingBean(HttpLongPollingDataChangedListener.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public HttpLongPollingDataChangedListener httpLongPollingDataChangedListener(final HttpSyncProperties httpSyncProperties) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return new HttpLongPollingDataChangedListener(httpSyncProperties);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="32-数据变更监听器实例化"></a>3.2 数据变更监听器实例化<a class="hash-link" href="#32-数据变更监听器实例化" title="Direct link to heading">#</a></h4><ul><li>HttpLongPollingDataChangedListener</li></ul><p>数据变更监听器通过构造函数的方式完成实例化和初始化操作。在构造函数中会创建阻塞队列，用于存放客户端；创建线程池，用于执行延迟任务，周期任务；保存长轮询相关属性信息。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    public HttpLongPollingDataChangedListener(final HttpSyncProperties httpSyncProperties) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 默认客户端（这里是网关）1024个</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.clients = new ArrayBlockingQueue&lt;&gt;(1024);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建线程池</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // ScheduledThreadPoolExecutor 可以执行延迟任务，周期任务，普通任务</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.scheduler = new ScheduledThreadPoolExecutor(1,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                ShenyuThreadFactory.create(&quot;long-polling&quot;, true));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 长轮询的属性信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.httpSyncProperties = httpSyncProperties;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>另外，它的类图关系如下：</p><p><img src="/zh/assets/images/data-changed-listener-86ba5f63c9906b88b128fd557f0b10ec.png"></p><p>实现了<code>InitializingBean</code>接口，所以在<code>bean</code>的初始化过程中执行<code>afterInitialize()</code>方法。通过线程池执行周期任务：更新内存中<code>（CACHE）</code>的数据每隔<code>5</code>分钟执行一次，<code>5</code>分钟后开始执行。刷新本地缓存就是从数据库读取数据到本地缓存（这里就是内存），通过<code>refreshLocalCache()</code>完成。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 在 InitializingBean接口中的afterPropertiesSet()方法中被调用，即在bean的初始化过程中执行</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected void afterInitialize() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        long syncInterval = httpSyncProperties.getRefreshInterval().toMillis();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Periodically check the data for changes and update the cache</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 执行周期任务：更新内存中（CACHE）的数据每隔5分钟执行一次，5分钟后开始执行</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 防止admin先启动一段时间后，产生了数据；然后网关初次连接时，没有拿到全量数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        scheduler.scheduleWithFixedDelay(() -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            log.info(&quot;http sync strategy refresh config start.&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 从数据库读取数据到本地缓存（这里就是内存）</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                this.refreshLocalCache();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                log.info(&quot;http sync strategy refresh config success.&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (Exception e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                log.error(&quot;http sync strategy refresh config error!&quot;, e);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }, syncInterval, syncInterval, TimeUnit.MILLISECONDS);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        log.info(&quot;http sync strategy refresh interval: {}ms&quot;, syncInterval);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>refreshLocalCache()</li></ul><p>分别对5种数据类型进行更新。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    // 从数据库读取数据到本地缓存（这里就是内存）</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void refreshLocalCache() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //更新认证数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.updateAppAuthCache();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //更新插件数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.updatePluginCache();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //更新规则数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.updateRuleCache();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //更新选择器数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.updateSelectorCache();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //更新元数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.updateMetaDataCache();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>5个更新方法的逻辑是类似的，调用<code>service</code>方法获取数据，然后放到内存<code>CACHE</code>中。以更新规则数据方法<code>updateRuleCache()</code>为例，传入规则枚举类型，调用<code>ruleService.listAll()</code>从数据库获取所有规则数据。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Update rule cache.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected void updateRuleCache() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.updateCache(ConfigGroupEnum.RULE, ruleService.listAll());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>updateCache()</li></ul><p>使用数据库中的数据更新内存中的数据。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// 缓存数据的 Map</span></span><span class="token-line" style="color:#393A34"><span class="token plain">protected static final ConcurrentMap&lt;String, ConfigDataCache&gt; CACHE = new ConcurrentHashMap&lt;&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * if md5 is not the same as the original, then update lcoal cache.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 更新缓存中的数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param group ConfigGroupEnum</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param &lt;T&gt; the type of class</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param data the new config data</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected &lt;T&gt; void updateCache(final ConfigGroupEnum group, final List&lt;T&gt; data) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //数据序列化</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String json = GsonUtils.getInstance().toJson(data);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //传入md5值和修改时间</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ConfigDataCache newVal = new ConfigDataCache(group.name(), json, Md5Utils.md5(json), System.currentTimeMillis());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //更新分组数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ConfigDataCache oldVal = CACHE.put(newVal.getGroup(), newVal);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        log.info(&quot;update config cache[{}], old: {}, updated: {}&quot;, group, oldVal, newVal);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>初始化的过程就是启动周期性任务，定时从数据库获取数据更新内存数据。</p><p>接下来开始对两个接口开始分析：</p><ul><li><code>/configs/listener</code>：判断组数据是否发生变更；</li><li><code>/configs/fetch</code>：获取变更组数据。</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="33--数据变更轮询接口"></a>3.3  数据变更轮询接口<a class="hash-link" href="#33--数据变更轮询接口" title="Direct link to heading">#</a></h4><ul><li><code>/configs/listener</code>：判断组数据是否发生变更；</li></ul><p>接口类是<code>ConfigController</code>，只有使用<code>http长轮询</code>进行数据同步时才会生效。接口方法<code>listener()</code>没有其他逻辑，直接调用<code>doLongPolling()</code>方法。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">   </span></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * This Controller only when HttpLongPollingDataChangedListener exist, will take effect.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@ConditionalOnBean(HttpLongPollingDataChangedListener.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@RestController</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@RequestMapping(&quot;/configs&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Slf4j</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ConfigController {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Resource</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private HttpLongPollingDataChangedListener longPollingListener;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 省略其他逻辑</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Listener.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 监听数据变更，执行长轮询</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param request  the request</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param response the response</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @PostMapping(value = &quot;/listener&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void listener(final HttpServletRequest request, final HttpServletResponse response) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        longPollingListener.doLongPolling(request, response);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>HttpLongPollingDataChangedListener#doLongPolling()</li></ul><p>执行长轮询任务：如果有数据变更，将会立即响应给客户端（这里就是网关端）。否则，客户端会一直被阻塞，直到有数据变更或者超时。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 执行长轮询：如果有数据变更，会立即响应给客户端（这里就是网关端）。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 否则，否则客户端会一直被阻塞，直到有数据变更或者超时。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param request</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param response</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void doLongPolling(final HttpServletRequest request, final HttpServletResponse response) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // compare group md5</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 比较md5，判断网关的数据和admin端的数据是否一致，得到发生变更的数据组</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;ConfigGroupEnum&gt; changedGroup = compareChangedGroup(request);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String clientIp = getRemoteIp(request);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // response immediately.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 有变更的数据，则立即向网关响应</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (CollectionUtils.isNotEmpty(changedGroup)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.generateResponse(response, changedGroup);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            log.info(&quot;send response with the changed group, ip={}, group={}&quot;, clientIp, changedGroup);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         // 没有变更，则将客户端（这里就是网关）放进阻塞队列</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // listen for configuration changed.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        final AsyncContext asyncContext = request.startAsync();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // AsyncContext.settimeout() does not timeout properly, so you have to control it yourself</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        asyncContext.setTimeout(0L);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // block client&#x27;s thread.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        scheduler.execute(new LongPollingClient(asyncContext, clientIp, HttpConstants.SERVER_MAX_HOLD_TIMEOUT));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>HttpLongPollingDataChangedListener#compareChangedGroup()</li></ul><p>判断组数据是否发生变更，判断逻辑是比较网关端和<code>admin</code>端的<code>md5</code>值和<code>lastModifyTime</code>。</p><ul><li>如果<code>md5</code>值不一样，那么需要更新；</li><li>如果<code>admin</code>端的<code>lastModifyTime</code>大于网关端的<code>lastModifyTime</code>，那么需要更新。</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain"> /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 判断组数据是否发生变更</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param request</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private List&lt;ConfigGroupEnum&gt; compareChangedGroup(final HttpServletRequest request) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;ConfigGroupEnum&gt; changedGroup = new ArrayList&lt;&gt;(ConfigGroupEnum.values().length);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (ConfigGroupEnum group : ConfigGroupEnum.values()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 网关端数据的md5值和lastModifyTime</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            String[] params = StringUtils.split(request.getParameter(group.name()), &#x27;,&#x27;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (params == null || params.length != 2) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw new ShenyuException(&quot;group param invalid:&quot; + request.getParameter(group.name()));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            String clientMd5 = params[0];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            long clientModifyTime = NumberUtils.toLong(params[1]);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            ConfigDataCache serverCache = CACHE.get(group.name());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // do check. 判断组数据是否发生变更</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (this.checkCacheDelayAndUpdate(serverCache, clientMd5, clientModifyTime)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                changedGroup.add(group);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return changedGroup;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>LongPollingClient</li></ul><p>没有变更数据，则将客户端（这里就是网关）放进阻塞队列。阻塞时间是60秒，即60秒后移除，并响应客户端。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">class LongPollingClient implements Runnable {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 省略了其他逻辑</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 60秒后移除，并响应客户端</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                this.asyncTimeoutFuture = scheduler.schedule(() -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    clients.remove(LongPollingClient.this);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    List&lt;ConfigGroupEnum&gt; changedGroups = compareChangedGroup((HttpServletRequest) asyncContext.getRequest());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    sendResponse(changedGroups);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }, timeoutTime, TimeUnit.MILLISECONDS);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 添加到阻塞队列</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                clients.add(this);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (Exception ex) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                log.error(&quot;add long polling client error&quot;, ex);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Send response.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @param changedGroups the changed groups</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        void sendResponse(final List&lt;ConfigGroupEnum&gt; changedGroups) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // cancel scheduler</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (null != asyncTimeoutFuture) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                asyncTimeoutFuture.cancel(false);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 响应变更的组</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            generateResponse((HttpServletResponse) asyncContext.getResponse(), changedGroups);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            asyncContext.complete();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="34--获取变更数据接口"></a>3.4  获取变更数据接口<a class="hash-link" href="#34--获取变更数据接口" title="Direct link to heading">#</a></h4><ul><li><code>/configs/fetch</code>：获取变更数据；</li></ul><p>根据网关传入的参数，获取分组数据，返回结果。主要实现方法是<code>longPollingListener.fetchConfig()</code>。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@ConditionalOnBean(HttpLongPollingDataChangedListener.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@RestController</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@RequestMapping(&quot;/configs&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Slf4j</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ConfigController {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Resource</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private HttpLongPollingDataChangedListener longPollingListener;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Fetch configs shenyu result.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 全量获取分组数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param groupKeys the group keys</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the shenyu result</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @GetMapping(&quot;/fetch&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ShenyuAdminResult fetchConfigs(@NotNull final String[] groupKeys) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Map&lt;String, ConfigData&lt;?&gt;&gt; result = Maps.newHashMap();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (String groupKey : groupKeys) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            ConfigData&lt;?&gt; data = longPollingListener.fetchConfig(ConfigGroupEnum.valueOf(groupKey));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            result.put(groupKey, data);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ShenyuAdminResult.success(ShenyuResultMessage.SUCCESS, result);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 省略了其他接口</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>AbstractDataChangedListener#fetchConfig()</li></ul><p>数据获取直接从<code>CACHE</code>中拿，然后根据不同分组类型进行匹配，封装。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * fetch configuration from cache.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 获取分组下的全量数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param groupKey the group key</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the configuration data</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ConfigData&lt;?&gt; fetchConfig(final ConfigGroupEnum groupKey) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 直接从 CACHE 中拿数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ConfigDataCache config = CACHE.get(groupKey.name()); </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        switch (groupKey) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            case APP_AUTH: // 认证数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                List&lt;AppAuthData&gt; appAuthList = GsonUtils.getGson().fromJson(config.getJson(), new TypeToken&lt;List&lt;AppAuthData&gt;&gt;() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }.getType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                return new ConfigData&lt;&gt;(config.getMd5(), config.getLastModifyTime(), appAuthList);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            case PLUGIN: // 插件数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                List&lt;PluginData&gt; pluginList = GsonUtils.getGson().fromJson(config.getJson(), new TypeToken&lt;List&lt;PluginData&gt;&gt;() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }.getType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                return new ConfigData&lt;&gt;(config.getMd5(), config.getLastModifyTime(), pluginList);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            case RULE:   // 规则数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                List&lt;RuleData&gt; ruleList = GsonUtils.getGson().fromJson(config.getJson(), new TypeToken&lt;List&lt;RuleData&gt;&gt;() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }.getType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                return new ConfigData&lt;&gt;(config.getMd5(), config.getLastModifyTime(), ruleList);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            case SELECTOR:  // 选择器数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                List&lt;SelectorData&gt; selectorList = GsonUtils.getGson().fromJson(config.getJson(), new TypeToken&lt;List&lt;SelectorData&gt;&gt;() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }.getType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                return new ConfigData&lt;&gt;(config.getMd5(), config.getLastModifyTime(), selectorList);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            case META_DATA: // 元数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                List&lt;MetaData&gt; metaList = GsonUtils.getGson().fromJson(config.getJson(), new TypeToken&lt;List&lt;MetaData&gt;&gt;() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }.getType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                return new ConfigData&lt;&gt;(config.getMd5(), config.getLastModifyTime(), metaList);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            default:  // 其他类型，抛出异常</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw new IllegalStateException(&quot;Unexpected groupKey: &quot; + groupKey);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="35-数据变更"></a>3.5 数据变更<a class="hash-link" href="#35-数据变更" title="Direct link to heading">#</a></h4><p>在之前的<code>websocket</code>数据同步和<code>zookeeper</code>数据同步源码分析文章中，我们知道<code>admin</code>端数据同步设计结构如下：</p><p><img src="/zh/assets/images/data-changed-listener-admin-f4fd2d742aac3fc4e133e21c7856dbc0.png"></p><p>各种数据变更监听器都是<code>DataChangedListener</code>的子类。</p><p>当在<code>admin</code>端修改数据后，通过<code>Spring</code>的事件处理机制，发送事件通知。发送逻辑如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Event forwarders, which forward the changed events to each ConfigEventListener.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 数据变更事件分发器：当admin端有数据发生变更时，将变更数据同步到 ShenYu 网关</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 数据变更依赖于Spring的事件监听机制：ApplicationEventPublisher --&gt; ApplicationEvent --&gt; ApplicationListener</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Component</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class DataChangedEventDispatcher implements ApplicationListener&lt;DataChangedEvent&gt;, InitializingBean {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   //省略了其他逻辑</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 有数据变更时，调用此方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param event</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @SuppressWarnings(&quot;unchecked&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onApplicationEvent(final DataChangedEvent event) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 遍历数据变更监听器(一般使用一种数据同步的方式就好了)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (DataChangedListener listener : listeners) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 哪种数据发生变更</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            switch (event.getGroupKey()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case APP_AUTH: // 认证信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onAppAuthChanged((List&lt;AppAuthData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case PLUGIN:  // 插件信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onPluginChanged((List&lt;PluginData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case RULE:    // 规则信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onRuleChanged((List&lt;RuleData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case SELECTOR:   // 选择器信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onSelectorChanged((List&lt;SelectorData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case META_DATA:  // 元数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onMetaDataChanged((List&lt;MetaData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                default:  // 其他类型，抛出异常</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    throw new IllegalStateException(&quot;Unexpected value: &quot; + event.getGroupKey());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>假设，对插件信息进行了修改，通过<code>http长轮询</code>的方式进行数据同步，那么<code>listener.onPluginChanged()</code>的实际调用的是<code>org.apache.shenyu.admin.listener.AbstractDataChangedListener#onPluginChanged</code>：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 在admin的操作，有插件发生了更新</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param changed   the changed</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param eventType the event type</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onPluginChanged(final List&lt;PluginData&gt; changed, final DataEventTypeEnum eventType) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (CollectionUtils.isEmpty(changed)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 更新内存CACHE</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.updatePluginCache();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 执行变更任务</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.afterPluginChanged(changed, eventType);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>有两个处理操作，一是更新内存<code>CACHE</code>，这个在前面分析过了；另一个是执行变更任务，在线程池中执行。</p><ul><li>HttpLongPollingDataChangedListener#afterPluginChanged()</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected void afterPluginChanged(final List&lt;PluginData&gt; changed, final DataEventTypeEnum eventType) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 在线程池中执行</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        scheduler.execute(new DataChangeTask(ConfigGroupEnum.PLUGIN));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>DataChangeTask</li></ul><p>数据变更任务：将阻塞队列中的客户端依次移除，并发送响应，通知网关有组数据发生变更。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">class DataChangeTask implements Runnable {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //省略了其他逻辑 </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 阻塞队列中的客户端超过了给定的值100，则分批执行</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (clients.size() &gt; httpSyncProperties.getNotifyBatchSize()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                List&lt;LongPollingClient&gt; targetClients = new ArrayList&lt;&gt;(clients.size());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                clients.drainTo(targetClients);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                List&lt;List&lt;LongPollingClient&gt;&gt; partitionClients = Lists.partition(targetClients, httpSyncProperties.getNotifyBatchSize());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">               // 分批执行</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                partitionClients.forEach(item -&gt; scheduler.execute(() -&gt; doRun(item)));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 执行任务</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                doRun(clients);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        private void doRun(final Collection&lt;LongPollingClient&gt; clients) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 通知所有客户端发生了数据变更</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (Iterator&lt;LongPollingClient&gt; iter = clients.iterator(); iter.hasNext();) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                LongPollingClient client = iter.next();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                iter.remove();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 发送响应</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                client.sendResponse(Collections.singletonList(groupKey));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                log.info(&quot;send response with the changed group,ip={}, group={}, changeTime={}&quot;, client.ip, groupKey, changeTime);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>至此，<code>admin</code>端数据同步逻辑就分析完了。在基于<code>http长轮询</code>数据同步是，它主要有三个功能：</p><ul><li>提供数据变更监听接口；</li><li>提供获取变更数据接口；</li><li>有数据变更时，移除阻塞队列中的客户端，并响应结果。</li></ul><p>最后，用三张图描述下<code>admin</code>端长轮询任务流程：</p><ul><li><code>/configs/listener</code>数据变更监听接口：</li></ul><p><img src="/zh/assets/images/http-long-polling-listener-zh-c1146f14cc91dd13964f891fad42c4c5.png"></p><ul><li><code>/configs/fetch</code>获取变更数据接口：</li></ul><p><img src="/zh/assets/images/http-long-polling-fetch-zh-fb5fcbe137986b6462c50f6f3fbf49ee.png"></p><ul><li>在admin后台管理系统更新数据，进行数据同步：</li></ul><p><img src="/zh/assets/images/http-long-polling-admin-update-zh-7c54b3adf9cab380ae8d79d47ffc3f59.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="4-总结"></a>4. 总结<a class="hash-link" href="#4-总结" title="Direct link to heading">#</a></h3><p>本文主要对<code>ShenYu</code>网关中的<code>http长轮询</code>数据同步进行了源码分析。涉及到的主要知识点如下：</p><ul><li><code>http长轮询</code>由网关端主动发起请求，不断请求<code>admin</code>端；</li><li>变更数据以组为粒度（认证信息、插件、选择器、规则、元数据）；</li><li><code>http长轮询</code>结果只拿到了变更组，还需要再次发起请求获取组数据；</li><li>数据是否更新由<code>md5</code>值和修改时间<code>lastModifyTime</code>决定。</li></ul></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><a class="margin-horiz--sm" href="/zh/blog/tags/http">http</a><a class="margin-horiz--sm" href="/zh/blog/tags/data-sync">data sync</a><a class="margin-horiz--sm" href="/zh/blog/tags/apache-shen-yu">Apache ShenYu</a></div></footer></article><article class="margin-bottom--xl"><header><h2 class="blogPostTitle_d4p0"><a href="/zh/blog/DataSync-SourceCode-Analysis-WebSocket-Data-Sync">WebSocket数据同步源码分析</a></h2><div class="blogPostData_-Im+ margin-vert--md"><time datetime="2021-12-14T03:31:25.749Z">2021年12月14日</time> · One min read</div><div class="avatar margin-vert--md"><div class="avatar__intro"><div class="avatar__name"><a href="https://github.com/midnight2104" target="_blank" rel="noopener noreferrer">midnight2104</a></div><small class="avatar__subtitle">Apache ShenYu Committer</small></div></div></header><div class="markdown"><p>在<code>ShenYu</code>网关中，数据同步是指，当在后台管理系统中，数据发送了更新后，如何将更新的数据同步到网关中。<code>Apache ShenYu</code> 网关当前支持<code>ZooKeeper</code>、<code>WebSocket</code>、<code>Http长轮询</code>、<code>Nacos</code> 、<code>etcd</code> 和 <code>Consul</code> 进行数据同步。本文的主要内容是基于<code>WebSocket</code>的数据同步源码分析。</p><blockquote><p>本文基于<code>shenyu-2.4.0</code>版本进行源码分析，官网的介绍请参考 <a href="https://shenyu.apache.org/zh/docs/design/data-sync" target="_blank" rel="noopener noreferrer">数据同步原理</a> 。</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="1-关于websocket通信"></a>1. 关于WebSocket通信<a class="hash-link" href="#1-关于websocket通信" title="Direct link to heading">#</a></h3><p><code>WebSocket</code>协议诞生于<code>2008</code>年，在<code>2011</code>年成为国际标准。它可以双向通信，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息。<code>WebSocket</code>协议建立在 <code>TCP</code> 协议之上，属于应用层，性能开销小，通信高效，协议标识符是<code>ws</code>。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="2-admin数据同步"></a>2. Admin数据同步<a class="hash-link" href="#2-admin数据同步" title="Direct link to heading">#</a></h3><p>我们从一个实际案例进行源码追踪，比如在后台管理系统中，新增一条选择器数据：</p><p><img src="/zh/assets/images/add-selector-93ff1008c1b0b4627dd3329abc92a7bd.png"></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="21-接收数据"></a>2.1 接收数据<a class="hash-link" href="#21-接收数据" title="Direct link to heading">#</a></h4><ul><li>SelectorController.createSelector()</li></ul><p>进入<code>SelectorController</code>类中的<code>createSelector()</code>方法，它负责数据的校验，添加或更新数据，返回结果信息。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Validated</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@RequiredArgsConstructor</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@RestController</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@RequestMapping(&quot;/selector&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SelectorController {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @PostMapping(&quot;&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ShenyuAdminResult createSelector(@Valid @RequestBody final SelectorDTO selectorDTO) { // @Valid 数校验</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 添加或更新数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Integer createCount = selectorService.createOrUpdate(selectorDTO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 返回结果信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ShenyuAdminResult.success(ShenyuResultMessage.CREATE_SUCCESS, createCount);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="22-处理数据"></a>2.2 处理数据<a class="hash-link" href="#22-处理数据" title="Direct link to heading">#</a></h4><ul><li>SelectorServiceImpl.createOrUpdate()</li></ul><p>在<code>SelectorServiceImpl</code>类中通过<code>createOrUpdate()</code>方法完成数据的转换，保存到数据库，发布事件，更新<code>upstream</code>。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@RequiredArgsConstructor</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Service</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SelectorServiceImpl implements SelectorService {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 负责事件发布的eventPublisher</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final ApplicationEventPublisher eventPublisher;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Transactional(rollbackFor = Exception.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int createOrUpdate(final SelectorDTO selectorDTO) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int selectorCount;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 构建数据 DTO --&gt; DO</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        SelectorDO selectorDO = SelectorDO.buildSelectorDO(selectorDTO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;SelectorConditionDTO&gt; selectorConditionDTOs = selectorDTO.getSelectorConditions();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 判断是添加还是更新</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (StringUtils.isEmpty(selectorDTO.getId())) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 插入选择器数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectorCount = selectorMapper.insertSelective(selectorDO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 插入选择器中的条件数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectorConditionDTOs.forEach(selectorConditionDTO -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                selectorConditionDTO.setSelectorId(selectorDO.getId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                selectorConditionMapper.insertSelective(SelectorConditionDO.buildSelectorConditionDO(selectorConditionDTO));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // check selector add</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 权限检查</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (dataPermissionMapper.listByUserId(JwtUtils.getUserInfo().getUserId()).size() &gt; 0) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                DataPermissionDTO dataPermissionDTO = new DataPermissionDTO();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                dataPermissionDTO.setUserId(JwtUtils.getUserInfo().getUserId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                dataPermissionDTO.setDataId(selectorDO.getId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                dataPermissionDTO.setDataType(AdminConstants.SELECTOR_DATA_TYPE);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                dataPermissionMapper.insertSelective(DataPermissionDO.buildPermissionDO(dataPermissionDTO));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 更新数据，先删除再新增</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectorCount = selectorMapper.updateSelective(selectorDO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            //delete rule condition then add</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectorConditionMapper.deleteByQuery(new SelectorConditionQuery(selectorDO.getId()));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectorConditionDTOs.forEach(selectorConditionDTO -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                selectorConditionDTO.setSelectorId(selectorDO.getId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                SelectorConditionDO selectorConditionDO = SelectorConditionDO.buildSelectorConditionDO(selectorConditionDTO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                selectorConditionMapper.insertSelective(selectorConditionDO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 发布事件</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        publishEvent(selectorDO, selectorConditionDTOs);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 更新upstream</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        updateDivideUpstream(selectorDO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return selectorCount;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在<code>Service</code>类完成数据的持久化操作，即保存数据到数据库，这个大家应该很熟悉了，就不展开。关于更新<code>upstream</code>操作，放到后面对应的章节中进行分析，重点关注发布事件的操作，它会进行数据同步。</p><p><code>publishEvent()</code>方法的逻辑是：找到选择器对应的插件，构建条件数据，发布变更数据。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">       private void publishEvent(final SelectorDO selectorDO, final List&lt;SelectorConditionDTO&gt; selectorConditionDTOs) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 找到选择器对应的插件</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        PluginDO pluginDO = pluginMapper.selectById(selectorDO.getPluginId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 构建条件数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;ConditionData&gt; conditionDataList =                selectorConditionDTOs.stream().map(ConditionTransfer.INSTANCE::mapToSelectorDTO).collect(Collectors.toList());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 发布变更数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.SELECTOR, DataEventTypeEnum.UPDATE,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                Collections.singletonList(SelectorDO.transFrom(selectorDO, pluginDO.getName(), conditionDataList))));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>发布变更数据通过<code>eventPublisher.publishEvent()</code>完成，这个<code>eventPublisher</code>对象是一个<code>ApplicationEventPublisher</code>类，这个类的全限定名是<code>org.springframework.context.ApplicationEventPublisher</code>。看到这儿，我们知道了发布数据是通过<code>Spring</code>相关的功能来完成的。</p><blockquote><p>关于<code>ApplicationEventPublisher</code>：</p><p>当有状态发生变化时，发布者调用 <code>ApplicationEventPublisher</code> 的 <code>publishEvent</code> 方法发布一个事件，<code>Spring</code>容器广播事件给所有观察者，调用观察者的 <code>onApplicationEvent</code> 方法把事件对象传递给观察者。调用 <code>publishEvent</code>方法有两种途径，一种是实现接口由容器注入 <code>ApplicationEventPublisher</code> 对象然后调用其方法，另一种是直接调用容器的方法，两种方法发布事件没有太大区别。</p><ul><li><code>ApplicationEventPublisher</code>：发布事件；</li><li><code>ApplicationEvent</code>：<code>Spring</code> 事件，记录事件源、时间和数据；</li><li><code>ApplicationListener</code>：事件监听者，观察者。</li></ul></blockquote><p>在<code>Spring</code>的事件发布机制中，有三个对象，</p><p>一个是发布事件的<code>ApplicationEventPublisher</code>，在<code>ShenYu</code>中通过构造器注入了一个<code>eventPublisher</code>。</p><p>另一个对象是<code>ApplicationEvent</code>，在<code>ShenYu</code>中通过<code>DataChangedEvent</code>继承了它，表示事件对象。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public class DataChangedEvent extends ApplicationEvent {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>最后一个是 <code>ApplicationListener</code>，在<code>ShenYu</code>中通过<code>DataChangedEventDispatcher</code>类实现了该接口，作为事件的监听者，负责处理事件对象。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Component</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class DataChangedEventDispatcher implements ApplicationListener&lt;DataChangedEvent&gt;, InitializingBean {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="23-分发数据"></a>2.3 分发数据<a class="hash-link" href="#23-分发数据" title="Direct link to heading">#</a></h4><ul><li>DataChangedEventDispatcher.onApplicationEvent()</li></ul><p>当事件发布完成后，会自动进入到<code>DataChangedEventDispatcher</code>类中的<code>onApplicationEvent()</code>方法，进行事件处理。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Component</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class DataChangedEventDispatcher implements ApplicationListener&lt;DataChangedEvent&gt;, InitializingBean {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 有数据变更时，调用此方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param event</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @SuppressWarnings(&quot;unchecked&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onApplicationEvent(final DataChangedEvent event) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 遍历数据变更监听器(一般使用一种数据同步的方式就好了)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (DataChangedListener listener : listeners) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 哪种数据发生变更</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            switch (event.getGroupKey()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case APP_AUTH: // 认证信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onAppAuthChanged((List&lt;AppAuthData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case PLUGIN:  // 插件信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onPluginChanged((List&lt;PluginData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case RULE:    // 规则信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onRuleChanged((List&lt;RuleData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case SELECTOR:   // 选择器信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onSelectorChanged((List&lt;SelectorData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case META_DATA:  // 元数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onMetaDataChanged((List&lt;MetaData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                default:  // 其他类型，抛出异常</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    throw new IllegalStateException(&quot;Unexpected value: &quot; + event.getGroupKey());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>当有数据变更时，调用<code>onApplicationEvent</code>方法，然后遍历所有数据变更监听器，判断是哪种数据类型，交给相应的数据监听器进行处理。</p><p><code>ShenYu</code>将所有数据进行了分组，一共是五种：认证信息、插件信息、规则信息、选择器信息和元数据。</p><p>这里的数据变更监听器（<code>DataChangedListener</code>），就是数据同步策略的抽象，它的具体实现有：</p><p><img src="/zh/assets/images/data-changed-listener-b01d7410746ca4afd526d8c9df865e9b.png"></p><p>这几个实现类就是当前<code>ShenYu</code>支持的同步策略：</p><ul><li><code>WebsocketDataChangedListener</code>：基于<code>websocket</code>的数据同步；</li><li><code>ZookeeperDataChangedListener</code>：基于<code>zookeeper</code>的数据同步；</li><li><code>ConsulDataChangedListener</code>：基于<code>consul</code>的数据同步；</li><li><code>EtcdDataDataChangedListener</code>：基于<code>etcd</code>的数据同步；</li><li><code>HttpLongPollingDataChangedListener</code>：基于<code>http长轮询</code>的数据同步；</li><li><code>NacosDataChangedListener</code>：基于<code>nacos</code>的数据同步；</li></ul><p>既然有这么多种实现策略，那么如何确定使用哪一种呢？</p><p>因为本文是基于<code>websocket</code>的数据同步源码分析，所以这里以<code>WebsocketDataChangedListener</code>为例，分析它是如何被加载并实现的。</p><p>通过在源码工程中进行全局搜索，可以看到，它的实现是在<code>DataSyncConfiguration</code>类完成的。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 数据同步配置类</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 通过springboot条件装配实现</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * The type Data sync configuration.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Configuration</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class DataSyncConfiguration {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain"> /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * websocket数据同步（默认策略）</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * The WebsocketListener(default strategy).</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Configuration</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @ConditionalOnProperty(name = &quot;shenyu.sync.websocket.enabled&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @EnableConfigurationProperties(WebsocketSyncProperties.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    static class WebsocketListener {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Config event listener data changed listener.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 配置websocket数据变更监听器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @return the data changed listener</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @ConditionalOnMissingBean(WebsocketDataChangedListener.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public DataChangedListener websocketDataChangedListener() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return new WebsocketDataChangedListener();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Websocket collector.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Websocket处理类：建立连接，发送消息，关闭连接等操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @return the websocket collector</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @ConditionalOnMissingBean(WebsocketCollector.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public WebsocketCollector websocketCollector() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return new WebsocketCollector();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Server endpoint exporter </span></span><span class="token-line" style="color:#393A34"><span class="token plain">         *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @return the server endpoint exporter</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @ConditionalOnMissingBean(ServerEndpointExporter.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public ServerEndpointExporter serverEndpointExporter() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return new ServerEndpointExporter();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这个配置类是通过<code>SpringBoot</code>条件装配类实现的。在<code>WebsocketListener</code>类上面有几个注解：</p><ul><li><p><code>@Configuration</code>：配置文件，应用上下文；</p></li><li><p><code>@ConditionalOnProperty(name = &quot;shenyu.sync.websocket.enabled&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</code>：属性条件判断，满足条件，该配置类才会生效。也就是说，当我们有如下配置时，就会采用<code>websocket</code>进行数据同步。不过，这里需要注意下<code>matchIfMissing = true</code>这个属性，它表示，如果你没有如下的配置，该配置类也会生效。基于<code>websocket</code>的数据同步时官方推荐的方式，也是默认采用的方式。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI properties"><pre tabindex="0" class="prism-code language-properties codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">shenyu:  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">  sync:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    websocket:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      enabled: true</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></li><li><p><code>@EnableConfigurationProperties</code>：启用配置属性；</p></li></ul><p>当我们主动配置，采用<code>websocket</code>进行数据同步时，<code>WebsocketDataChangedListener</code>就会生成。所以在事件处理方法<code>onApplicationEvent()</code>中，就会到相应的<code>listener</code>中。在我们的案例中，是新增加了一条选择器数据，数据通过采用的是<code>websocket</code>，所以，代码会进入到<code>WebsocketDataChangedListener</code>进行选择器数据变更处理。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @SuppressWarnings(&quot;unchecked&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onApplicationEvent(final DataChangedEvent event) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 遍历数据变更监听器(一般使用一种数据同步的方式就好了)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (DataChangedListener listener : listeners) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 哪种数据发生变更</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            switch (event.getGroupKey()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 省略了其他逻辑</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case SELECTOR:   // 选择器信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onSelectorChanged((List&lt;SelectorData&gt;) event.getSource(), event.getEventType());   // WebsocketDataChangedListener进行选择器数据变更处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="24-websocket数据变更监听器"></a>2.4 Websocket数据变更监听器<a class="hash-link" href="#24-websocket数据变更监听器" title="Direct link to heading">#</a></h4><ul><li><p>WebsocketDataChangedListener.onSelectorChanged()</p><p>在<code>onSelectorChanged()</code>方法中，将数据进行了封装，转成<code>WebsocketData</code>，然后通过<code>WebsocketCollector.send()</code>发送数据。</p></li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    // 选择器数据有更新</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onSelectorChanged(final List&lt;SelectorData&gt; selectorDataList, final DataEventTypeEnum eventType) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 构造 WebsocketData 数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        WebsocketData&lt;SelectorData&gt; websocketData =</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                new WebsocketData&lt;&gt;(ConfigGroupEnum.SELECTOR.name(), eventType.name(), selectorDataList);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 通过websocket发送数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        WebsocketCollector.send(GsonUtils.getInstance().toJson(websocketData), eventType);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="25-websocket发送数据"></a>2.5 Websocket发送数据<a class="hash-link" href="#25-websocket发送数据" title="Direct link to heading">#</a></h4><ul><li>WebsocketCollector.send()</li></ul><p>在<code>send()</code>方法中，判断了一下同步的类型，根据不同的类型，进行处理。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Slf4j</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@ServerEndpoint(value = &quot;/websocket&quot;, configurator = WebsocketConfigurator.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class WebsocketCollector {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Send.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param message the message</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param type    the type</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void send(final String message, final DataEventTypeEnum type) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (StringUtils.isNotBlank(message)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 如果是MYSELF（第一次的全量同步）</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (DataEventTypeEnum.MYSELF == type) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 从threadlocal中获取session</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                Session session = (Session) ThreadLocalUtil.get(SESSION_KEY);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (session != null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 向该session发送全量数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    sendMessageBySession(session, message);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 后续的增量同步</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 向所有的session中同步变更数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                SESSION_SET.forEach(session -&gt; sendMessageBySession(session, message));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static void sendMessageBySession(final Session session, final String message) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 通过websocket的session把消息发送出去</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            session.getBasicRemote().sendText(message);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (IOException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            log.error(&quot;websocket send result is exception: &quot;, e);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>我们给的案例是一个新增操作 ，是一个增量同步，所以会走</p><p><code>SESSION_SET.forEach(session -&gt; sendMessageBySession(session, message));</code></p><p>这个逻辑。</p><p>再通过</p><p><code>session.getBasicRemote().sendText(message);</code></p><p>将数据发送了出去。</p><p>至此，当<code>admin</code>端发生数据变更时，就将变更的数据以增量形式通过<code>WebSocket</code>发给了网关。</p><p>分析到这里，不知道大家有没有疑问呢？比如<code>session</code>是怎么来的？网关如何和<code>admin</code>建立连接的？</p><p>不要着急，我们接下来就进行网关端的同步分析。</p><p>不过，在继续源码分析前，我们用一张图将上面的分析过程串联起来。</p><p><img src="/zh/assets/images/websocket-data-sync-admin-56f75ad149ca3cd1ec07fd24c6194c5b.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="3-网关数据同步"></a>3. 网关数据同步<a class="hash-link" href="#3-网关数据同步" title="Direct link to heading">#</a></h3><p>假设<code>ShenYu</code>网关已经在正常运行了，使用的数据同步方式也是<code>websocket</code>。那么当在<code>admin</code>端新增一条选择器数据后，并且通过<code>WebSocket</code>发送到网关，那网关是如何接收并处理数据的呢？接下来我们就继续进行源码分析，一探究竟。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="31-websocketclient接收数据"></a>3.1 WebsocketClient接收数据<a class="hash-link" href="#31-websocketclient接收数据" title="Direct link to heading">#</a></h4><ul><li>ShenyuWebsocketClient.onMessage()</li></ul><p>在网关端有一个<code>ShenyuWebsocketClient</code>类，它继承了<code>WebSocketClient</code>，可以和<code>WebSocket</code>建立连接并通信。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public final class ShenyuWebsocketClient extends WebSocketClient {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>当在<code>admin</code>端通过<code>websocket</code>发送数据后，<code>ShenyuWebsocketClient</code>就可以通过<code>onMessage()</code>接收到数据，然后就可以自己进行处理。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public final class ShenyuWebsocketClient extends WebSocketClient {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 接受到消息后执行</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onMessage(final String result) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 处理接收到的数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        handleResult(result);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void handleResult(final String result) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 数据反序列化</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        WebsocketData websocketData = GsonUtils.getInstance().fromJson(result, WebsocketData.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 哪种数据类型，插件、选择器、规则...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ConfigGroupEnum groupEnum = ConfigGroupEnum.acquireByName(websocketData.getGroupType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 哪种操作类型，更新、删除...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String eventType = websocketData.getEventType();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String json = GsonUtils.getInstance().toJson(websocketData.getData());</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 处理数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        websocketDataHandler.executor(groupEnum, json, eventType);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>接收到数据后，首先进行了反序列化操作，读取数据类型和操作类型，紧接着，就交给<code>websocketDataHandler.executor()</code>进行处理。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="32-执行websocket事件处理器"></a>3.2 执行Websocket事件处理器<a class="hash-link" href="#32-执行websocket事件处理器" title="Direct link to heading">#</a></h4><ul><li>WebsocketDataHandler.executor()</li></ul><p>通过工厂模式创建了<code>Websocket</code>数据处理器，每种数据类型，都提供了一个处理器：</p><blockquote><p>插件 --&gt; 插件数据处理器;</p><p>选择器 --&gt; 选择器数据处理器；</p><p>规则 --&gt; 规则数据处理器；</p><p>认证信息 --&gt; 认证数据处理器；</p><p>元数据 --&gt; 元数据处理器。</p></blockquote><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 通过工厂模式创建 Websocket数据处理器</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * The type Websocket cache handler.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class WebsocketDataHandler {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final EnumMap&lt;ConfigGroupEnum, DataHandler&gt; ENUM_MAP = new EnumMap&lt;&gt;(ConfigGroupEnum.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Instantiates a new Websocket data handler.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 每种数据类型，提供一个处理器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param pluginDataSubscriber the plugin data subscriber</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param metaDataSubscribers  the meta data subscribers</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param authDataSubscribers  the auth data subscribers</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public WebsocketDataHandler(final PluginDataSubscriber pluginDataSubscriber,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                final List&lt;MetaDataSubscriber&gt; metaDataSubscribers,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                final List&lt;AuthDataSubscriber&gt; authDataSubscribers) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 插件 --&gt; 插件数据处理器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ENUM_MAP.put(ConfigGroupEnum.PLUGIN, new PluginDataHandler(pluginDataSubscriber));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 选择器 --&gt; 选择器数据处理器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ENUM_MAP.put(ConfigGroupEnum.SELECTOR, new SelectorDataHandler(pluginDataSubscriber));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 规则 --&gt; 规则数据处理器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ENUM_MAP.put(ConfigGroupEnum.RULE, new RuleDataHandler(pluginDataSubscriber));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 认证信息 --&gt; 认证数据处理器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ENUM_MAP.put(ConfigGroupEnum.APP_AUTH, new AuthDataHandler(authDataSubscribers));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 元数据 --&gt; 元数据处理器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ENUM_MAP.put(ConfigGroupEnum.META_DATA, new MetaDataHandler(metaDataSubscribers));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Executor.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param type      the type</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param json      the json</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param eventType the event type</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void executor(final ConfigGroupEnum type, final String json, final String eventType) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 根据数据类型，找到对应的数据处理器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ENUM_MAP.get(type).handle(json, eventType);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>不同的数据类型，有不同的数据处理方式，所以有不同的实现类。但是它们之间也有相同的处理逻辑，所以可以通过模板方法设计模式来实现。相同的逻辑放在抽象类中的<code>handle()</code>方法中，不同逻辑就交给各自的实现类。</p><p><img src="/zh/assets/images/data-handler-313ae788eadfdabf405cdc55c74dbb21.png"></p><p>我们的案例是新增了一条选择器数据，所以会交给<code>SelectorDataHandler</code>（ 选择器 --&gt; 选择器数据处理器）进行数据处理。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="33-判断事件类型"></a>3.3 判断事件类型<a class="hash-link" href="#33-判断事件类型" title="Direct link to heading">#</a></h4><ul><li>AbstractDataHandler.handle()</li></ul><p>实现数据变更的通用逻辑处理：根据不同的操作类型调用不同方法。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public abstract class AbstractDataHandler&lt;T&gt; implements DataHandler {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Convert list.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 不同的逻辑由各自实现类去实现</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param json the json</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the list</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected abstract List&lt;T&gt; convert(String json);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Do refresh.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 不同的逻辑由各自实现类去实现</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param dataList the data list</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected abstract void doRefresh(List&lt;T&gt; dataList);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Do update.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 不同的逻辑由各自实现类去实现</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param dataList the data list</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected abstract void doUpdate(List&lt;T&gt; dataList);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Do delete.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 不同的逻辑由各自实现类去实现</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param dataList the data list</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected abstract void doDelete(List&lt;T&gt; dataList);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 通用逻辑，抽象类实现</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void handle(final String json, final String eventType) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;T&gt; dataList = convert(json);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (CollectionUtils.isNotEmpty(dataList)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            DataEventTypeEnum eventTypeEnum = DataEventTypeEnum.acquireByName(eventType);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            switch (eventTypeEnum) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case REFRESH:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case MYSELF:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    doRefresh(dataList);  //刷新数据，全量同步</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case UPDATE:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case CREATE:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    doUpdate(dataList); // 更新或创建数据，增量同步</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case DELETE:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    doDelete(dataList);  // 删除数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                default:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>新增一条选择器数据，是新增操作，通过<code>switch-case</code>进入到<code>doUpdate()</code>方法中。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="34-进入具体的数据处理器"></a>3.4 进入具体的数据处理器<a class="hash-link" href="#34-进入具体的数据处理器" title="Direct link to heading">#</a></h4><ul><li>SelectorDataHandler.doUpdate()</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 选择器数据处理器</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * The type Selector data handler.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@RequiredArgsConstructor</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SelectorDataHandler extends AbstractDataHandler&lt;SelectorData&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final PluginDataSubscriber pluginDataSubscriber;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //......</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 更新操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected void doUpdate(final List&lt;SelectorData&gt; dataList) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        dataList.forEach(pluginDataSubscriber::onSelectorSubscribe);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>遍历数据，进入<code>onSelectorSubscribe()</code>方法。</p><ul><li>PluginDataSubscriber.onSelectorSubscribe()</li></ul><p>它没有其他逻辑，直接调用<code>subscribeDataHandler()</code>方法。在方法中，更具数据类型（插件、选择器或规则），操作类型（更新或删除），去执行不同逻辑。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 通用插件数据订阅者，负责处理所有插件、选择器和规则信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * The type Common plugin data subscriber.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class CommonPluginDataSubscriber implements PluginDataSubscriber {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     // 处理选择器数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onSelectorSubscribe(final SelectorData selectorData) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        subscribeDataHandler(selectorData, DataEventTypeEnum.UPDATE);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 订阅数据处理器，处理数据的更新或删除</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private &lt;T&gt; void subscribeDataHandler(final T classData, final DataEventTypeEnum dataType) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Optional.ofNullable(classData).ifPresent(data -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 插件数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (data instanceof PluginData) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                PluginData pluginData = (PluginData) data;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (dataType == DataEventTypeEnum.UPDATE) { // 更新操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 将数据保存到网关内存</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().cachePluginData(pluginData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Optional.ofNullable(handlerMap.get(pluginData.getName())).ifPresent(handler -&gt; handler.handlerPlugin(pluginData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else if (dataType == DataEventTypeEnum.DELETE) {  // 删除操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 从网关内存移除数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().removePluginData(pluginData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Optional.ofNullable(handlerMap.get(pluginData.getName())).ifPresent(handler -&gt; handler.removePlugin(pluginData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else if (data instanceof SelectorData) {  // 选择器数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                SelectorData selectorData = (SelectorData) data;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (dataType == DataEventTypeEnum.UPDATE) { // 更新操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 将数据保存到网关内存</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().cacheSelectData(selectorData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理 </span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Optional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -&gt; handler.handlerSelector(selectorData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else if (dataType == DataEventTypeEnum.DELETE) {  // 删除操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 从网关内存移除数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().removeSelectData(selectorData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Optional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -&gt; handler.removeSelector(selectorData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else if (data instanceof RuleData) {  // 规则数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                RuleData ruleData = (RuleData) data;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (dataType == DataEventTypeEnum.UPDATE) { // 更新操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 将数据保存到网关内存</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().cacheRuleData(ruleData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Optional.ofNullable(handlerMap.get(ruleData.getPluginName())).ifPresent(handler -&gt; handler.handlerRule(ruleData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else if (dataType == DataEventTypeEnum.DELETE) { // 删除操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 从网关内存移除数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().removeRuleData(ruleData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Optional.ofNullable(handlerMap.get(ruleData.getPluginName())).ifPresent(handler -&gt; handler.removeRule(ruleData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>那么新增一条选择器数据，会进入下面的逻辑：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// 将数据保存到网关内存</span></span><span class="token-line" style="color:#393A34"><span class="token plain">BaseDataCache.getInstance().cacheSelectData(selectorData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 如果每个插件还有自己的处理逻辑，那么就去处理                  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">Optional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -&gt; handler.handlerSelector(selectorData));</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>一是将数据保存到网关的内存中。<code>BaseDataCache</code>是最终缓存数据的类，通过单例模式实现。选择器数据就存到了<code>SELECTOR_MAP</code>这个<code>Map</code>中。在后续使用的时候，也是从这里拿数据。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public final class BaseDataCache {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 私有变量</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final BaseDataCache INSTANCE = new BaseDataCache();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 私有构造器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private BaseDataCache() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Gets instance.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *  公开方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the instance</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static BaseDataCache getInstance() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return INSTANCE;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    *  缓存选择器数据的Map</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * pluginName -&gt; SelectorData.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final ConcurrentMap&lt;String, List&lt;SelectorData&gt;&gt; SELECTOR_MAP = Maps.newConcurrentMap();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void cacheSelectData(final SelectorData selectorData) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Optional.ofNullable(selectorData).ifPresent(this::selectorAccept);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span></span><span class="token-line" style="color:#393A34"><span class="token plain">   /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * cache selector data.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 缓存选择器数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param data the selector data</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void selectorAccept(final SelectorData data) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String key = data.getPluginName();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (SELECTOR_MAP.containsKey(key)) { // 更新操作，先删除再插入</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            List&lt;SelectorData&gt; existList = SELECTOR_MAP.get(key);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            final List&lt;SelectorData&gt; resultList = existList.stream().filter(r -&gt; !r.getId().equals(data.getId())).collect(Collectors.toList());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            resultList.add(data);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            final List&lt;SelectorData&gt; collect = resultList.stream().sorted(Comparator.comparing(SelectorData::getSort)).collect(Collectors.toList());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            SELECTOR_MAP.put(key, collect);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {  // 新增操作，直接放到Map中</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            SELECTOR_MAP.put(key, Lists.newArrayList(data));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>二是如果每个插件还有自己的处理逻辑，那么就去处理。  通过<code>idea</code>编辑器可以看到，当新增一条选择器后，有如下的插件还有处理。这里我们就不再展开了。</p><p><img src="/zh/assets/images/handler-selector-bf05b8fdf80a428aa53606178a42bae6.png"></p><p>经过以上的源码追踪，并通过一个实际的案例，在<code>admin</code>端新增一条选择器数据，就将<code>websocket</code>数据同步的流程分析清除了。</p><p>我们还是用下面的一张图将网关端的数据同步流程串联一下：</p><p><img src="/zh/assets/images/websocket-data-sync-gateway-181e89c69dc9b9d2569e858eb82431bf.png"></p><p>数据同步的流程已经分析完了，但是还有一些问题没有分析到，就是网关是如何跟<code>admin</code>建立连接的？</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="4-网关和admin建立websocket连接"></a>4. 网关和admin建立websocket连接<a class="hash-link" href="#4-网关和admin建立websocket连接" title="Direct link to heading">#</a></h3><ul><li>websocket配置</li></ul><p>在网关的配置文件中有如下配置，并且引入了相关依赖，就会启动<code>websocket</code>相关服务。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI yaml"><pre tabindex="0" class="prism-code language-yaml codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token key atrule" style="color:#00a4db">shenyu</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">file</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">enabled</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token boolean important" style="color:#36acaa">true</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">cross</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">enabled</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token boolean important" style="color:#36acaa">true</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">dubbo</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">parameter</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> multi</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">sync</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token key atrule" style="color:#00a4db">websocket</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic"># 使用websocket进行数据同步</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">             </span><span class="token key atrule" style="color:#00a4db">urls</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> ws</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain">//localhost</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain">9095/websocket   </span><span class="token comment" style="color:#999988;font-style:italic"># admin端的websocket地址</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在网关中引入<code>websocket</code>的依赖。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI xml"><pre tabindex="0" class="prism-code language-xml codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">&lt;!--shenyu data sync start use websocket--&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">dependency</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">groupId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">org.apache.shenyu</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">groupId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">artifactId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">shenyu-spring-boot-starter-sync-data-websocket</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">artifactId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">version</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">${project.version}</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">version</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">dependency</span><span class="token tag punctuation" style="color:#393A34">&gt;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>Websocket数据同步配置</li></ul><p>通过<code>springboot</code>的条件装配，创建相关的<code>bean</code>。在网关启动的时候，如果我们配置了<code>shenyu.sync.websocket.urls</code>，那么<code>Websocket</code>数据同步配置就会被加载。这里通过<code>spring boot starter</code>完成依赖的加载。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Websocket数据同步配置</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 通过springboot实现条件注入</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Websocket sync data configuration for spring boot.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Configuration</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@ConditionalOnClass(WebsocketSyncDataService.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@ConditionalOnProperty(prefix = &quot;shenyu.sync.websocket&quot;, name = &quot;urls&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Slf4j</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class WebsocketSyncDataConfiguration {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Websocket sync data service.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Websocket数据同步服务</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param websocketConfig   the websocket config</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param pluginSubscriber the plugin subscriber</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param metaSubscribers   the meta subscribers</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param authSubscribers   the auth subscribers</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the sync data service</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 创建websocketSyncDataService</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public SyncDataService websocketSyncDataService(final ObjectProvider&lt;WebsocketConfig&gt; websocketConfig, final ObjectProvider&lt;PluginDataSubscriber&gt; pluginSubscriber,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                           final ObjectProvider&lt;List&lt;MetaDataSubscriber&gt;&gt; metaSubscribers, final ObjectProvider&lt;List&lt;AuthDataSubscriber&gt;&gt; authSubscribers) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        log.info(&quot;you use websocket sync shenyu data.......&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new WebsocketSyncDataService(websocketConfig.getIfAvailable(WebsocketConfig::new), pluginSubscriber.getIfAvailable(),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                metaSubscribers.getIfAvailable(Collections::emptyList), authSubscribers.getIfAvailable(Collections::emptyList));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Config websocket config.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the websocket config</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @ConfigurationProperties(prefix = &quot;shenyu.sync.websocket&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public WebsocketConfig websocketConfig() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new WebsocketConfig();  // 创建WebsocketConfig</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在项目的<code>resources/META-INF</code>目录先新建<code>spring.factories</code>文件，在文件中指明配置类。</p><p><img src="/zh/assets/images/websocket-springboot-starter-2cfd149ba2fb69ab514241e061fc22c9.png"></p><ul><li>Websocket数据同步服务</li></ul><p>在<code>WebsocketSyncDataService</code>中做了如下几件事情：</p><ul><li>读取配置中的<code>urls</code>，这个表示<code>admin</code>端的同步地址，有多个的话，使用&quot;,&quot;分割；</li><li>创建调度线程池，一个<code>admin</code>分配一个，用于执行定时任务；</li><li>创建<code>ShenyuWebsocketClient</code>，一个<code>admin</code>分配一个，用于和<code>admin</code>建立<code>websocket</code>通信；</li><li>开始和<code>admin</code>端的<code>websocket</code> 建立连接；</li><li>执行定时任务，每隔10秒执行一次。主要作用是判断<code>websocket</code>连接是否已经断开，如果已经断开，则尝试重连。如果没有断开，就进行 <code>ping-pong</code> 检测。</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Websocket数据同步服务</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Websocket sync data service.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Slf4j</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class WebsocketSyncDataService implements SyncDataService, AutoCloseable {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final List&lt;WebSocketClient&gt; clients = new ArrayList&lt;&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final ScheduledThreadPoolExecutor executor;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Instantiates a new Websocket sync cache.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 创建Websocket数据同步服务</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param websocketConfig      the websocket config</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param pluginDataSubscriber the plugin data subscriber</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param metaDataSubscribers  the meta data subscribers</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param authDataSubscribers  the auth data subscribers</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public WebsocketSyncDataService(final WebsocketConfig websocketConfig,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    final PluginDataSubscriber pluginDataSubscriber,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    final List&lt;MetaDataSubscriber&gt; metaDataSubscribers,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    final List&lt;AuthDataSubscriber&gt; authDataSubscribers) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // admin端的同步地址，有多个的话，使用&quot;,&quot;分割</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String[] urls = StringUtils.split(websocketConfig.getUrls(), &quot;,&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建调度线程池，一个admin分配一个</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        executor = new ScheduledThreadPoolExecutor(urls.length, ShenyuThreadFactory.create(&quot;websocket-connect&quot;, true));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (String url : urls) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                //创建WebsocketClient，一个admin分配一个</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                clients.add(new ShenyuWebsocketClient(new URI(url), Objects.requireNonNull(pluginDataSubscriber), metaDataSubscribers, authDataSubscribers));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (URISyntaxException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                log.error(&quot;websocket url({}) is error&quot;, url, e);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (WebSocketClient client : clients) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 和websocket server建立连接</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                boolean success = client.connectBlocking(3000, TimeUnit.MILLISECONDS);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (success) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    log.info(&quot;websocket connection is successful.....&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    log.error(&quot;websocket connection is error.....&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 执行定时任务，每隔10秒执行一次</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 主要作用是判断websocket连接是否已经断开，如果已经断开，则尝试重连。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 如果没有断开，就进行 ping-pong 检测</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                executor.scheduleAtFixedRate(() -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if (client.isClosed()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            boolean reconnectSuccess = client.reconnectBlocking();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            if (reconnectSuccess) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                log.info(&quot;websocket reconnect server[{}] is successful.....&quot;, client.getURI().toString());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                log.error(&quot;websocket reconnection server[{}] is error.....&quot;, client.getURI().toString());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            client.sendPing();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            log.debug(&quot;websocket send to [{}] ping message successful&quot;, client.getURI().toString());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } catch (InterruptedException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        log.error(&quot;websocket connect is error :{}&quot;, e.getMessage());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }, 10, 10, TimeUnit.SECONDS);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            /* client.setProxy(new Proxy(Proxy.Type.HTTP, new InetSocketAddress(&quot;proxyaddress&quot;, 80)));*/</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (InterruptedException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            log.info(&quot;websocket connection...exception....&quot;, e);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void close() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 关闭 websocket client</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (WebSocketClient client : clients) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!client.isClosed()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                client.close();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 关闭线程池</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (Objects.nonNull(executor)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            executor.shutdown();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>ShenyuWebsocketClient</li></ul><p>在<code>ShenYu</code>中创建的<code>WebSocket</code>客户端，用于和<code>admin</code>端通信。第一次成功建立连接后，同步全量数据，后续进行增量同步。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 在ShenYu中自定义的WebSocket客户端</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * The type shenyu websocket client.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Slf4j</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public final class ShenyuWebsocketClient extends WebSocketClient {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private volatile boolean alreadySync = Boolean.FALSE;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final WebsocketDataHandler websocketDataHandler;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Instantiates a new shenyu websocket client.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 创建ShenyuWebsocketClient</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param serverUri             the server uri  服务端uri</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param pluginDataSubscriber the plugin data subscriber 插件数据订阅器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param metaDataSubscribers   the meta data subscribers 元数据订阅器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param authDataSubscribers   the auth data subscribers 认证数据订阅器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ShenyuWebsocketClient(final URI serverUri, final PluginDataSubscriber pluginDataSubscriber,final List&lt;MetaDataSubscriber&gt; metaDataSubscribers, final List&lt;AuthDataSubscriber&gt; authDataSubscribers) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        super(serverUri);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.websocketDataHandler = new WebsocketDataHandler(pluginDataSubscriber, metaDataSubscribers, authDataSubscribers);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 成功建立连接后执行</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onOpen(final ServerHandshake serverHandshake) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 防止重新建立连接时，再次执行，所以用alreadySync进行判断</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!alreadySync) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 同步所有数据，MYSELF 类型</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            send(DataEventTypeEnum.MYSELF.name());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            alreadySync = true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 接收到消息后执行</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onMessage(final String result) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 处理接收到的数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        handleResult(result);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 关闭后执行</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onClose(final int i, final String s, final boolean b) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.close();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 失败后执行</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onError(final Exception e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.close();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @SuppressWarnings(&quot;ALL&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void handleResult(final String result) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 数据反序列化</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        WebsocketData websocketData = GsonUtils.getInstance().fromJson(result, WebsocketData.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 哪种数据类型，插件、选择器、规则...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ConfigGroupEnum groupEnum = ConfigGroupEnum.acquireByName(websocketData.getGroupType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 哪种操作类型，更新、删除...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String eventType = websocketData.getEventType();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String json = GsonUtils.getInstance().toJson(websocketData.getData());</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 处理数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        websocketDataHandler.executor(groupEnum, json, eventType);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="5-总结"></a>5. 总结<a class="hash-link" href="#5-总结" title="Direct link to heading">#</a></h3><p>本文通过一个实际案例，对<code>websocket</code>的数据同步原理进行了源码分析。涉及到的主要知识点如下：</p><ul><li><code>websocket</code>支持双向通信，性能好，推荐使用；</li><li>通过<code>Spring</code>完成事件发布和监听；</li><li>通过抽象<code>DataChangedListener</code>接口，支持多种同步策略，面向接口编程；</li><li>使用工厂模式创建 <code>WebsocketDataHandler</code>，实现不同数据类型的处理；</li><li>使用模板方法设计模式实现<code>AbstractDataHandler</code>，处理通用的操作类型；</li><li>使用单例设计模式实现缓存数据类<code>BaseDataCache</code>；</li><li>通过<code>SpringBoot</code>的条件装配和<code>starter</code>加载机制实现配置类的加载。</li></ul></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><a class="margin-horiz--sm" href="/zh/blog/tags/websocket">websocket</a><a class="margin-horiz--sm" href="/zh/blog/tags/data-sync">data sync</a><a class="margin-horiz--sm" href="/zh/blog/tags/apache-shen-yu">Apache ShenYu</a></div></footer></article><article class="margin-bottom--xl"><header><h2 class="blogPostTitle_d4p0"><a href="/zh/blog/DataSync-SourceCode-Analysis-ZooKeeper-Data-Sync">ZooKeeper数据同步源码分析</a></h2><div class="blogPostData_-Im+ margin-vert--md"><time datetime="2021-12-14T03:31:25.749Z">2021年12月14日</time> · One min read</div><div class="avatar margin-vert--md"><div class="avatar__intro"><div class="avatar__name"><a href="https://github.com/midnight2104" target="_blank" rel="noopener noreferrer">midnight2104</a></div><small class="avatar__subtitle">Apache ShenYu Committer</small></div></div></header><div class="markdown"><blockquote><p><a href="https://shenyu.apache.org/zh/docs/index" target="_blank" rel="noopener noreferrer">Apache ShenYu</a> 是一个异步的，高性能的，跨语言的，响应式的 <code>API</code> 网关。</p></blockquote><p>在<code>ShenYu</code>网关中，数据同步是指，当在后台管理系统中，数据发送了更新后，如何将更新的数据同步到网关中。<code>Apache ShenYu</code> 网关当前支持<code>ZooKeeper</code>、<code>WebSocket</code>、<code>Http长轮询</code>、<code>Nacos</code> 、<code>Etcd</code> 和 <code>Consul</code> 进行数据同步。本文的主要内容是基于<code>ZooKeeper</code>的数据同步源码分析。</p><blockquote><p>本文基于<code>shenyu-2.4.0</code>版本进行源码分析，官网的介绍请参考 <a href="https://shenyu.apache.org/zh/docs/design/data-sync" target="_blank" rel="noopener noreferrer">数据同步原理</a> 。</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="1-关于zookeeper"></a>1. 关于ZooKeeper<a class="hash-link" href="#1-关于zookeeper" title="Direct link to heading">#</a></h3><p><a href="https://zh.wikipedia.org/wiki/Apache_ZooKeeper" target="_blank" rel="noopener noreferrer"><code>Apache ZooKeeper</code></a>是<code>Apache</code>软件基金会的一个软件项目，它为大型分布式计算提供开源的分布式配置服务、同步服务和命名注册。<code>ZooKeeper</code>节点将它们的数据存储于一个分层的名字空间，非常类似于一个文件系统或一个前缀树结构。客户端可以在节点读写，从而以这种方式拥有一个共享的配置服务。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="2-admin数据同步"></a>2. Admin数据同步<a class="hash-link" href="#2-admin数据同步" title="Direct link to heading">#</a></h3><p>我们从一个实际案例进行源码追踪，比如在后台管理系统中，对<code>Divide</code>插件中的一条选择器数据进行更新，将权重更新为90：</p><p><img src="/zh/assets/images/update-selector-zh-1f49b39fb8e5ce2c26a80018669619ea.png"></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="21-接收数据"></a>2.1 接收数据<a class="hash-link" href="#21-接收数据" title="Direct link to heading">#</a></h4><ul><li>SelectorController.createSelector()</li></ul><p>进入<code>SelectorController</code>类中的<code>updateSelector()</code>方法，它负责数据的校验，添加或更新数据，返回结果信息。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Validated</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@RequiredArgsConstructor</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@RestController</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@RequestMapping(&quot;/selector&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SelectorController {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @PutMapping(&quot;/{id}&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ShenyuAdminResult updateSelector(@PathVariable(&quot;id&quot;) final String id, @Valid @RequestBody final SelectorDTO selectorDTO) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 设置当前选择器数据id</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        selectorDTO.setId(id);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建或更新操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Integer updateCount = selectorService.createOrUpdate(selectorDTO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 返回结果信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ShenyuAdminResult.success(ShenyuResultMessage.UPDATE_SUCCESS, updateCount);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="22-处理数据"></a>2.2 处理数据<a class="hash-link" href="#22-处理数据" title="Direct link to heading">#</a></h4><ul><li>SelectorServiceImpl.createOrUpdate()</li></ul><p>在<code>SelectorServiceImpl</code>类中通过<code>createOrUpdate()</code>方法完成数据的转换，保存到数据库，发布事件，更新<code>upstream</code>。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@RequiredArgsConstructor</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Service</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SelectorServiceImpl implements SelectorService {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 负责事件发布的eventPublisher</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final ApplicationEventPublisher eventPublisher;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Transactional(rollbackFor = Exception.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int createOrUpdate(final SelectorDTO selectorDTO) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int selectorCount;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 构建数据 DTO --&gt; DO</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        SelectorDO selectorDO = SelectorDO.buildSelectorDO(selectorDTO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;SelectorConditionDTO&gt; selectorConditionDTOs = selectorDTO.getSelectorConditions();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 判断是添加还是更新</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (StringUtils.isEmpty(selectorDTO.getId())) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 插入选择器数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectorCount = selectorMapper.insertSelective(selectorDO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 插入选择器中的条件数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectorConditionDTOs.forEach(selectorConditionDTO -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                selectorConditionDTO.setSelectorId(selectorDO.getId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                selectorConditionMapper.insertSelective(SelectorConditionDO.buildSelectorConditionDO(selectorConditionDTO));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // check selector add</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 权限检查</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (dataPermissionMapper.listByUserId(JwtUtils.getUserInfo().getUserId()).size() &gt; 0) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                DataPermissionDTO dataPermissionDTO = new DataPermissionDTO();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                dataPermissionDTO.setUserId(JwtUtils.getUserInfo().getUserId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                dataPermissionDTO.setDataId(selectorDO.getId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                dataPermissionDTO.setDataType(AdminConstants.SELECTOR_DATA_TYPE);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                dataPermissionMapper.insertSelective(DataPermissionDO.buildPermissionDO(dataPermissionDTO));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 更新数据，先删除再新增</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectorCount = selectorMapper.updateSelective(selectorDO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            //delete rule condition then add</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectorConditionMapper.deleteByQuery(new SelectorConditionQuery(selectorDO.getId()));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectorConditionDTOs.forEach(selectorConditionDTO -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                selectorConditionDTO.setSelectorId(selectorDO.getId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                SelectorConditionDO selectorConditionDO = SelectorConditionDO.buildSelectorConditionDO(selectorConditionDTO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                selectorConditionMapper.insertSelective(selectorConditionDO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 发布事件</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        publishEvent(selectorDO, selectorConditionDTOs);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 更新upstream</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        updateDivideUpstream(selectorDO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return selectorCount;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在<code>Serrvice</code>类完成数据的持久化操作，即保存数据到数据库，这个比较简单，就不深入追踪了。关于更新<code>upstream</code>操作，放到后面对应的章节中进行分析，重点关注发布事件的操作，它会执行数据同步。</p><p><code>publishEvent()</code>方法的逻辑是：找到选择器对应的插件，构建条件数据，发布变更数据。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">       private void publishEvent(final SelectorDO selectorDO, final List&lt;SelectorConditionDTO&gt; selectorConditionDTOs) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 找到选择器对应的插件</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        PluginDO pluginDO = pluginMapper.selectById(selectorDO.getPluginId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 构建条件数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;ConditionData&gt; conditionDataList =                selectorConditionDTOs.stream().map(ConditionTransfer.INSTANCE::mapToSelectorDTO).collect(Collectors.toList());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 发布变更数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.SELECTOR, DataEventTypeEnum.UPDATE,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                Collections.singletonList(SelectorDO.transFrom(selectorDO, pluginDO.getName(), conditionDataList))));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>发布变更数据通过<code>eventPublisher.publishEvent()</code>完成，这个<code>eventPublisher</code>对象是一个<code>ApplicationEventPublisher</code>类，这个类的全限定名是<code>org.springframework.context.ApplicationEventPublisher</code>。看到这儿，我们知道了发布数据是通过<code>Spring</code>相关的功能来完成的。</p><blockquote><p>关于<code>ApplicationEventPublisher</code>：</p><p>当有状态发生变化时，发布者调用 <code>ApplicationEventPublisher</code> 的 <code>publishEvent</code> 方法发布一个事件，<code>Spring</code>容器广播事件给所有观察者，调用观察者的 <code>onApplicationEvent</code> 方法把事件对象传递给观察者。调用 <code>publishEvent</code>方法有两种途径，一种是实现接口由容器注入 <code>ApplicationEventPublisher</code> 对象然后调用其方法，另一种是直接调用容器的方法，两种方法发布事件没有太大区别。</p><ul><li><code>ApplicationEventPublisher</code>：发布事件；</li><li><code>ApplicationEvent</code>：<code>Spring</code> 事件，记录事件源、时间和数据；</li><li><code>ApplicationListener</code>：事件监听者，观察者；</li></ul></blockquote><p>在<code>Spring</code>的事件发布机制中，有三个对象，</p><p>一个是发布事件的<code>ApplicationEventPublisher</code>，在<code>ShenYu</code>中通过构造器注入了一个<code>eventPublisher</code>。</p><p>另一个对象是<code>ApplicationEvent</code>，在<code>ShenYu</code>中通过<code>DataChangedEvent</code>继承了它，表示事件对象。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public class DataChangedEvent extends ApplicationEvent {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>最后一个是 <code>ApplicationListener</code>，在<code>ShenYu</code>中通过<code>DataChangedEventDispatcher</code>类实现了该接口，作为事件的监听者，负责处理事件对象。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Component</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class DataChangedEventDispatcher implements ApplicationListener&lt;DataChangedEvent&gt;, InitializingBean {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="23-分发数据"></a>2.3 分发数据<a class="hash-link" href="#23-分发数据" title="Direct link to heading">#</a></h4><ul><li>DataChangedEventDispatcher.onApplicationEvent()</li></ul><p>当事件发布完成后，会自动进入到<code>DataChangedEventDispatcher</code>类中的<code>onApplicationEvent()</code>方法，进行事件处理。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Component</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class DataChangedEventDispatcher implements ApplicationListener&lt;DataChangedEvent&gt;, InitializingBean {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 有数据变更时，调用此方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param event</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @SuppressWarnings(&quot;unchecked&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onApplicationEvent(final DataChangedEvent event) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 遍历数据变更监听器(一般使用一种数据同步的方式就好了)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (DataChangedListener listener : listeners) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 哪种数据发生变更</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            switch (event.getGroupKey()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case APP_AUTH: // 认证信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onAppAuthChanged((List&lt;AppAuthData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case PLUGIN:  // 插件信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onPluginChanged((List&lt;PluginData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case RULE:    // 规则信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onRuleChanged((List&lt;RuleData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case SELECTOR:   // 选择器信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onSelectorChanged((List&lt;SelectorData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case META_DATA:  // 元数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onMetaDataChanged((List&lt;MetaData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                default:  // 其他类型，抛出异常</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    throw new IllegalStateException(&quot;Unexpected value: &quot; + event.getGroupKey());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>当有数据变更时，调用<code>onApplicationEvent</code>方法，然后遍历所有数据变更监听器，判断是哪种数据类型，交给相应的数据监听器进行处理。</p><p><code>ShenYu</code>将所有数据进行了分组，一共是五种：认证信息、插件信息、规则信息、选择器信息和元数据。</p><p>这里的数据变更监听器（<code>DataChangedListener</code>），就是数据同步策略的抽象，它的具体实现有：</p><p><img src="/zh/assets/images/data-changed-listener-b01d7410746ca4afd526d8c9df865e9b.png"></p><p>这几个实现类就是当前<code>ShenYu</code>支持的同步策略：</p><ul><li><code>WebsocketDataChangedListener</code>：基于<code>websocket</code>的数据同步；</li><li><code>ZookeeperDataChangedListener</code>：基于<code>zookeeper</code>的数据同步；</li><li><code>ConsulDataChangedListener</code>：基于<code>consul</code>的数据同步；</li><li><code>EtcdDataDataChangedListener</code>：基于<code>etcd</code>的数据同步；</li><li><code>HttpLongPollingDataChangedListener</code>：基于<code>http长轮询</code>的数据同步；</li><li><code>NacosDataChangedListener</code>：基于<code>nacos</code>的数据同步；</li></ul><p>既然有这么多种实现策略，那么如何确定使用哪一种呢？</p><p>因为本文是基于<code>Zookeeper</code>的数据同步源码分析，所以这里以<code>ZookeeperDataChangedListener</code>为例，分析它是如何被加载并实现的。</p><p>通过在源码工程中进行全局搜索，可以看到，它的实现是在<code>DataSyncConfiguration</code>类完成的。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 数据同步配置类</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 通过springboot条件装配实现</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * The type Data sync configuration.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Configuration</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class DataSyncConfiguration {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * zookeeper数据同步</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * The type Zookeeper listener.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Configuration</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @ConditionalOnProperty(prefix = &quot;shenyu.sync.zookeeper&quot;, name = &quot;url&quot;)  // 条件属性，满足才会被加载</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Import(ZookeeperConfiguration.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    static class ZookeeperListener {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Config event listener data changed listener.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 创建Zookeeper数据变更监听器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @param zkClient the zk client</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @return the data changed listener</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @ConditionalOnMissingBean(ZookeeperDataChangedListener.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public DataChangedListener zookeeperDataChangedListener(final ZkClient zkClient) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return new ZookeeperDataChangedListener(zkClient);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Zookeeper data init zookeeper data init.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         *  创建 Zookeeper 数据初始化类</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @param zkClient        the zk client</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @param syncDataService the sync data service</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @return the zookeeper data init</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @ConditionalOnMissingBean(ZookeeperDataInit.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public ZookeeperDataInit zookeeperDataInit(final ZkClient zkClient, final SyncDataService syncDataService) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return new ZookeeperDataInit(zkClient, syncDataService);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //省略了其他代码......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这个配置类是通过<code>SpringBoot</code>条件装配类实现的。在<code>ZookeeperListener</code>类上面有几个注解：</p><ul><li><p><code>@Configuration</code>：配置文件，应用上下文；</p></li><li><p><code>@ConditionalOnProperty(prefix = &quot;shenyu.sync.zookeeper&quot;, name = &quot;url&quot;)</code>：属性条件判断，满足条件，该配置类才会生效。也就是说，当我们有如下配置时，就会采用<code>zookeeper</code>进行数据同步。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI properties"><pre tabindex="0" class="prism-code language-properties codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">shenyu:  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">  sync:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     zookeeper:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          url: localhost:2181</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          sessionTimeout: 5000</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          connectionTimeout: 2000</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></li><li><p><code>@Import(ZookeeperConfiguration.class)</code>：导入另一个类<code>ZookeeperConfiguration</code>；</p></li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">  @EnableConfigurationProperties(ZookeeperProperties.class)  // 启用zk属性配置类</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public class ZookeeperConfiguration {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * register zkClient in spring ioc.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 向 Spring IOC 容器注册 zkClient</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param zookeeperProp the zookeeper configuration</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return ZkClient {@linkplain ZkClient}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      @ConditionalOnMissingBean(ZkClient.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      public ZkClient zkClient(final ZookeeperProperties zookeeperProp) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new ZkClient(zookeeperProp.getUrl(), zookeeperProp.getSessionTimeout(), zookeeperProp.getConnectionTimeout()); // 读取zk配置信息，并创建zkClient</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Data</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@ConfigurationProperties(prefix = &quot;shenyu.sync.zookeeper&quot;) // zk属性配置</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ZookeeperProperties {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String url;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Integer sessionTimeout;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Integer connectionTimeout;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String serializer;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>当我们主动配置，采用<code>zookeeper</code>进行数据同步时，<code>zookeeperDataChangedListener</code>就会生成。所以在事件处理方法<code>onApplicationEvent()</code>中，就会到相应的<code>listener</code>中。在我们的案例中，是对一条选择器数据进行更新，数据同步采用的是<code>zookeeper</code>，所以，代码会进入到<code>ZookeeperDataChangedListener</code>进行选择器数据变更处理。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @SuppressWarnings(&quot;unchecked&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onApplicationEvent(final DataChangedEvent event) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 遍历数据变更监听器(一般使用一种数据同步的方式就好了)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (DataChangedListener listener : listeners) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 哪种数据发生变更</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            switch (event.getGroupKey()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 省略了其他逻辑</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case SELECTOR:   // 选择器信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onSelectorChanged((List&lt;SelectorData&gt;) event.getSource(), event.getEventType());   // 在我们的案例中，会进入到ZookeeperDataChangedListener进行选择器数据变更处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="24-zookeeper数据变更监听器"></a>2.4 Zookeeper数据变更监听器<a class="hash-link" href="#24-zookeeper数据变更监听器" title="Direct link to heading">#</a></h4><ul><li><p>ZookeeperDataChangedListener.onSelectorChanged()</p><p>在<code>onSelectorChanged()</code>方法中，判断操作类型，是刷新同步还是更新或创建同步。根据当前选择器数据信息判断节点是否在<code>zk</code>中。</p></li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 使用 zookeeper 发布变更数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ZookeeperDataChangedListener implements DataChangedListener {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 选择器信息发生改变</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onSelectorChanged(final List&lt;SelectorData&gt; changed, final DataEventTypeEnum eventType) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 刷新操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (eventType == DataEventTypeEnum.REFRESH &amp;&amp; !changed.isEmpty()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            String selectorParentPath = DefaultPathConstants.buildSelectorParentPath(changed.get(0).getPluginName());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            deleteZkPathRecursive(selectorParentPath);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 发生变更的数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (SelectorData data : changed) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 构建选择器数据的真实路径</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            String selectorRealPath = DefaultPathConstants.buildSelectorRealPath(data.getPluginName(), data.getId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 如果是删除操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (eventType == DataEventTypeEnum.DELETE) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 删除当前数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                deleteZkPath(selectorRealPath);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                continue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 父节点路径</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            String selectorParentPath = DefaultPathConstants.buildSelectorParentPath(data.getPluginName());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 创建父节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            createZkNode(selectorParentPath);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 插入或更新数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            insertZkNode(selectorRealPath, data);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 创建 zk 节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void createZkNode(final String path) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 不存在才创建</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!zkClient.exists(path)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            zkClient.createPersistent(path, true);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 插入zk节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void insertZkNode(final String path, final Object data) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        createZkNode(path);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 通过 zkClient 写入数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        zkClient.writeData(path, null == data ? &quot;&quot; : GsonUtils.getInstance().toJson(data));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>只要将变动的数据正确写入到<code>zk</code>的节点上，<code>admin</code>这边的操作就执行完成了。<code>ShenYu</code>在使用<code>zk</code>进行数据同步时，<code>zk</code>的节点是通过精心设计的。</p><p>在我们当前的案例中，对<code>Divide</code>插件中的一条选择器数据进行更新，将权重更新为90，就会对图中的特定节点更新。</p><p><img src="/zh/assets/images/zookeeper-node-c7628b680a1f1afa0eada97b66fcd5b1.png"></p><p>我们用时序图将上面的更新流程串联起来。</p><p><img src="/zh/assets/images/zk-sync-sequence-admin-zh-afad1ef642b7130231c2ceacce236b34.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="3-网关数据同步"></a>3. 网关数据同步<a class="hash-link" href="#3-网关数据同步" title="Direct link to heading">#</a></h3><p>假设<code>ShenYu</code>网关已经在正常运行，使用的数据同步方式也是<code>zookeeper</code>。那么当在<code>admin</code>端更新选择器数据后，并且向<code>zk</code>发送了变更的数据，那网关是如何接收并处理数据的呢？接下来我们就继续进行源码分析，一探究竟。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="31-zkclient接收数据"></a>3.1 ZkClient接收数据<a class="hash-link" href="#31-zkclient接收数据" title="Direct link to heading">#</a></h4><ul><li>ZkClient.subscribeDataChanges()</li></ul><p>在网关端有一个<code>ZookeeperSyncDataService</code>类，它通过<code>ZkClient</code>订阅了数据节点，当数据发生变更时，可以感知到。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 使用 zookeeper 缓存数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ZookeeperSyncDataService implements SyncDataService, AutoCloseable {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">private void subscribeSelectorDataChanges(final String path) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">       // zkClient订阅数据节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        zkClient.subscribeDataChanges(path, new IZkDataListener() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void handleDataChange(final String dataPath, final Object data) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                cacheSelectorData(GsonUtils.getInstance().fromJson(data.toString(), SelectorData.class)); // 节点数据被更新</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void handleDataDeleted(final String dataPath) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                unCacheSelectorData(dataPath);  // 节点数据被删除</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 省略了其他逻辑</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><code>ZooKeeper</code>的<code>Watch</code>机制，会给订阅的客户端发送节点变更通知。在我们的案例中，更新选择器信息，就会进入到<code>handleDataChange()</code>方法。通过<code>cacheSelectorData()</code>去处理数据。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="32-处理数据"></a>3.2 处理数据<a class="hash-link" href="#32-处理数据" title="Direct link to heading">#</a></h4><ul><li>ZookeeperSyncDataService.cacheSelectorData()</li></ul><p>经过判空逻辑之后，缓存选择器数据的操作又交给了<code>PluginDataSubscriber</code>处理。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    private void cacheSelectorData(final SelectorData selectorData) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Optional.ofNullable(selectorData)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .ifPresent(data -&gt; Optional.ofNullable(pluginDataSubscriber).ifPresent(e -&gt; e.onSelectorSubscribe(data)));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><code>PluginDataSubscriber</code>是一个接口，它只有一个<code>CommonPluginDataSubscriber</code>实现类，负责处理插件、选择器和规则数据。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="33-通用插件数据订阅者"></a>3.3 通用插件数据订阅者<a class="hash-link" href="#33-通用插件数据订阅者" title="Direct link to heading">#</a></h4><ul><li>PluginDataSubscriber.onSelectorSubscribe()</li></ul><p>它没有其他逻辑，直接调用<code>subscribeDataHandler()</code>方法。在方法中，更具数据类型（插件、选择器或规则），操作类型（更新或删除），去执行不同逻辑。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 通用插件数据订阅者，负责处理所有插件、选择器和规则信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * The type Common plugin data subscriber.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class CommonPluginDataSubscriber implements PluginDataSubscriber {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     // 处理选择器数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onSelectorSubscribe(final SelectorData selectorData) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        subscribeDataHandler(selectorData, DataEventTypeEnum.UPDATE);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 订阅数据处理器，处理数据的更新或删除</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private &lt;T&gt; void subscribeDataHandler(final T classData, final DataEventTypeEnum dataType) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Optional.ofNullable(classData).ifPresent(data -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 插件数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (data instanceof PluginData) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                PluginData pluginData = (PluginData) data;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (dataType == DataEventTypeEnum.UPDATE) { // 更新操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 将数据保存到网关内存</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().cachePluginData(pluginData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Optional.ofNullable(handlerMap.get(pluginData.getName())).ifPresent(handler -&gt; handler.handlerPlugin(pluginData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else if (dataType == DataEventTypeEnum.DELETE) {  // 删除操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 从网关内存移除数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().removePluginData(pluginData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Optional.ofNullable(handlerMap.get(pluginData.getName())).ifPresent(handler -&gt; handler.removePlugin(pluginData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else if (data instanceof SelectorData) {  // 选择器数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                SelectorData selectorData = (SelectorData) data;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (dataType == DataEventTypeEnum.UPDATE) { // 更新操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 将数据保存到网关内存</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().cacheSelectData(selectorData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理                    Optional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -&gt; handler.handlerSelector(selectorData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else if (dataType == DataEventTypeEnum.DELETE) {  // 删除操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 从网关内存移除数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().removeSelectData(selectorData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Optional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -&gt; handler.removeSelector(selectorData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else if (data instanceof RuleData) {  // 规则数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                RuleData ruleData = (RuleData) data;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (dataType == DataEventTypeEnum.UPDATE) { // 更新操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 将数据保存到网关内存</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().cacheRuleData(ruleData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Optional.ofNullable(handlerMap.get(ruleData.getPluginName())).ifPresent(handler -&gt; handler.handlerRule(ruleData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else if (dataType == DataEventTypeEnum.DELETE) { // 删除操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 从网关内存移除数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().removeRuleData(ruleData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Optional.ofNullable(handlerMap.get(ruleData.getPluginName())).ifPresent(handler -&gt; handler.removeRule(ruleData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="34-数据缓存到内存"></a>3.4 数据缓存到内存<a class="hash-link" href="#34-数据缓存到内存" title="Direct link to heading">#</a></h4><p>那么更新一条选择器数据，会进入下面的逻辑：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// 将数据保存到网关内存</span></span><span class="token-line" style="color:#393A34"><span class="token plain">BaseDataCache.getInstance().cacheSelectData(selectorData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 如果每个插件还有自己的处理逻辑，那么就去处理                    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">Optional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -&gt; handler.handlerSelector(selectorData));</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>一是将数据保存到网关的内存中。<code>BaseDataCache</code>是最终缓存数据的类，通过单例模式实现。选择器数据就存到了<code>SELECTOR_MAP</code>这个<code>Map</code>中。在后续使用的时候，也是从这里拿数据。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public final class BaseDataCache {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 私有变量</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final BaseDataCache INSTANCE = new BaseDataCache();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 私有构造器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private BaseDataCache() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Gets instance.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *  公开方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the instance</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static BaseDataCache getInstance() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return INSTANCE;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    *  缓存选择器数据的Map</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * pluginName -&gt; SelectorData.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final ConcurrentMap&lt;String, List&lt;SelectorData&gt;&gt; SELECTOR_MAP = Maps.newConcurrentMap();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void cacheSelectData(final SelectorData selectorData) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Optional.ofNullable(selectorData).ifPresent(this::selectorAccept);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span></span><span class="token-line" style="color:#393A34"><span class="token plain">   /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * cache selector data.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 缓存选择器数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param data the selector data</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void selectorAccept(final SelectorData data) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String key = data.getPluginName();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (SELECTOR_MAP.containsKey(key)) { // 更新操作，先删除再插入</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            List&lt;SelectorData&gt; existList = SELECTOR_MAP.get(key);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            final List&lt;SelectorData&gt; resultList = existList.stream().filter(r -&gt; !r.getId().equals(data.getId())).collect(Collectors.toList());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            resultList.add(data);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            final List&lt;SelectorData&gt; collect = resultList.stream().sorted(Comparator.comparing(SelectorData::getSort)).collect(Collectors.toList());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            SELECTOR_MAP.put(key, collect);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {  // 新增操作，直接放到Map中</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            SELECTOR_MAP.put(key, Lists.newArrayList(data));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>二是如果每个插件还有自己的处理逻辑，那么就去处理。  通过<code>idea</code>编辑器可以看到，当新增一条选择器后，有如下的插件还有处理。这里我们就不再展开了。</p><p><img src="/zh/assets/images/handler-selector-bf05b8fdf80a428aa53606178a42bae6.png"></p><p>经过以上的源码追踪，并通过一个实际的案例，在<code>admin</code>端新增更新一条选择器数据，就将<code>zookeeper</code>数据同步的流程分析清楚了。</p><p>我们还是通过时序图将网关端的数据同步流程串联一下：</p><p><img src="/zh/assets/images/zk-sync-sequence-gateway-zh-0494aedc4de3f64c781fe8bb6c4b69bc.png"></p><p>数据同步的流程已经分析完了，为了不让同步流程被打断，在分析过程中就忽略了其他逻辑。我们还需要分析<code>Admin</code>同步数据初始化和网关同步操作初始化的流程。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="4-admin同步数据初始化"></a>4. Admin同步数据初始化<a class="hash-link" href="#4-admin同步数据初始化" title="Direct link to heading">#</a></h3><p>当<code>admin</code>启动后，会将当前的数据信息全量同步到<code>zk</code>中，实现逻辑如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Zookeeper 数据初始化</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ZookeeperDataInit implements CommandLineRunner {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final ZkClient zkClient;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final SyncDataService syncDataService;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Instantiates a new Zookeeper data init.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param zkClient        the zk client</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param syncDataService the sync data service</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ZookeeperDataInit(final ZkClient zkClient, final SyncDataService syncDataService) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.zkClient = zkClient;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.syncDataService = syncDataService;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run(final String... args) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String pluginPath = DefaultPathConstants.PLUGIN_PARENT;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String authPath = DefaultPathConstants.APP_AUTH_PARENT;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String metaDataPath = DefaultPathConstants.META_DATA;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 判断zk中是否存在数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!zkClient.exists(pluginPath) &amp;&amp; !zkClient.exists(authPath) &amp;&amp; !zkClient.exists(metaDataPath)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            syncDataService.syncAll(DataEventTypeEnum.REFRESH);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>判断<code>zk</code>中是否存在数据，如果不存在，则进行同步。</p><p><code>ZookeeperDataInit</code>实现了<code>CommandLineRunner</code>接口。它是<code>springboot</code>提供的接口，会在所有 <code>Spring Beans</code>初始化之后执行<code>run()</code>方法，常用于项目中初始化的操作。</p><ul><li>SyncDataService.syncAll()</li></ul><p>从数据库查询数据，然后进行全量数据同步，所有的认证信息、插件信息、选择器信息、规则信息和元数据信息。主要是通过<code>eventPublisher</code>发布同步事件。这里就跟前面提到的同步逻辑就又联系起来了，<code>eventPublisher</code>通过<code>publishEvent()</code>发布完事件后，有<code>ApplicationListener</code>执行事件变更操作，在<code>ShenYu</code>中就是前面提到的<code>DataChangedEventDispatcher</code>。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Service</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SyncDataServiceImpl implements SyncDataService {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 事件发布</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final ApplicationEventPublisher eventPublisher;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">     /***</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 全量数据同步</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param type the type</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean syncAll(final DataEventTypeEnum type) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 同步认证信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        appAuthService.syncData();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 同步插件信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;PluginData&gt; pluginDataList = pluginService.listAll();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.PLUGIN, type, pluginDataList));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 同步选择器信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;SelectorData&gt; selectorDataList = selectorService.listAll();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.SELECTOR, type, selectorDataList));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 同步规则信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;RuleData&gt; ruleDataList = ruleService.listAll();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.RULE, type, ruleDataList));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 同步元数据信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        metaDataService.syncData();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="5-网关同步操作初始化"></a>5. 网关同步操作初始化<a class="hash-link" href="#5-网关同步操作初始化" title="Direct link to heading">#</a></h3><p>网关这边的数据同步初始化操作主要是订阅<code>zk</code>中的节点，当有数据变更时，收到变更数据。这依赖于<code>ZooKeeper</code>的<code>Watch</code>机制。在<code>ShenYu</code>中，负责<code>zk</code>数据同步的是<code>ZookeeperSyncDataService</code>，也在前面提到过。</p><p><code>ZookeeperSyncDataService</code>的功能逻辑是在实例化的过程中完成的：对<code>zk</code>中的<code>shenyu</code>数据同步节点完成订阅。这里的订阅分两类，一类是已经存在的节点上面数据发生更新，这通过<code>zkClient.subscribeDataChanges()</code>方法实现；另一类是当前节点下有新增或删除节点，即子节点发生变化，这通过<code>zkClient.subscribeChildChanges()</code>方法实现。</p><p><code>ZookeeperSyncDataService</code>的代码有点多，这里我们以插件数据的读取和订阅进行追踪，其他类型的数据操作原理是一样的。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> *  zookeeper 数据同步服务</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ZookeeperSyncDataService implements SyncDataService, AutoCloseable {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 在实例化的时候，完成从zk中读取数据的操作，并订阅节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ZookeeperSyncDataService( /*省略构造参数参数*/ ) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.zkClient = zkClient;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.pluginDataSubscriber = pluginDataSubscriber;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.metaDataSubscribers = metaDataSubscribers;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.authDataSubscribers = authDataSubscribers;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 订阅插件、选择器和规则数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        watcherData();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 订阅认证数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        watchAppAuth();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 订阅元数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        watchMetaData();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void watcherData() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 插件节点路径</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        final String pluginParent = DefaultPathConstants.PLUGIN_PARENT;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 所有插件节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;String&gt; pluginZKs = zkClientGetChildren(pluginParent);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (String pluginName : pluginZKs) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 订阅当前所有插件、选择器和规则数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            watcherAll(pluginName);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 订阅子节点（新增或删除一个插件）</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        zkClient.subscribeChildChanges(pluginParent, (parentPath, currentChildren) -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (CollectionUtils.isNotEmpty(currentChildren)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (String pluginName : currentChildren) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 需要订阅子节点的所有插件、选择器和规则数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    watcherAll(pluginName);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void watcherAll(final String pluginName) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 订阅插件数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        watcherPlugin(pluginName);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 订阅选择器数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        watcherSelector(pluginName);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 订阅规则数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        watcherRule(pluginName);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void watcherPlugin(final String pluginName) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 当前插件路径</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String pluginPath = DefaultPathConstants.buildPluginPath(pluginName);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 是否存在，不存在就创建</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!zkClient.exists(pluginPath)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            zkClient.createPersistent(pluginPath, true);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 读取zk上当前节点数据，并反序列化</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        PluginData pluginData = null == zkClient.readData(pluginPath) ? null</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                : GsonUtils.getInstance().fromJson((String) zkClient.readData(pluginPath), PluginData.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 缓存到网关内存中</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        cachePluginData(pluginData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 订阅插件节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        subscribePluginDataChanges(pluginPath, pluginName);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">   private void cachePluginData(final PluginData pluginData) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">       // 省略实现逻辑，其实就是 CommonPluginDataSubscriber 中的操作，跟前面都能联系起来</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void subscribePluginDataChanges(final String pluginPath, final String pluginName) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 订阅数据变更：更新或删除</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        zkClient.subscribeDataChanges(pluginPath, new IZkDataListener() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void handleDataChange(final String dataPath, final Object data) {  // 更新操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                 // 省略实现逻辑，其实就是 CommonPluginDataSubscriber 中的操作，跟前面都能联系起来</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void handleDataDeleted(final String dataPath) {   // 删除操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                  // 省略实现逻辑，其实就是 CommonPluginDataSubscriber 中的操作，跟前面都能联系起来</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}    </span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>上面的源代码中都给出了注释，相信大家可以看明白。订阅插件数据的主要逻辑如下：</p><blockquote><ol><li>构造当前插件路径</li><li>路径是否存在，不存在就创建</li><li>读取zk上当前节点数据，并反序列化</li><li>插件数据缓存到网关内存中</li><li>订阅插件节点</li></ol></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="6-总结"></a>6. 总结<a class="hash-link" href="#6-总结" title="Direct link to heading">#</a></h3><p>本文通过一个实际案例，对<code>zookeeper</code>的数据同步原理进行了源码分析。涉及到的主要知识点如下：</p><ul><li>基于<code>zookeeper</code>的数据同步，主要是通过<code>watch</code>机制实现；</li><li>通过<code>Spring</code>完成事件发布和监听；</li><li>通过抽象<code>DataChangedListener</code>接口，支持多种同步策略，面向接口编程；</li><li>使用单例设计模式实现缓存数据类<code>BaseDataCache</code>；</li><li>通过<code>SpringBoot</code>的条件装配和<code>starter</code>加载机制实现配置类的加载。</li></ul></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><a class="margin-horiz--sm" href="/zh/blog/tags/zookeeper">zookeeper</a><a class="margin-horiz--sm" href="/zh/blog/tags/data-sync">data sync</a><a class="margin-horiz--sm" href="/zh/blog/tags/apache-shen-yu">Apache ShenYu</a></div></footer></article><article class="margin-bottom--xl"><header><h2 class="blogPostTitle_d4p0"><a href="/zh/blog/Plugin-SourceCode-Analysis-Context-Path-Plugin">Context-Path插件源码分析</a></h2><div class="blogPostData_-Im+ margin-vert--md"><time datetime="2021-12-14T03:31:25.749Z">2021年12月14日</time> · One min read</div><div class="avatar margin-vert--md"><a href="https://github.com/JooKS-me" target="_blank" rel="noopener noreferrer" class="avatar__photo-link avatar__photo"><img src="https://avatars1.githubusercontent.com/u/62384022?v=4" alt="Kunshuai Zhu"></a><div class="avatar__intro"><div class="avatar__name"><a href="https://github.com/JooKS-me" target="_blank" rel="noopener noreferrer">Kunshuai Zhu</a></div><small class="avatar__subtitle">Apache ShenYu Contributor</small></div></div></header><div class="markdown"><blockquote><p>开始前，可以参考 <a href="/zh/start-demo">这篇文章</a> 运行shenyu网关</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="正文"></a>正文<a class="hash-link" href="#正文" title="Direct link to heading">#</a></h3><p>首先，看<code>ContextPathPlugin#doExecute</code>方法，这是这个插件的核心。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">protected Mono&lt;Void&gt; doExecute(final ServerWebExchange exchange, final ShenyuPluginChain chain, final SelectorData selector, final RuleData rule) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 1. 从JVM缓存中取得contextMappingHandle</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ContextMappingHandle contextMappingHandle = ContextPathPluginDataHandler.CACHED_HANDLE.get().obtainHandle(CacheKeyUtils.INST.getKey(rule));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 2. 根据contextMappingHandle设置shenyu上下文</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    buildContextPath(shenyuContext, contextMappingHandle);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return chain.execute(exchange);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ol><li><p>从JVM缓存中取得<code>contextMappingHandle</code></p><p>这里的<code>contextMappingHandle</code>是<code>ContextMappingHandle</code>类的实例，里面有两个成员变量：<code>contextPath</code>和<code>addPrefix</code></p><p>这两个变量在之前Admin里面的Rules表单里有出现过，是在数据同步的时候更新的。</p></li><li><p>根据contextMappingHandle设置shenyu上下文</p><p>下面是<code>ContextPathPlugin#buildContextPath</code>方法的源代码</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">private void buildContextPath(final ShenyuContext context, final ContextMappingHandle handle) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    String realURI = &quot;&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 1. 设置shenyu的context path，根据contextPath的长度将真实URI的前缀去掉</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (StringUtils.isNoneBlank(handle.getContextPath())) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        context.setContextPath(handle.getContextPath());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        context.setModule(handle.getContextPath());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        realURI = context.getPath().substring(handle.getContextPath().length());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 加上前缀</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (StringUtils.isNoneBlank(handle.getAddPrefix())) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (StringUtils.isNotBlank(realURI)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            realURI = handle.getAddPrefix() + realURI;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            realURI = handle.getAddPrefix() + context.getPath();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    context.setRealUrl(realURI);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li><p>设置shenyu的context path，<strong>根据contextPath的长度将真实URI的前缀去掉</strong></p><p>你可能会有疑问，<strong>这里所谓的「根据contextPath的长度」会不会有问题呢？</strong></p><p>实际上这样的判断是没有问题的，因为请求在被Selector和Rules匹配到之后，才会被插件处理。所以在设置好Selector和Rules的前提下，是完全可以满足转换特定contextPath的需求的。</p></li></ul></li></ol><p>然后，<code>ContextPathPlugin</code>类还有一个比较重要的方法<code>skip</code>，下面展示了部分代码。我们可以发现：<strong>如果是对RPC服务的调用，就会直接跳过context_path插件。</strong></p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public Boolean skip(final ServerWebExchange exchange) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return Objects.equals(rpcType, RpcTypeEnum.DUBBO.getName())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            || Objects.equals(rpcType, RpcTypeEnum.GRPC.getName())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            || Objects.equals(rpcType, RpcTypeEnum.TARS.getName())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            || Objects.equals(rpcType, RpcTypeEnum.MOTAN.getName())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            || Objects.equals(rpcType, RpcTypeEnum.SOFA.getName());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>最后，context_path插件还有另一个类<code>ContextPathPluginDataHandler</code>。这个类的作用是订阅插件的数据，当插件配置被修改、删除、增加时，就往JVM缓存里面修改、删除、新增数据。</p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><a class="margin-horiz--sm" href="/zh/blog/tags/context-path">Context-Path</a><a class="margin-horiz--sm" href="/zh/blog/tags/apache-shen-yu">Apache ShenYu</a></div></footer></article><article class="margin-bottom--xl"><header><h2 class="blogPostTitle_d4p0"><a href="/zh/blog/Plugin-SourceCode-Analysis-Param-Mapping-Plugin">Param-Mapping插件源码分析</a></h2><div class="blogPostData_-Im+ margin-vert--md"><time datetime="2021-12-14T03:31:25.749Z">2021年12月14日</time> · One min read</div><div class="avatar margin-vert--md"><a href="https://github.com/JooKS-me" target="_blank" rel="noopener noreferrer" class="avatar__photo-link avatar__photo"><img src="https://avatars1.githubusercontent.com/u/62384022?v=4" alt="Kunshuai Zhu"></a><div class="avatar__intro"><div class="avatar__name"><a href="https://github.com/JooKS-me" target="_blank" rel="noopener noreferrer">Kunshuai Zhu</a></div><small class="avatar__subtitle">Apache ShenYu Contributor</small></div></div></header><div class="markdown"><blockquote><p>开始前，可以参考 <a href="/zh/start-demo">这篇文章</a> 运行shenyu网关</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="正文"></a>正文<a class="hash-link" href="#正文" title="Direct link to heading">#</a></h3><p>先看一下这个插件的结构，如下图。</p><p><img alt="param-mapping-structure" src="/zh/assets/images/param-mapping-structure-1d2b4243e835eeff74fc6ea114dcbee7.png"></p><p>猜测：handler是用来做数据同步的；strategy中文意思是策略，可能是对各种请求体做了适配，应该是这个插件的重点；<code>ParamMappingPlugin</code> 应该是 <code>ShenyuPlugin</code> 的实现。</p><p>首先，看一下 <code>ParamMappingPlugin</code> ，里面主要是对 <code>doExecute</code> 方法的重写。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public Mono&lt;Void&gt; doExecute(final ServerWebExchange exchange, final ShenyuPluginChain chain, final SelectorData selector, final RuleData rule) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ... // paramMappingHandle判断是否为空</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 根据首部行中的contentType确定请求体类型</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    HttpHeaders headers = exchange.getRequest().getHeaders();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    MediaType contentType = headers.getContentType();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return match(contentType).apply(exchange, chain, paramMappingHandle);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li><p>match方法是根据contentType返回对应的 <code>Operator</code></p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">private Operator match(final MediaType mediaType) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (MediaType.APPLICATION_JSON.isCompatibleWith(mediaType)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return operatorMap.get(MediaType.APPLICATION_JSON.toString());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else if (MediaType.APPLICATION_FORM_URLENCODED.isCompatibleWith(mediaType)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return operatorMap.get(MediaType.APPLICATION_FORM_URLENCODED.toString());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return operatorMap.get(Constants.DEFAULT);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>从match方法的代码可以看出，目前有 <code>DefaultOperator</code>、<code>FormDataOperator</code>、<code>JsonOperator</code>三种，支持 <code>x-www-form-urlencoded</code> 和 <code>json</code> 两种格式的请求体。</p></li></ul><p>那么我们就来看一下上面三种Operator究竟是怎么样的吧。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="一defaultoperator"></a>一、DefaultOperator<a class="hash-link" href="#一defaultoperator" title="Direct link to heading">#</a></h4><p>虚晃一枪，它的apply方法只是继续执行插件链，并没有实质功能。当请求体没有匹配到Operator时，就会通过 <code>DefaultOperator</code> 跳过。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="二formdataoperator"></a>二、FormDataOperator<a class="hash-link" href="#二formdataoperator" title="Direct link to heading">#</a></h4><p>这个类是用来处理 <code>x-www-form-urlencoded</code> 格式的请求体的。</p><p>主要是看apply方法，但是这个apply方法长得有点奇怪。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public Mono&lt;Void&gt; apply(final ServerWebExchange exchange, final ShenyuPluginChain shenyuPluginChain, final ParamMappingHandle paramMappingHandle) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return exchange.getFormData()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            .switchIfEmpty(Mono.defer(() -&gt; Mono.just(new LinkedMultiValueMap&lt;&gt;())))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            .flatMap(multiValueMap -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                ...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>省略号中的代码是对请求体的处理，如下。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// 判空</span></span><span class="token-line" style="color:#393A34"><span class="token plain">if (Objects.isNull(multiValueMap) || multiValueMap.isEmpty()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return shenyuPluginChain.execute(exchange);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 将form-data转化成json</span></span><span class="token-line" style="color:#393A34"><span class="token plain">String original = GsonUtils.getInstance().toJson(multiValueMap);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">LOG.info(&quot;get from data success data:{}&quot;, original);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// *修改请求体*</span></span><span class="token-line" style="color:#393A34"><span class="token plain">String modify = operation(original, paramMappingHandle);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">if (StringUtils.isEmpty(modify)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return shenyuPluginChain.execute(exchange);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 将修改后的json，转换成LinkedMultiValueMap。注意一下这一行，后面会提到！</span></span><span class="token-line" style="color:#393A34"><span class="token plain">LinkedMultiValueMap&lt;String, String&gt; modifyMap = GsonUtils.getInstance().toLinkedMultiValueMap(modify);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">final BodyInserter bodyInserter = BodyInserters.fromValue(modifyMap);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 修改exchange中的请求体，然后继续执行插件链</span></span><span class="token-line" style="color:#393A34"><span class="token plain">return bodyInserter.insert(cachedBodyOutputMessage, new BodyInserterContext())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        .then(Mono.defer(() -&gt; shenyuPluginChain.execute(exchange.mutate()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .request(new ModifyServerHttpRequestDecorator(httpHeaders, exchange.getRequest(), cachedBodyOutputMessage))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .build())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        )).onErrorResume((Function&lt;Throwable, Mono&lt;Void&gt;&gt;) throwable -&gt; release(cachedBodyOutputMessage, throwable));</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><blockquote><p>PS: 省略的部分是设置请求头等操作。</p></blockquote><p>上面比较重要的应该是打星的修改请求体，也就是 <code>operation</code> 方法的调用。这里因为参数类型的原因，会先调用 <code>Operator</code> 接口的默认方法（而不是 <code>FormDataOperator</code> 重写的）。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">default String operation(final String jsonValue, final ParamMappingHandle paramMappingHandle) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    DocumentContext context = JsonPath.parse(jsonValue);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 调用重写的operation方法，添加addParameterKey</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    operation(context, paramMappingHandle);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 对设置的replacedParameterKey进行替换</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!CollectionUtils.isEmpty(paramMappingHandle.getReplaceParameterKeys())) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        paramMappingHandle.getReplaceParameterKeys().forEach(info -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            context.renameKey(info.getPath(), info.getKey(), info.getValue());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 对设置的removeParameterKey进行删除</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!CollectionUtils.isEmpty(paramMappingHandle.getRemoveParameterKeys())) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        paramMappingHandle.getRemoveParameterKeys().forEach(info -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            context.delete(info);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return context.jsonString();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>梳理下来可以发现，这里引入的json工具<a href="https://github.com/json-path/JsonPath" target="_blank" rel="noopener noreferrer">JsonPath</a>使得请求体的加工变得简单、清晰很多。</p><p><strong>另外，我们可以注意到 <code>FormDataOperator</code> 重写了 <code>operation(DocumentContext, ParamMappingHandle)</code> 方法。</strong></p><p><strong>为什么要重写呢？</strong> 接口中有对应处理addParameterKey的默认方法啊。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// Operator接口中的默认方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">default void operation(final DocumentContext context, final ParamMappingHandle paramMappingHandle) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!CollectionUtils.isEmpty(paramMappingHandle.getAddParameterKeys())) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        paramMappingHandle.getAddParameterKeys().forEach(info -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            context.put(info.getPath(), info.getKey(), info.getValue()); //不同之处</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// FormDataOperator重写的方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public void operation(final DocumentContext context, final ParamMappingHandle paramMappingHandle) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!CollectionUtils.isEmpty(paramMappingHandle.getAddParameterKeys())) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        paramMappingHandle.getAddParameterKeys().forEach(info -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            context.put(info.getPath(), info.getKey(), Arrays.asList(info.getValue()));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>实际上，在 <code>FormDataOperator#apply</code> 中有这么一行（前面有提到）：<code>LinkedMultiValueMap&lt;String, String&gt; modifyMap = GsonUtils.getInstance().toLinkedMultiValueMap(modify);</code></p><p>这一行是将修改后的json转换成 <code>LinkedMultiValueMap</code>，<code>GsonUtils#toLinkedMultiValueMap</code> 如下。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public LinkedMultiValueMap&lt;String, String&gt; toLinkedMultiValueMap(final String json) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return GSON.fromJson(json, new TypeToken&lt;LinkedMultiValueMap&lt;String, String&gt;&gt;() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }.getType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>而 <code>LinkedMultiValueMap</code> 类中的属性 <code>targetMap</code> 定义为：<code>private final Map&lt;K, List&lt;V&gt;&gt; targetMap</code></p><p>因此，json字符串中的value必须是列表形式的，不然Gson就会抛出转换错误的异常，这也就是为什么 <code>FormDataOperator</code> 要重写operator方法。</p><p><strong>那么为什么要用 <code>LinkedMultiValueMap</code> 呢？</strong></p><p>回到 <code>FormDataOperator#apply</code> 方法的第一行 <code>exchange.getFormData</code> 。而SpringMVC中，<code>DefaultServerWebExchange#getFormData</code> 的返回值类型就是 <code>Mono&lt;MultiValueMap&lt;String, String&gt;&gt;</code> ，而 <code>LinkedMultiValueMap</code> 是 <code>MultiValueMap</code> 的子类。并且，<code>getFormData</code> 方法就是针对 <code>x-www-form-urlencoded</code> 格式的请求体的。</p><p><img alt="param-mapping-getFormData" src="/zh/assets/images/param-mapping-getFormData-04b664908cd5f52d149eb1098d5648c9.png"></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="三jsonoperator"></a>三、JsonOperator<a class="hash-link" href="#三jsonoperator" title="Direct link to heading">#</a></h4><p>显然，这个类是用来处理Json格式的请求体的。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public Mono&lt;Void&gt; apply(final ServerWebExchange exchange, final ShenyuPluginChain shenyuPluginChain, final ParamMappingHandle paramMappingHandle) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ServerRequest serverRequest = ServerRequest.create(exchange, MESSAGE_READERS);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Mono&lt;String&gt; mono = serverRequest.bodyToMono(String.class).switchIfEmpty(Mono.defer(() -&gt; Mono.just(&quot;&quot;))).flatMap(originalBody -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        LOG.info(&quot;get body data success data:{}&quot;, originalBody);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 调用默认的operation方法修改请求体</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String modify = operation(originalBody, paramMappingHandle);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Mono.just(modify);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    BodyInserter bodyInserter = BodyInserters.fromPublisher(mono, String.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ... //处理首部行</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    CachedBodyOutputMessage outputMessage = new CachedBodyOutputMessage(exchange, headers);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 修改exchange中的请求体，然后继续执行插件链</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return bodyInserter.insert(outputMessage, new BodyInserterContext())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            .then(Mono.defer(() -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                ServerHttpRequestDecorator decorator = new ModifyServerHttpRequestDecorator(headers, exchange.getRequest(), outputMessage);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                return shenyuPluginChain.execute(exchange.mutate().request(decorator).build());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            })).onErrorResume((Function&lt;Throwable, Mono&lt;Void&gt;&gt;) throwable -&gt; release(outputMessage, throwable));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><code>JsonOperator</code> 的处理流程与 <code>FormDataOperator</code> 大致类似。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="总结"></a>总结<a class="hash-link" href="#总结" title="Direct link to heading">#</a></h3><p>最后，用一张图来简单总结一下。</p><p><img alt="param-mapping-summary" src="/zh/assets/images/param-mapping-summary-490cf9ee499bf9efc03d0c963b39118c.jpg"></p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><a class="margin-horiz--sm" href="/zh/blog/tags/param-mapping">Param-Mapping</a><a class="margin-horiz--sm" href="/zh/blog/tags/apache-shen-yu">Apache ShenYu</a></div></footer></article><article class="margin-bottom--xl"><header><h2 class="blogPostTitle_d4p0"><a href="/zh/blog/RegisterCenter-SourceCode-Analysis-Http-Register">注册中心实现原理之Http注册</a></h2><div class="blogPostData_-Im+ margin-vert--md"><time datetime="2021-12-14T03:31:25.749Z">2021年12月14日</time> · One min read</div><div class="avatar margin-vert--md"><div class="avatar__intro"><div class="avatar__name"><a href="https://github.com/midnight2104" target="_blank" rel="noopener noreferrer">midnight2104</a></div><small class="avatar__subtitle">Apache ShenYu Committer</small></div></div></header><div class="markdown"><blockquote><p><a href="https://shenyu.apache.org/zh/docs/index" target="_blank" rel="noopener noreferrer">Apache ShenYu</a> 是一个异步的，高性能的，跨语言的，响应式的 <code>API</code> 网关。</p></blockquote><p>在<code>ShenYu</code>网关中，注册中心是用于将客户端信息注册到<code>shenyu-admin</code>，<code>admin</code>再通过数据同步将这些信息同步到网关，网关通过这些数据完成流量筛选。客户端信息主要包括<code>接口信息</code>和<code>URI信息</code>。</p><blockquote><p>本文基于<code>shenyu-2.4.1</code>版本进行源码分析，官网的介绍请参考 <a href="https://shenyu.apache.org/zh/docs/design/register-center-design" target="_blank" rel="noopener noreferrer">客户端接入原理</a> 。</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="1-注册中心原理"></a>1. 注册中心原理<a class="hash-link" href="#1-注册中心原理" title="Direct link to heading">#</a></h3><p>当客户端启动时，读取接口信息和<code>uri信息</code>，通过指定的注册类型，将数据发送到<code>shenyu-admin</code>。</p><p><img src="/zh/assets/images/register-center-6df3139bde6babdb3360f928f93bf737.png"></p><p>图中的注册中心需要用户指定使用哪种注册类型，<code>ShenYu</code>当前支持<code>Http</code>、<code>Zookeeper</code>、<code>Etcd</code>、<code>Consul</code>和<code>Nacos</code>进行注册。具体如何配置请参考 <a href="https://shenyu.apache.org/zh/docs/user-guide/register-center-access" target="_blank" rel="noopener noreferrer">客户端接入配置</a> 。</p><p><code>ShenYu</code>在注册中心的原理设计上引入了<code>Disruptor</code>，<code>Disruptor</code>队列在其中起到数据与操作解耦，利于扩展。如果注册请求过多，导致注册异常，也有数据缓冲作用。</p><p><img src="/zh/assets/images/shenyu-register-center-679a8ce3a7173b5f7a29f312448efa47.png"></p><p>如图所示，注册中心分为两个部分，一是注册中心客户端<code>register-client</code>，负载处理客户端数据读取。另一个是注册中心服务端<code>register-server</code>，负载处理服务端（就是<code>shenyu-admin</code>）数据写入。通过指定注册类型进行数据发送和接收。</p><ul><li>客户端：通常来说就是一个微服务，可以是<code>springmvc</code>，<code>spring-cloud</code>，<code>dubbo</code>，<code>grpc</code>等。</li><li><code>register-client</code>：注册中心客户端，读取客户接口和<code>uri</code>信息。</li><li><code>Disruptor</code>：数据与操作解耦，数据缓冲作用。</li><li><code>register-server</code>：注册中心服务端，这里就是<code>shenyu-admin</code>，接收数据，写入数据库，发数据同步事件。</li><li>注册类型：指定注册类型，完成数据注册，当前支持<code>Http</code>、<code>Zookeeper</code>、<code>Etcd</code>、<code>Consul</code>和<code>Nacos</code>。</li></ul><p>本文分析的是使用<code>Http</code>的方式进行注册，所以具体的处理流程如下：</p><p><img src="/zh/assets/images/shenyu-register-center-http-540b66ff202c41000b463cfae8403699.png"></p><p>在客户端，数据出队列后，通过<code>http</code>传输数据，在服务端，提供相应的接口，接收数据，然后写入队列。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="2-客户端注册流程"></a>2. 客户端注册流程<a class="hash-link" href="#2-客户端注册流程" title="Direct link to heading">#</a></h3><p>当客户端启动后，根据相关配置，读取属性信息，然后写入队列。以官方提供的 <a href="https://github.com/apache/incubator-shenyu/tree/master/shenyu-examples/shenyu-examples-http" target="_blank" rel="noopener noreferrer">shenyu-examples-http</a> 为例，开始源码分析。官方提供的例子是一个由<code>springboot</code>构建的微服务。注册中心的相关配置可以参考官网  <a href="https://shenyu.apache.org/zh/docs/user-guide/register-center-access" target="_blank" rel="noopener noreferrer">客户端接入配置</a> 。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="21-加载配置读取属性"></a>2.1 加载配置，读取属性<a class="hash-link" href="#21-加载配置读取属性" title="Direct link to heading">#</a></h4><p>先用一张图串联下注册中心客户端初始化流程：</p><p><img src="/zh/assets/images/client-register-init-zh-f92d1323e8068e4f0708e71234bf6d70.png"></p><p>我们分析的是通过<code>http</code>的方式进行注册，所以需要进行如下配置：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI xml"><pre tabindex="0" class="prism-code language-xml codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">shenyu:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  register:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    registerType: http</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    serverLists: http://localhost:9095</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  client:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    http:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        props:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          contextPath: /http</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          appName: http</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          port: 8189  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">          isFull: false</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>每个属性表示的含义如下：</p><ul><li><code>registerType</code>: 服务注册类型，填写 <code>http</code>。</li><li><code>serverList</code>: 为<code>http</code>注册类型时，填写<code>Shenyu-Admin</code>项目的地址，注意加上<code>http://</code>，多个地址用英文逗号分隔。</li><li><code>port</code>: 你本项目的启动端口，目前<code>springmvc/tars/grpc</code>需要进行填写。</li><li><code>contextPath</code>: 为你的这个<code>mvc</code>项目在<code>shenyu</code>网关的路由前缀， 比如<code>/order</code> ，<code>/product</code> 等等，网关会根据你的这个前缀来进行路由。</li><li><code>appName</code>：你的应用名称，不配置的话，会默认取 <code>spring.application.name</code> 的值。</li><li><code>isFull</code>: 设置 <code>true</code> 代表代理你的整个服务，<code>false</code>表示代理你其中某几个<code>controller</code>；目前适用于<code>springmvc/springcloud</code>。</li></ul><p>项目启动后，会先加载配置文件，读取属性信息，生成相应的<code>Bean</code>。</p><p>首先读取到的配置文件是 <code>ShenyuSpringMvcClientConfiguration</code>，它是<code>shenyu</code> 客户端<code>http</code>注册配置类，通过<code>@Configuration</code>表示这是一个配置类，通过<code>@ImportAutoConfiguration</code>引入其他配置类。创建<code>SpringMvcClientBeanPostProcessor</code>，主要处理元数据。创建<code>ContextRegisterListener</code>，主要处理 <code>URI</code> 信息。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * shenyu 客户端http注册配置类</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Configuration</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@ImportAutoConfiguration(ShenyuClientCommonBeanConfiguration.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ShenyuSpringMvcClientConfiguration {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //创建SpringMvcClientBeanPostProcessor，主要处理元数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public SpringMvcClientBeanPostProcessor springHttpClientBeanPostProcessor(final ShenyuClientConfig clientConfig,final ShenyuClientRegisterRepository shenyuClientRegisterRepository) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new SpringMvcClientBeanPostProcessor(clientConfig.getClient().get(RpcTypeEnum.HTTP.getName()), shenyuClientRegisterRepository);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">   // 创建ContextRegisterListener，主要处理 URI信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ContextRegisterListener contextRegisterListener(final ShenyuClientConfig clientConfig) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new ContextRegisterListener(clientConfig.getClient().get(RpcTypeEnum.HTTP.getName()));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><code>ShenyuClientCommonBeanConfiguration</code>是<code>shenyu</code>客户端通用配置类，会创建注册中心客户端通用的<code>bean</code>。</p><ul><li>创建<code>ShenyuClientRegisterRepository</code>，通过工厂类创建而成。</li><li>创建<code>ShenyuRegisterCenterConfig</code>，读取<code>shenyu.register</code>属性配置。</li><li>创建<code>ShenyuClientConfig</code>，读取<code>shenyu.client</code>属性配置。</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * shenyu客户端通用配置类</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Configuration</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ShenyuClientCommonBeanConfiguration {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">   // 创建ShenyuClientRegisterRepository，通过工厂类创建而成。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ShenyuClientRegisterRepository shenyuClientRegisterRepository(final ShenyuRegisterCenterConfig config) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ShenyuClientRegisterRepositoryFactory.newInstance(config);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 创建ShenyuRegisterCenterConfig，读取shenyu.register属性配置</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @ConfigurationProperties(prefix = &quot;shenyu.register&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ShenyuRegisterCenterConfig shenyuRegisterCenterConfig() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new ShenyuRegisterCenterConfig();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 创建ShenyuClientConfig，读取shenyu.client属性配置</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @ConfigurationProperties(prefix = &quot;shenyu&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ShenyuClientConfig shenyuClientConfig() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new ShenyuClientConfig();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="22-用于注册的-httpclientregisterrepository"></a>2.2 用于注册的 HttpClientRegisterRepository<a class="hash-link" href="#22-用于注册的-httpclientregisterrepository" title="Direct link to heading">#</a></h4><p>上面的配置文件中生成的<code>ShenyuClientRegisterRepository</code>是客户端注册的具体实现，它是一个接口，它的实现类如下。</p><p><img src="/zh/assets/images/shenyu-client-register-repository-57035be945a0a8fc435049c13c0dac57.png"></p><ul><li><code>HttpClientRegisterRepository</code>：通过<code>http</code>进行注册；</li><li><code>ConsulClientRegisterRepository</code>：通过<code>Consul</code>进行注册；</li><li><code>EtcdClientRegisterRepository</code>：通过<code>Etcd</code>进行注册；</li><li><code>NacosClientRegisterRepository</code>：通过<code>nacos</code>进行注册；</li><li><code>ZookeeperClientRegisterRepository</code>通过<code>Zookeeper</code>进行注册。</li></ul><p>具体是哪一种方式，是通过<code>SPI</code>进行加载实现的，实现逻辑如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 加载 ShenyuClientRegisterRepository</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public final class ShenyuClientRegisterRepositoryFactory {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final Map&lt;String, ShenyuClientRegisterRepository&gt; REPOSITORY_MAP = new ConcurrentHashMap&lt;&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 创建 ShenyuClientRegisterRepository</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static ShenyuClientRegisterRepository newInstance(final ShenyuRegisterCenterConfig shenyuRegisterCenterConfig) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!REPOSITORY_MAP.containsKey(shenyuRegisterCenterConfig.getRegisterType())) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 通过SPI的方式进行加载，类型由registerType决定</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            ShenyuClientRegisterRepository result = ExtensionLoader.getExtensionLoader(ShenyuClientRegisterRepository.class).getJoin(shenyuRegisterCenterConfig.getRegisterType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            //执行初始化操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            result.init(shenyuRegisterCenterConfig);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            ShenyuClientShutdownHook.set(result, shenyuRegisterCenterConfig.getProps());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            REPOSITORY_MAP.put(shenyuRegisterCenterConfig.getRegisterType(), result);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return result;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return REPOSITORY_MAP.get(shenyuRegisterCenterConfig.getRegisterType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>加载类型通过<code>registerType</code>指定，也就是我们在配置文件中指定的类型：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI xml"><pre tabindex="0" class="prism-code language-xml codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">shenyu:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  register:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    registerType: http</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    serverLists: http://localhost:9095</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>我们指定的是<code>http</code>，所以会去加载<code>HttpClientRegisterRepository</code>。对象创建成功后，执行的初始化方法<code>init()</code>如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI jav"><pre tabindex="0" class="prism-code language-jav codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Join</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class HttpClientRegisterRepository implements ShenyuClientRegisterRepository {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void init(final ShenyuRegisterCenterConfig config) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.serverList = Lists.newArrayList(Splitter.on(&quot;,&quot;).split(config.getServerLists()));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 暂时省略其他逻辑</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>读取配置文件中的<code>serverLists</code>，即<code>sheenyu-admin</code>的地址，为后续数据发送做准备。类注解<code>@Join</code>用于<code>SPI</code>的加载。</p><blockquote><p><code>SPI</code> 全称为 <code>Service Provider Interface</code>, 是 <code>JDK</code> 内置的一种服务提供发现功能, 一种动态替换发现的机制。</p><p><a href="https://github.com/apache/incubator-shenyu/tree/master/shenyu-spi" target="_blank" rel="noopener noreferrer">shenyu-spi</a> 是<code>Apache ShenYu</code>网关自定义的<code>SPI</code>扩展实现，设计和实现原理参考了<code>Dubbo</code>的 <a href="https://dubbo.apache.org/zh/docs/v2.7/dev/impls/" target="_blank" rel="noopener noreferrer">SPI扩展实现</a> 。</p></blockquote><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="23-构建元数据的-springmvcclientbeanpostprocessor"></a>2.3 构建元数据的 SpringMvcClientBeanPostProcessor<a class="hash-link" href="#23-构建元数据的-springmvcclientbeanpostprocessor" title="Direct link to heading">#</a></h4><p>创建<code>SpringMvcClientBeanPostProcessor</code>，负责元数据的构建和注册，它的构造函数逻辑如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> *  spring mvc 客户端bean的后置处理器</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SpringMvcClientBeanPostProcessor implements BeanPostProcessor {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 通过构造函数进行实例化</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public SpringMvcClientBeanPostProcessor(final PropertiesConfig clientConfig,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                            final ShenyuClientRegisterRepository shenyuClientRegisterRepository) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 读取配置属性</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Properties props = clientConfig.getProps();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 获取端口信息，并校验</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int port = Integer.parseInt(props.getProperty(ShenyuClientConstants.PORT));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (port &lt;= 0) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            String errorMsg = &quot;http register param must config the port must &gt; 0&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            LOG.error(errorMsg);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new ShenyuClientIllegalArgumentException(errorMsg);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 获取appName</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.appName = props.getProperty(ShenyuClientConstants.APP_NAME);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 获取contextPath</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.contextPath = props.getProperty(ShenyuClientConstants.CONTEXT_PATH);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 校验appName和contextPath</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (StringUtils.isBlank(appName) &amp;&amp; StringUtils.isBlank(contextPath)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            String errorMsg = &quot;http register param must config the appName or contextPath&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            LOG.error(errorMsg);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new ShenyuClientIllegalArgumentException(errorMsg);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 获取 isFull</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.isFull = Boolean.parseBoolean(props.getProperty(ShenyuClientConstants.IS_FULL, Boolean.FALSE.toString()));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 开始事件发布</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        publisher.start(shenyuClientRegisterRepository);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 暂时省略了其他逻辑</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object postProcessAfterInitialization(@NonNull final Object bean, @NonNull final String beanName) throws BeansException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     // 暂时省略了其他逻辑</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在构造函数中，主要是读取属性信息，然后进行校验。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI xml"><pre tabindex="0" class="prism-code language-xml codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">shenyu:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  client:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    http:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        props:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          contextPath: /http</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          appName: http</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          port: 8189  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">          isFull: false</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>最后，执行了<code>publisher.start()</code>，开始事件发布，为注册做准备。</p><ul><li>ShenyuClientRegisterEventPublisher</li></ul><p><code>ShenyuClientRegisterEventPublisher</code>通过单例模式实现，主要是生成<code>元数据</code>和<code>URI</code>订阅器（后续用于数据发布），然后启动<code>Disruptor</code>队列。提供了一个共有方法<code>publishEvent()</code>，发布事件，向Disruptor队列发数据。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ShenyuClientRegisterEventPublisher {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 私有变量</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final ShenyuClientRegisterEventPublisher INSTANCE = new ShenyuClientRegisterEventPublisher();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private DisruptorProviderManage providerManage;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private RegisterClientExecutorFactory factory;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 公开静态方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return ShenyuClientRegisterEventPublisher instance</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static ShenyuClientRegisterEventPublisher getInstance() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return INSTANCE;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Start方法执行</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param shenyuClientRegisterRepository shenyuClientRegisterRepository</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void start(final ShenyuClientRegisterRepository shenyuClientRegisterRepository) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建客户端注册工厂类</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        factory = new RegisterClientExecutorFactory();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 添加元数据订阅器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        factory.addSubscribers(new ShenyuClientMetadataExecutorSubscriber(shenyuClientRegisterRepository));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  添加URI订阅器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        factory.addSubscribers(new ShenyuClientURIExecutorSubscriber(shenyuClientRegisterRepository));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 启动Disruptor队列</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        providerManage = new DisruptorProviderManage(factory);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        providerManage.startup();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 发布事件，向Disruptor队列发数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param &lt;T&gt; the type parameter</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param data the data</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public &lt;T&gt; void publishEvent(final T data) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        DisruptorProvider&lt;Object&gt; provider = providerManage.getProvider();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        provider.onData(f -&gt; f.setData(data));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><code>SpringMvcClientBeanPostProcessor</code>的构造函数逻辑分析完了，主要是读取属性配置，创建元数据和<code>URI</code>订阅器， 启动<code>Disruptor</code>队列。要注意到它实现了<code>BeanPostProcessor</code>，这是<code>Spring</code>提供的一个接口，在<code>Bean</code>的生命周期中，真正开始使用之前，会执行后置处理器的<code>postProcessAfterInitialization()</code>方法。</p><ul><li>postProcessAfterInitialization() 方法</li></ul><p><code>SpringMvcClientBeanPostProcessor</code>作为一个后置处理器，它的功能是：读取注解中的元数据，并向<code>admin</code>注册。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// 后置处理器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SpringMvcClientBeanPostProcessor implements BeanPostProcessor {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   // 省略了其他逻辑</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 后置处理器：读取注解中的元数据，并向admin注册</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object postProcessAfterInitialization(@NonNull final Object bean, @NonNull final String beanName) throws BeansException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 配置属性，如果 isFull=true 的话，表示注册整个微服务</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (isFull) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return bean;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 获取当前bean的Controller注解</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Controller controller = AnnotationUtils.findAnnotation(bean.getClass(), Controller.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         // 获取当前bean的RequestMapping注解</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        RequestMapping requestMapping = AnnotationUtils.findAnnotation(bean.getClass(), RequestMapping.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果这个bean是一个接口</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (controller != null || requestMapping != null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">               // 获取当前bean的 ShenyuSpringMvcClient 注解</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            ShenyuSpringMvcClient clazzAnnotation = AnnotationUtils.findAnnotation(bean.getClass(), ShenyuSpringMvcClient.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            String prePath = &quot;&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            //如果没有 ShenyuSpringMvcClient 注解，就返回，表示这个接口不需要注册</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (Objects.isNull(clazzAnnotation)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                return bean;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">             //如果 ShenyuSpringMvcClient 注解中的path属性包括 * ，表示注册整个接口</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (clazzAnnotation.path().indexOf(&quot;*&quot;) &gt; 1) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 构建元数据，发送注册事件</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                publisher.publishEvent(buildMetaDataDTO(clazzAnnotation, prePath));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                return bean;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span></span><span class="token-line" style="color:#393A34"><span class="token plain">            prePath = clazzAnnotation.path();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 获取当前bean的所有方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            final Method[] methods = ReflectionUtils.getUniqueDeclaredMethods(bean.getClass());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 遍历方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (Method method : methods) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 获取当前方法上的注解 ShenyuSpringMvcClient</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                ShenyuSpringMvcClient shenyuSpringMvcClient = AnnotationUtils.findAnnotation(method, ShenyuSpringMvcClient.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 如果方法上有注解ShenyuSpringMvcClient，就表示该方法需要注册</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (Objects.nonNull(shenyuSpringMvcClient)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 构建元数据，发送注册事件</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    publisher.publishEvent(buildMetaDataDTO(shenyuSpringMvcClient, prePath));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return bean;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 构造元数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private MetaDataRegisterDTO buildMetaDataDTO(final ShenyuSpringMvcClient shenyuSpringMvcClient, final String prePath) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // contextPath上下文名称</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String contextPath = this.contextPath;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // appName应用名称</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String appName = this.appName;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // path注册路径</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String path;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (StringUtils.isEmpty(contextPath)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            path = prePath + shenyuSpringMvcClient.path();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            path = contextPath + prePath + shenyuSpringMvcClient.path();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // desc描述信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String desc = shenyuSpringMvcClient.desc();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // ruleName规则名称，没有填写的话就和path一致</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String configRuleName = shenyuSpringMvcClient.ruleName();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String ruleName = StringUtils.isBlank(configRuleName) ? path : configRuleName;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 构建元数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return MetaDataRegisterDTO.builder()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .contextPath(contextPath)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .appName(appName)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .path(path)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .pathDesc(desc)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .rpcType(RpcTypeEnum.HTTP.getName())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .enabled(shenyuSpringMvcClient.enabled())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .ruleName(ruleName)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .registerMetaData(shenyuSpringMvcClient.registerMetaData())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .build();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在后置处理器中，需要读取配置属性，如果 <code>isFull=true</code> 的话，表示注册整个微服务。获取当前<code>bean</code>的<code>Controller</code>注解、<code>RequestMapping</code>注解、<code>ShenyuSpringMvcClient</code> 注解，通过读取这些注解信息判断当前<code>bean</code>是否是接口？接口是否需要注册？方法是否需要注册？然后根据<code>ShenyuSpringMvcClient</code> 注解中的属性构建元数据，最后通过<code>publisher.publishEvent()</code>发布事件进行注册。</p><p><code>Controller</code>注解和<code>RequestMapping</code>注解是由<code>Spring</code>提供的，这个大家应该很熟悉，不过多赘述。<code>ShenyuSpringMvcClient</code> 注解是由<code>Apache ShenYu</code>提供的，用于注册<code>SpringMvc</code>客户端，它的定义如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * shenyu 客户端接口，用于方法上或类上</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Retention(RetentionPolicy.RUNTIME)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Target({ElementType.TYPE, ElementType.METHOD})</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public @interface ShenyuSpringMvcClient {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // path 注册路径</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    String path();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ruleName 规则名称</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    String ruleName() default &quot;&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // desc 描述信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    String desc() default &quot;&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // enabled是否启用</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean enabled() default true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // registerMetaData 注册元数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean  registerMetaData() default false;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>它的使用如下：</p><ul><li>注册整个接口</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@RestController</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@RequestMapping(&quot;/test&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@ShenyuSpringMvcClient(path = &quot;/test/**&quot;)  // 表示整个接口注册</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class HttpTestController {</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> //......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>注册当前方法</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@RestController</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@RequestMapping(&quot;/order&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@ShenyuSpringMvcClient(path = &quot;/order&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class OrderController {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Save order dto.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param orderDTO the order dto</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the order dto</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @PostMapping(&quot;/save&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @ShenyuSpringMvcClient(path = &quot;/save&quot;, desc = &quot;Save order&quot;) // 注册当前方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public OrderDTO save(@RequestBody final OrderDTO orderDTO) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        orderDTO.setName(&quot;hello world save order&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return orderDTO;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>publisher.publishEvent() 发布注册事件</li></ul><p>该方法会将数据发送到<code>Disruptor</code>队列中，关于<code>Disruptor</code>队列更多细节这里不做更多介绍，这不影响分析注册的流程。</p><p>当数据发送后，<code>Disruptor</code>队列的消费者会处理数据，进行消费。</p><ul><li>QueueConsumer 消费数据</li></ul><p><code>QueueConsumer</code>是一个消费者，它实现了<code>WorkHandler</code>接口，它的创建过程在<code>providerManage.startup()</code>逻辑中。<code>WorkHandler</code>接口是<code>disruptor</code>的数据消费接口，只有一个方法是<code>onEvent()</code>。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">package com.lmax.disruptor;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface WorkHandler&lt;T&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    void onEvent(T var1) throws Exception;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><code>QueueConsumer</code>重写了<code>onEvent()</code>方法，主要逻辑是生成消费任务，然后在线程池中去执行。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * </span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 队列消费者</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class QueueConsumer&lt;T&gt; implements WorkHandler&lt;DataEvent&lt;T&gt;&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 省略了其他逻辑</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onEvent(final DataEvent&lt;T&gt; t) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (t != null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 通过工厂创建队列消费任务</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            QueueConsumerExecutor&lt;T&gt; queueConsumerExecutor = factory.create();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 保存数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            queueConsumerExecutor.setData(t.getData());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // help gc</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            t.setData(null);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 放在线程池中执行 消费任务</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            executor.execute(queueConsumerExecutor);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><code>QueueConsumerExecutor</code>是在线程池中被执行的任务，它实现了<code>Runnable</code>接口，具体的实现类有两个：</p><ul><li><code>RegisterClientConsumerExecutor</code>：客户端消费者执行器；</li><li><code>RegisterServerConsumerExecutor</code>：服务端消费者执行器。</li></ul><p>顾名思义，一个负责处理客户端任务，一个负责处理服务端任务（服务端就是<code>admin</code>，在下文进行分析）。</p><p><img src="/zh/assets/images/consumer-executor-f7ad67d35abaa5a2fac94ef913445a19.png"></p><ul><li>RegisterClientConsumerExecutor 消费者执行器</li></ul><p>重写的<code>run()</code>逻辑如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public final class RegisterClientConsumerExecutor extends QueueConsumerExecutor&lt;DataTypeParent&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //...... </span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 获取数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        DataTypeParent dataTypeParent = getData();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 根据数据类型调用相应的处理器进行处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        subscribers.get(dataTypeParent.getType()).executor(Lists.newArrayList(dataTypeParent));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>根据不同的数据类型调用不同的处理器去执行相应的任务。数据类型有两种，一个是元数据，记录客户端注册信息。一个是<code>URI</code>数据，记录客户端服务信息。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">//数据类型</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public enum DataType {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   // 元数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    META_DATA,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">   // URI数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    URI,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>ExecutorSubscriber#executor() 执行器订阅者</li></ul><p>执行器订阅者也分为两类，一个是处理元数据，一个是处理<code>URI</code>。在客户端和服务端分别有两个，所以一共是四个。</p><p><img src="/zh/assets/images/executor-subscriber-86d5645d204ad1d05fe12dd30992c8d1.png"></p><ul><li>ShenyuClientMetadataExecutorSubscriber#executor()</li></ul><p>客户端这边对元数据处理逻辑是：遍历元数据信息，调用接口方法<code>persistInterface()</code>完成数据的发布。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public class ShenyuClientMetadataExecutorSubscriber implements ExecutorTypeSubscriber&lt;MetaDataRegisterDTO&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public DataType getType() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return DataType.META_DATA; // 元数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void executor(final Collection&lt;MetaDataRegisterDTO&gt; metaDataRegisterDTOList) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (MetaDataRegisterDTO metaDataRegisterDTO : metaDataRegisterDTOList) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 调用接口方法persistInterface()完成数据的发布</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            shenyuClientRegisterRepository.persistInterface(metaDataRegisterDTO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>ShenyuClientRegisterRepository#persistInterface()</li></ul><p><code>ShenyuClientRegisterRepository</code>是一个接口，用于表示客户端数据注册，它的实现类目前有五种，每一种就表示一种注册方法。</p><ul><li><code>ConsulClientRegisterRepository</code>：通过<code>Consul</code>实现客户端注册；</li><li><code>EtcdClientRegisterRepository</code>：通过<code>Etcd</code>实现客户端注册；</li><li><code>HttpClientRegisterRepository</code>：通过<code>Http</code>实现客户端注册；</li><li><code>NacosClientRegisterRepository</code>：通过<code>Nacos</code>实现客户端注册；</li><li><code>ZookeeperClientRegisterRepository</code>：通过<code>Zookeeper</code>实现客户端注册；</li></ul><p><img src="/zh/assets/images/client-register-repository-61756e3284c1d3a27083b25d393edf9c.png"></p><p>从图中可以看出，注册中心的加载是通过<code>SPI</code>的方式完成的。这个在前面提到过了，在客户端通用配置文件中，通过指定配置文件中的属性完成具体的类加载。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 加载 ShenyuClientRegisterRepository</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public final class ShenyuClientRegisterRepositoryFactory {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final Map&lt;String, ShenyuClientRegisterRepository&gt; REPOSITORY_MAP = new ConcurrentHashMap&lt;&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 创建 ShenyuClientRegisterRepository</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static ShenyuClientRegisterRepository newInstance(final ShenyuRegisterCenterConfig shenyuRegisterCenterConfig) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!REPOSITORY_MAP.containsKey(shenyuRegisterCenterConfig.getRegisterType())) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 通过SPI的方式进行加载，类型由registerType决定</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            ShenyuClientRegisterRepository result = ExtensionLoader.getExtensionLoader(ShenyuClientRegisterRepository.class).getJoin(shenyuRegisterCenterConfig.getRegisterType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            //执行初始化操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            result.init(shenyuRegisterCenterConfig);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            ShenyuClientShutdownHook.set(result, shenyuRegisterCenterConfig.getProps());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            REPOSITORY_MAP.put(shenyuRegisterCenterConfig.getRegisterType(), result);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return result;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return REPOSITORY_MAP.get(shenyuRegisterCenterConfig.getRegisterType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>本文的源码分析是基于<code>Http</code>的方式进行注册，所以我们先分析<code>HttpClientRegisterRepository</code>，其他的注册方式后续再分析。</p><p>通过<code>http</code>的方式注册很简单，就是调用工具类发送<code>http</code>请求。注册元数据和URI都是调用的同一个方法<code>doRegister()</code>，指定接口和类型就好。</p><ul><li><code>/shenyu-client/register-metadata</code>：服务端提供的接口用于注册元数据。</li><li><code>/shenyu-client/register-uri</code>：    服务端提供的接口用于注册URI。</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Join</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class HttpClientRegisterRepository implements ShenyuClientRegisterRepository {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 服务端提供的接口用于注册元数据    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final String META_PATH = &quot;/shenyu-client/register-metadata&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 服务端提供的接口用于注册URI</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final String URI_PATH = &quot;/shenyu-client/register-uri&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //注册URI</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void persistURI(final URIRegisterDTO registerDTO) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        doRegister(registerDTO, URI_PATH, Constants.URI);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //注册接口（就是元数据信息）</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void persistInterface(final MetaDataRegisterDTO metadata) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        doRegister(metadata, META_PATH, META_TYPE);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 进行注册</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private &lt;T&gt; void doRegister(final T t, final String path, final String type) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 遍历admin服务列表（admin可能是集群）</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (String server : serverList) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 调用工具类发送 http 请求</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                RegisterUtils.doRegister(GsonUtils.getInstance().toJson(t), server + path, type);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                return;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (Exception e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                LOGGER.error(&quot;register admin url :{} is fail, will retry&quot;, server);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>将数据序列化后，通过<code>OkHttp</code>发送数据。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public final class RegisterUtils {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span></span><span class="token-line" style="color:#393A34"><span class="token plain">   //...... </span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 通过OkHttp发送数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void doRegister(final String json, final String url, final String type) throws IOException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String result = OkHttpTools.getInstance().post(url, json);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (Objects.equals(SUCCESS, result)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            LOGGER.info(&quot;{} client register success: {} &quot;, type, json);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            LOGGER.error(&quot;{} client register error: {} &quot;, type, json);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>至此，客户端通过<code>http</code>的方式注册元数据的逻辑就分析完了。小结一下：通过读取自定义的注解信息构造元数据，将数据发到<code>Disruptor</code>队列，然后从队列中消费数据，将消费者放到线程池中去执行，最终通过发送<code>http</code>请求到<code>admin</code>。</p><p>客户端元数据注册流程的源码分析过程完成了，用流程图描述如下：</p><p><img src="/zh/assets/images/client-metadata-register-zh-340085d19f3b7ec9abf77a9d1243493c.png"></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="24--构建-uri-的-contextregisterlistener"></a>2.4  构建 URI 的 ContextRegisterListener<a class="hash-link" href="#24--构建-uri-的-contextregisterlistener" title="Direct link to heading">#</a></h4><p>创建 <code>ContextRegisterListener</code>，负责客户端<code>URI</code>数据的构建和注册，它的创建是在配置文件中完成。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Configuration</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@ImportAutoConfiguration(ShenyuClientCommonBeanConfiguration.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ShenyuSpringMvcClientConfiguration {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     // ......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //  创建 ContextRegisterListener</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ContextRegisterListener contextRegisterListener(final ShenyuClientConfig clientConfig) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new ContextRegisterListener(clientConfig.getClient().get(RpcTypeEnum.HTTP.getName()));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><code>ContextRegisterListener</code>实现了<code>ApplicationListener</code>接口，并重写了<code>onApplicationEvent()</code>方法，当有Spring事件发生后，该方法会执行。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// 实现了ApplicationListener接口</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ContextRegisterListener implements ApplicationListener&lt;ContextRefreshedEvent&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     //......</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //通过构造函数完成实例化</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ContextRegisterListener(final PropertiesConfig clientConfig) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 读取 shenyu.client.http 配置信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Properties props = clientConfig.getProps();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // isFull是否注册整个服务</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.isFull = Boolean.parseBoolean(props.getProperty(ShenyuClientConstants.IS_FULL, Boolean.FALSE.toString()));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // contextPath上下文路径</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String contextPath = props.getProperty(ShenyuClientConstants.CONTEXT_PATH);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.contextPath = contextPath;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (isFull) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (StringUtils.isBlank(contextPath)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                String errorMsg = &quot;http register param must config the contextPath&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                LOG.error(errorMsg);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw new ShenyuClientIllegalArgumentException(errorMsg);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.contextPath = contextPath + &quot;/**&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // port 客户端端口信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int port = Integer.parseInt(props.getProperty(ShenyuClientConstants.PORT));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // appName 应用名称</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.appName = props.getProperty(ShenyuClientConstants.APP_NAME);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // host信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.host = props.getProperty(ShenyuClientConstants.HOST);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.port = port;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 当有上下文刷新事件ContextRefreshedEvent发生时，该方法会执行</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onApplicationEvent(@NonNull final ContextRefreshedEvent contextRefreshedEvent) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //保证该方法的内容只执行一次</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!registered.compareAndSet(false, true)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果是 isFull=true 代表注册整个服务，构建元数据并注册</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (isFull) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            publisher.publishEvent(buildMetaDataDTO());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 构建URI数据并注册</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        publisher.publishEvent(buildURIRegisterDTO());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 构建URI数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private URIRegisterDTO buildURIRegisterDTO() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String host = IpUtils.isCompleteHost(this.host) ? this.host : IpUtils.getHost(this.host);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return URIRegisterDTO.builder()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .contextPath(this.contextPath)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .appName(appName)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .host(host)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .port(port)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .rpcType(RpcTypeEnum.HTTP.getName())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .build();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 构建元数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private MetaDataRegisterDTO buildMetaDataDTO() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String contextPath = this.contextPath;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String appName = this.appName;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return MetaDataRegisterDTO.builder()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .contextPath(contextPath)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .appName(appName)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .path(contextPath)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .rpcType(RpcTypeEnum.HTTP.getName())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .enabled(true)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .ruleName(contextPath)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .build();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在构造函数中主要是读取属性配置。</p><p><code>onApplicationEvent()</code>方法是有<code>Spring</code>事件发生时会执行，这里的参数是<code>ContextRefreshedEvent</code>，表示上下文刷新事件。当<code>Spring</code>容器就绪后执行此处逻辑：如果是 <code>isFull=true</code> 代表注册整个服务，构建元数据并注册，在前面分析的后置处理器<code>SpringMvcClientBeanPostProcessor</code>中没有处理 <code>isFull=true</code> 的情况，所以在此处进行了处理。然后再构建<code>URI</code>数据并注册。</p><blockquote><p><code>ContextRefreshedEvent</code>是<code>Spring</code>内置事件。<code>ApplicationContext</code>被初始化或刷新时，该事件被触发。这也可以在 <code>ConfigurableApplicationContext</code>接口中使用 <code>refresh()</code> 方法来发生。此处的初始化是指：所有的<code>Bean</code>被成功装载，后处理<code>Bean</code>被检测并激活，所有<code>Singleton Bean</code> 被预实例化，<code>ApplicationContext</code>容器已就绪可用。</p></blockquote><p>注册逻辑都是通过 <code>publisher.publishEvent()</code>完成。在前面都已经分析过了：向<code>Disruptor</code>队列写入数据，再从中消费数据，最后通过<code>ExecutorSubscriber</code>去处理。</p><ul><li>ExecutorSubscriber#executor()</li></ul><p>执行器订阅者分为两类，一个是处理元数据，一个是处理<code>URI</code>。在客户端和服务端分别有两个，所以一共是四个。</p><p><img src="/zh/assets/images/executor-subscriber-86d5645d204ad1d05fe12dd30992c8d1.png"></p><p>这里是注册<code>URI</code>信息，所以执行类是<code>ShenyuClientURIExecutorSubscriber</code>。</p><ul><li>ShenyuClientURIExecutorSubscriber#executor()</li></ul><p>主要逻辑是遍历URI数据集合，通过<code>persistURI()</code>方法实现数据注册。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ShenyuClientURIExecutorSubscriber implements ExecutorTypeSubscriber&lt;URIRegisterDTO&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public DataType getType() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return DataType.URI; //数据类型是URI</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 注册URI数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void executor(final Collection&lt;URIRegisterDTO&gt; dataList) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (URIRegisterDTO uriRegisterDTO : dataList) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            Stopwatch stopwatch = Stopwatch.createStarted();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (true) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                try (Socket ignored = new Socket(uriRegisterDTO.getHost(), uriRegisterDTO.getPort())) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (IOException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    long sleepTime = 1000;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // maybe the port is delay exposed</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (stopwatch.elapsed(TimeUnit.SECONDS) &gt; 5) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        LOG.error(&quot;host:{}, port:{} connection failed, will retry&quot;,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                uriRegisterDTO.getHost(), uriRegisterDTO.getPort());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // If the connection fails for a long time, Increase sleep time</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if (stopwatch.elapsed(TimeUnit.SECONDS) &gt; 180) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            sleepTime = 10000;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        TimeUnit.MILLISECONDS.sleep(sleepTime);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } catch (InterruptedException ex) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ex.printStackTrace();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            //添加hook，优雅停止客户端 </span></span><span class="token-line" style="color:#393A34"><span class="token plain">            ShenyuClientShutdownHook.delayOtherHooks();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 注册URI</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            shenyuClientRegisterRepository.persistURI(uriRegisterDTO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>代码中的<code>while(true)</code>循环是为了保证客户端已经成功启动了，通过<code>host</code>和<code>port</code>可以连接上。</p><p>后面的逻辑是：添加<code>hook</code>函数，用于优雅停止客户端 。</p><p>通过<code>persistURI()</code>方法实现数据注册。整个逻辑也在前面分析过了，最终就是通过<code>OkHttp</code>客户端向<code>shenyu-admin</code>发起<code>http</code>，通过<code>http</code>的方式注册<code>URI</code>。</p><p>分析到这里就将客户端的注册逻辑分析完了，将构建的元数据和URI数据发送到<code>Disruptor</code>队列，再从中消费，读取数据，通过<code>http</code>向<code>admin</code>发送数据。</p><p>客户端<code>URI</code>注册流程的源码分析完成了，流程图如下：</p><p><img src="/zh/assets/images/client-uri-register-zh-3e41a54eeec666edb6ad8e16d7354d0d.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="3-服务端注册流程"></a>3. 服务端注册流程<a class="hash-link" href="#3-服务端注册流程" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="31-注册接口shenyuhttpregistrycontroller"></a>3.1 注册接口ShenyuHttpRegistryController<a class="hash-link" href="#31-注册接口shenyuhttpregistrycontroller" title="Direct link to heading">#</a></h4><p>从前面的分析可以知道，服务端提供了注册的两个接口：</p><ul><li><code>/shenyu-client/register-metadata</code>：服务端提供的接口用于注册元数据。</li><li><code>/shenyu-client/register-uri</code>：    服务端提供的接口用于注册URI。</li></ul><p>这两个接口位于<code>ShenyuHttpRegistryController</code>中，它实现了<code>ShenyuServerRegisterRepository</code>接口，是服务端注册的实现类。它用<code>@Join</code>标记，表示通过<code>SPI</code>进行加载。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// shenuyu客户端接口</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@RequestMapping(&quot;/shenyu-client&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Join</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ShenyuHttpRegistryController implements ShenyuServerRegisterRepository {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private ShenyuServerRegisterPublisher publisher;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void init(final ShenyuServerRegisterPublisher publisher, final ShenyuRegisterCenterConfig config) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.publisher = publisher;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 注册元数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @PostMapping(&quot;/register-metadata&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @ResponseBody</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String registerMetadata(@RequestBody final MetaDataRegisterDTO metaDataRegisterDTO) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        publish(metaDataRegisterDTO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ShenyuResultMessage.SUCCESS;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span></span><span class="token-line" style="color:#393A34"><span class="token plain">   // 注册URI</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @PostMapping(&quot;/register-uri&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @ResponseBody</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String registerURI(@RequestBody final URIRegisterDTO uriRegisterDTO) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        publish(uriRegisterDTO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ShenyuResultMessage.SUCCESS;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 发布注册事件</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private &lt;T&gt; void publish(final T t) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        publisher.publish(Collections.singletonList(t));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>两个注册接口获取到数据好，就调用了<code>publish()</code>方法，把数据发布到<code>Disruptor</code>队列中。</p><ul><li><code>ShenyuServerRegisterRepository</code>接口</li></ul><p><code>ShenyuServerRegisterRepository</code>接口是服务注册接口，它有五个实现类，表示有五种注册方式：</p><ul><li><code>ConsulServerRegisterRepository</code>：通过<code>Consul</code>实现注册;</li><li><code>EtcdServerRegisterRepository</code>：通过<code>Etcd</code>实现注册；</li><li><code>NacosServerRegisterRepository</code>：通过<code>Nacos</code>实现注册；</li><li><code>ShenyuHttpRegistryController</code>：通过<code>Http</code>实现注册；</li><li><code>ZookeeperServerRegisterRepository</code>：通过<code>Zookeeper</code>实现注册。</li></ul><p>具体用哪一种方式，是通过配置文件指定的，然后通过<code>SPI</code>进行加载。</p><p>在<code>shenyu-admin</code>中的<code>application.yml</code>文件中配置注册方式，<code>registerType</code>指定注册类型，当用<code>http</code>进行注册时，<code>serverLists</code>不需要填写，更多配置说明可以参考官网  <a href="https://shenyu.apache.org/zh/docs/user-guide/register-center-access" target="_blank" rel="noopener noreferrer">客户端接入配置</a> 。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">shenyu:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  register:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    registerType: http </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    serverLists: </span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>RegisterCenterConfiguration 加载配置</li></ul><p>在引入相关依赖和属性配置后，启动<code>shenyu-admin</code>时，会先加载配置文件，和注册中心相关的配置文件类是<code>RegisterCenterConfiguration</code>。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// 注册中心配置类</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Configuration</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class RegisterCenterConfiguration {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 读取配置属性</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @ConfigurationProperties(prefix = &quot;shenyu.register&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ShenyuRegisterCenterConfig shenyuRegisterCenterConfig() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new ShenyuRegisterCenterConfig();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //创建ShenyuServerRegisterRepository，用于服务端注册</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ShenyuServerRegisterRepository shenyuServerRegisterRepository(final ShenyuRegisterCenterConfig shenyuRegisterCenterConfig, final List&lt;ShenyuClientRegisterService&gt; shenyuClientRegisterService) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 1.从配置属性中获取注册类型</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String registerType = shenyuRegisterCenterConfig.getRegisterType();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 2.通过注册类型，以SPI的方法加载实现类</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ShenyuServerRegisterRepository registerRepository = ExtensionLoader.getExtensionLoader(ShenyuServerRegisterRepository.class).getJoin(registerType);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 3.获取publisher，向Disruptor队列中写数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        RegisterServerDisruptorPublisher publisher = RegisterServerDisruptorPublisher.getInstance();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 4.注册Service， rpcType -&gt; registerService</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Map&lt;String, ShenyuClientRegisterService&gt; registerServiceMap = shenyuClientRegisterService.stream().collect(Collectors.toMap(ShenyuClientRegisterService::rpcType, e -&gt; e));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 5.事件发布的准备工作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        publisher.start(registerServiceMap);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 6.注册的初始化操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        registerRepository.init(publisher, shenyuRegisterCenterConfig);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return registerRepository;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在配置类中生成了两个<code>bean</code>：</p><ul><li><p><code>shenyuRegisterCenterConfig</code>：读取属性配置；</p></li><li><p><code>shenyuServerRegisterRepository</code>：用于服务端注册。</p></li></ul><p>在创建<code>shenyuServerRegisterRepository</code>的过程中，也进行了一系列的准备工作：</p><ul><li>1.从配置属性中获取注册类型。</li><li>2.通过注册类型，以<code>SPI</code>的方法加载实现类：比如指定的类型是<code>http</code>，就会加载<code>ShenyuHttpRegistryController</code>。</li><li>3.获取<code>publisher</code>，向<code>Disruptor</code>队列中写数据。</li><li>4.注册<code>Service</code>， <code>rpcType -&gt; registerService</code>：获取注册的<code>Service</code>，每种<code>rpc</code>都有对应的<code>Service</code>。本文的客户端构建是通过<code>springboot</code>，属于<code>http</code>类型，还有其他客户端类型：<code>dubbo</code>，<code>Spring Cloud</code>，<code>gRPC</code>等。</li><li>5.事件发布的准备工作：添加服务端元数据和<code>URI</code>订阅器，处理数据。并且启动<code>Disruptor</code>队列。</li><li>6.注册的初始化操作：<code>http</code>类型的注册初始化操作就是保存<code>publisher</code>。</li></ul><ul><li>RegisterServerDisruptorPublisher#publish()</li></ul><p>服务端向<code>Disruptor</code>队列写入数据的发布者 ，通过单例模式构建。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class RegisterServerDisruptorPublisher implements ShenyuServerRegisterPublisher {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //私有属性</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final RegisterServerDisruptorPublisher INSTANCE = new RegisterServerDisruptorPublisher();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //公开静态方法获取实例</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static RegisterServerDisruptorPublisher getInstance() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return INSTANCE;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">   //事件发布的准备工作，添加服务端元数据和URI订阅器，处理数据。并且启动Disruptor队列。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void start(final Map&lt;String, ShenyuClientRegisterService&gt; shenyuClientRegisterService) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //服务端注册工厂</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        factory = new RegisterServerExecutorFactory();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //添加URI数据订阅器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        factory.addSubscribers(new URIRegisterExecutorSubscriber(shenyuClientRegisterService));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //添加元数据订阅器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        factory.addSubscribers(new MetadataExecutorSubscriber(shenyuClientRegisterService));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //启动Disruptor队列</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        providerManage = new DisruptorProviderManage(factory);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        providerManage.startup();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 向队列中写入数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public &lt;T&gt; void publish(final T data) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        DisruptorProvider&lt;Object&gt; provider = providerManage.getProvider();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        provider.onData(f -&gt; f.setData(data));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void close() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        providerManage.getProvider().shutdown();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>配置文件的加载，可看作是注册中心服务端初始化流程，用图描述如下：</p><p><img src="/zh/assets/images/server-register-init-zh-f459729f048f19f89b7eaa023ae4b4e8.png"></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="32-消费数据queueconsumer"></a>3.2 消费数据QueueConsumer<a class="hash-link" href="#32-消费数据queueconsumer" title="Direct link to heading">#</a></h4><p>在前面分析了客户端<code>disruptor</code>队列消费数据的过。服务端也是一样的逻辑，只是其中执行任务的执行者变了。</p><p><code>QueueConsumer</code>是一个消费者，它实现了<code>WorkHandler</code>接口，它的创建过程在<code>providerManage.startup()</code>逻辑中。<code>WorkHandler</code>接口是<code>disruptor</code>的数据消费接口，只有一个方法是<code>onEvent()</code>。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">package com.lmax.disruptor;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface WorkHandler&lt;T&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    void onEvent(T var1) throws Exception;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><code>QueueConsumer</code>重写了<code>onEvent()</code>方法，主要逻辑是生成消费任务，然后在线程池中去执行。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * </span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 队列消费者</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class QueueConsumer&lt;T&gt; implements WorkHandler&lt;DataEvent&lt;T&gt;&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 省略了其他逻辑</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onEvent(final DataEvent&lt;T&gt; t) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (t != null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 通过工厂创建队列消费任务</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            QueueConsumerExecutor&lt;T&gt; queueConsumerExecutor = factory.create();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 保存数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            queueConsumerExecutor.setData(t.getData());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // help gc</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            t.setData(null);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 放在线程池中执行 消费任务</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            executor.execute(queueConsumerExecutor);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><code>QueueConsumerExecutor</code>是在线程池中被执行的任务，它实现了<code>Runnable</code>接口，具体的实现类有两个：</p><ul><li><code>RegisterClientConsumerExecutor</code>：客户端消费者执行器；</li><li><code>RegisterServerConsumerExecutor</code>：服务端消费者执行器。</li></ul><p>顾名思义，一个负责处理客户端任务，一个负责处理服务端任务。</p><ul><li><code>RegisterServerConsumerExecutor#run()</code></li></ul><p><code>RegisterServerConsumerExecutor</code>是服务端消费者执行器，它通过<code>QueueConsumerExecutor</code>间接实现了<code>Runnable</code>接口，并重写了<code>run()</code>方法。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public final class RegisterServerConsumerExecutor extends QueueConsumerExecutor&lt;List&lt;DataTypeParent&gt;&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   // ...</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //获取从disruptor队列中拿到的数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;DataTypeParent&gt; results = getData();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 数据校验</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        results = results.stream().filter(data -&gt; isValidData(data)).collect(Collectors.toList());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (CollectionUtils.isEmpty(results)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //根据类型执行操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        getType(results).executor(results);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 根据类型获取订阅者</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private ExecutorSubscriber getType(final List&lt;DataTypeParent&gt; list) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        DataTypeParent result = list.get(0);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return subscribers.get(result.getType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>ExecutorSubscriber#executor()</li></ul><p>执行器订阅者分为两类，一个是处理元数据，一个是处理<code>URI</code>。在客户端和服务端分别有两个，所以一共是四个。</p><p><img src="/zh/assets/images/executor-subscriber-86d5645d204ad1d05fe12dd30992c8d1.png"></p><ul><li>MetadataExecutorSubscriber#executor()</li></ul><p>如果是注册元数据，则通过<code>MetadataExecutorSubscriber#executor()</code>实现：根据类型获取注册<code>Service</code>，调用<code>register()</code>。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public class MetadataExecutorSubscriber implements ExecutorTypeSubscriber&lt;MetaDataRegisterDTO&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //......</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public DataType getType() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return DataType.META_DATA;  // 元数据类型</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void executor(final Collection&lt;MetaDataRegisterDTO&gt; metaDataRegisterDTOList) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 遍历元数据列表</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (MetaDataRegisterDTO metaDataRegisterDTO : metaDataRegisterDTOList) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 根据类型获取注册Service</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            ShenyuClientRegisterService shenyuClientRegisterService = this.shenyuClientRegisterService.get(metaDataRegisterDTO.getRpcType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            Objects.requireNonNull(shenyuClientRegisterService);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 对元数据进行注册，加锁确保顺序执行，防止并发错误</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            synchronized (ShenyuClientRegisterService.class) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                shenyuClientRegisterService.register(metaDataRegisterDTO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>URIRegisterExecutorSubscriber#executor()</li></ul><p>如果是注册元数据，则通过<code>URIRegisterExecutorSubscriber#executor()</code>实现：构建<code>URI</code>数据，根据注册类型查找<code>Service，</code>通过<code>registerURI</code>方法实现注册。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class URIRegisterExecutorSubscriber implements ExecutorTypeSubscriber&lt;URIRegisterDTO&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public DataType getType() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return DataType.URI; // URI数据类型</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void executor(final Collection&lt;URIRegisterDTO&gt; dataList) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (CollectionUtils.isEmpty(dataList)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 构建URI数据类型，通过registerURI方法实现注册</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        findService(dataList).ifPresent(service -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            Map&lt;String, List&lt;URIRegisterDTO&gt;&gt; listMap = buildData(dataList);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            listMap.forEach(service::registerURI);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 根据类型查找Service</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Optional&lt;ShenyuClientRegisterService&gt; findService(final Collection&lt;URIRegisterDTO&gt; dataList) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return dataList.stream().map(dto -&gt; shenyuClientRegisterService.get(dto.getRpcType())).findFirst();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>ShenyuClientRegisterService#register()</li></ul><p><code>ShenyuClientRegisterService</code>是注册方法接口，它有多个实现类：</p><p><img src="/zh/assets/images/client-register-service-5dff35d87a76f01373cdd702d1217b3b.png"></p><ul><li><code>AbstractContextPathRegisterService</code>：抽象类，处理部分公共逻辑；</li><li><code>AbstractShenyuClientRegisterServiceImpl</code>：：抽象类，处理部分公共逻辑；</li><li><code>ShenyuClientRegisterDivideServiceImpl</code>：<code>divide</code>类，处理<code>http</code>注册类型；</li><li><code>ShenyuClientRegisterDubboServiceImpl</code>：<code>dubbo</code>类，处理<code>dubbo</code>注册类型；</li><li><code>ShenyuClientRegisterGrpcServiceImpl</code>：<code>gRPC</code>类，处理<code>gRPC</code>注册类型；</li><li><code>ShenyuClientRegisterMotanServiceImpl</code>：<code>Motan</code>类，处理<code>Motan</code>注册类型；</li><li><code>ShenyuClientRegisterSofaServiceImpl</code>：<code>Sofa</code>类，处理<code>Sofa</code>注册类型；</li><li><code>ShenyuClientRegisterSpringCloudServiceImpl</code>：<code>SpringCloud</code>类，处理<code>SpringCloud</code>注册类型；</li><li><code>ShenyuClientRegisterTarsServiceImpl</code>：<code>Tars</code>类，处理<code>Tars</code>注册类型；</li></ul><p>从上面可以看出每种微服务都有对应的注册实现类，本文的源码分析是 以官方提供的 <a href="https://github.com/apache/incubator-shenyu/tree/master/shenyu-examples/shenyu-examples-http" target="_blank" rel="noopener noreferrer">shenyu-examples-http</a> 为例，是属<code>http</code>注册类型，所以元数据和URI数据的注册实现类是 <code>ShenyuClientRegisterDivideServiceImpl</code>：</p><ul><li>register(): 注册元数据</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public String register(final MetaDataRegisterDTO dto) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 1.注册选择器信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String selectorHandler = selectorHandler(dto);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String selectorId = selectorService.registerDefault(dto, PluginNameAdapter.rpcTypeAdapter(rpcType()), selectorHandler);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 2.注册规则信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String ruleHandler = ruleHandler();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        RuleDTO ruleDTO = buildRpcDefaultRuleDTO(selectorId, dto, ruleHandler);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ruleService.registerDefault(ruleDTO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 3.注册元数据信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        registerMetadata(dto);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 4.注册contextPath</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String contextPath = dto.getContextPath();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (StringUtils.isNotEmpty(contextPath)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            registerContextPath(dto);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ShenyuResultMessage.SUCCESS;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>整个注册逻辑可以分为4个步骤：</p><ul><li>1.注册选择器信息</li><li>2.注册规则信息</li><li>3.注册元数据信息</li><li>4.注册<code>contextPath</code></li></ul><p>在<code>admin</code>这一侧通过客户端的元数据信息需要构建选择器、规则、元数据和<code>ContextPath</code>。具体的注册过程和细节处理跟<code>rpc</code>类型有关。我们就不再继续向下追踪了，对于注册中心的逻辑分析，跟踪到这里就够了。</p><p>服务端元数据注册流程的源码分析完了，流程图描述如下：</p><p><img src="/zh/assets/images/server-metadata-register-zh-1b1d9d30b0f3c8fedc59d9a82ab24896.png"></p><ul><li>registerURI(): 注册<code>URI</code>数据</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public String registerURI(final String selectorName, final List&lt;URIRegisterDTO&gt; uriList) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (CollectionUtils.isEmpty(uriList)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return &quot;&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 对应的选择器是否存在</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        SelectorDO selectorDO = selectorService.findByNameAndPluginName(selectorName, PluginNameAdapter.rpcTypeAdapter(rpcType()));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (Objects.isNull(selectorDO)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return &quot;&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 处理选择器中的handler信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String handler = buildHandle(uriList, selectorDO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        selectorDO.setHandle(handler);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        SelectorData selectorData = selectorService.buildByName(selectorName, PluginNameAdapter.rpcTypeAdapter(rpcType()));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        selectorData.setHandle(handler);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">       </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 更新数据库中的记录</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        selectorService.updateSelective(selectorDO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 发布事件</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.SELECTOR, DataEventTypeEnum.UPDATE, Collections.singletonList(selectorData)));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ShenyuResultMessage.SUCCESS;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><code>admin</code>拿到<code>URI</code>数据后，主要是更新选择器中的<code>handler</code>信息，然后写入到数据库，最后发布事件通知网关。通知网关的逻辑是由数据同步操作完成，这在之前的文章中已经分析过了，就不再赘述。</p><p>服务端<code>URI</code>注册流程的源码分析完成了，用图描述如下：</p><p><img src="/zh/assets/images/server-uri-register-zh-4d956ca81d252f021f22e8a28d15bf2d.png"></p><p>至此，服务端注册流程也就分析完了，主要通过对外提供的接口，接受客户端的注册信息，然后写入到<code>Disruptor</code>队列，再从中消费数据，根据接收到的元数据和<code>URI</code>数据更新<code>admin</code>的选择器、规则、元数据和选择器的<code>handler</code>。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="4-总结"></a>4. 总结<a class="hash-link" href="#4-总结" title="Direct link to heading">#</a></h3><p>本文主要对<code>Apache ShenYu</code>网关中的<code>http注册</code>模块进行了源码分析。涉及到的主要知识点，归纳如下：</p><ul><li>注册中心是为了将客户端信息注册到<code>admin</code>，方便流量筛选；</li><li><code>http</code>注册是将客户端元数据信息和<code>URI</code>信息注册到<code>admin</code>；</li><li><code>http</code>服务的接入通过注解<code>@ShenyuSpringMvcClient</code>标识；</li><li>注册信息的构建主要通过<code>Spring</code>的后置处理器<code>BeanPostProcessor</code>和应用监听器<code>ApplicationListener</code>；</li><li>注册类型的加载通过<code>SPI</code>完成；</li><li>引入<code>Disruptor</code>队列是为了数据与操作解耦，以及数据缓冲。</li><li>注册中心的实现采用了面向接口编程，使用模板方法、单例、观察者等设计模式。</li></ul></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><a class="margin-horiz--sm" href="/zh/blog/tags/http">http</a><a class="margin-horiz--sm" href="/zh/blog/tags/register-center">register center</a><a class="margin-horiz--sm" href="/zh/blog/tags/apache-shen-yu">Apache ShenYu</a></div></footer></article><article class="margin-bottom--xl"><header><h2 class="blogPostTitle_d4p0"><a href="/zh/blog/SPI-SourceCode-Analysis-LoadBalance-SPI">LoadBalance SPI 代码分析</a></h2><div class="blogPostData_-Im+ margin-vert--md"><time datetime="2021-12-14T03:31:25.749Z">2021年12月14日</time> · One min read</div><div class="avatar margin-vert--md"><div class="avatar__intro"><div class="avatar__name"><a href="https://github.com/changanjennifer/" target="_blank" rel="noopener noreferrer">Huihui Yin</a></div><small class="avatar__subtitle">Apache ShenYu Contributor</small></div></div></header><div class="markdown"><p>​        网关应用需要支持多种负载均衡的方案，包括随机选择、Hash、轮询等方式。<code>Apache Shenyu</code>网关中不仅实现了传统网关的这些均衡策略，还通过流量预热(warmup)等细节处理，对服务器节点的加入，做了更平滑的流量处理，获得了更好的整体稳定性。让我们来看看Shenyu是是如何设计和实现这部分功能的。</p><blockquote><p>本文基于<code>shenyu-2.4.0</code>版本进行源码分析.</p></blockquote><p>[TOC]</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="loadbalance-spi"></a>LoadBalance <code>SPI</code><a class="hash-link" href="#loadbalance-spi" title="Direct link to heading">#</a></h2><p><code>LoadBalance</code> SPI 定义在<strong><em>shenyu-plugin-divide</em></strong>模组中，以下是这个核心接口的代码，这个接口很好的诠释了这样一个理念：负载均衡是在一系列服务器节点中选出最合适的节点，也就是选择策略。做流量转发、路由和负载均衡是<code>LoadBalance SPI</code>的基本功能</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@SPI</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface LoadBalance {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param upstreamList upstream list</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param ip ip</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return divide upstream</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    DivideUpstream select(List&lt;DivideUpstream&gt; upstreamList, String ip);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>接口中，upstreamList是可选路由的一组服务器节点，<code>DivideUpstream</code>  是服务器节点的数据结构，它包括的重要元素有：协议、upstreamUrl 、权重、时间戳，warmup等。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public class DivideUpstream implements Serializable {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String upstreamHost;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * this is http protocol.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String protocol;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String upstreamUrl;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int weight;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * false close/ true open.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Builder.Default</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private boolean status = true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private long timestamp;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int warmup;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="design-of-loadbalance-module"></a>Design of LoadBalance module<a class="hash-link" href="#design-of-loadbalance-module" title="Direct link to heading">#</a></h2><p>图1是<code>LoadBalance</code>模组的类图：</p><p><img alt="loadbalance-class-diagram" src="/zh/assets/images/loadbalance-class-diagram-9bfc1b2f9cb359702481d7f739ae21f7.png"></p><p>从类图上可以看出<code>LoadBalance</code>的设计概要：</p><ol><li><p>抽象类<code>AbstractLoadBalance</code>继承自<code>LoadBalance</code> SPI接口，并提供选择的模板方法，及权重计算。</p></li><li><p>三个实做类继承<code>AbstractLoadBalance</code>， 实现各自的逻辑处理。</p><ul><li><code>RandomLoadBalance</code> -加权随机选择 Weight Random</li><li><code>HashLoadBalance</code>  - 一致性Hash</li><li><code>RoundRobinLoadBalance</code> -加权轮询（Weight Round Robin per-packet)</li></ul></li><li><p>由Util类<code>LoadBalanceUtil</code> 实现对外的静态调用方法。</p><p>另外根据<code>Apache Sheny SPI</code>规范，在<code>SHENYU_DIERECTORY</code>中的添加profile，配置<code>LoadBalance</code>的实现类，配置key=class形式，左边的operator要和<code>LoadBalanceEnum</code>中的定义一致。</p></li></ol><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI properties"><pre tabindex="0" class="prism-code language-properties codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">random=org.apache.shenyu.plugin.divide.balance.spi.RandomLoadBalance</span></span><span class="token-line" style="color:#393A34"><span class="token plain">roundRobin=org.apache.shenyu.plugin.divide.balance.spi.RoundRobinLoadBalance</span></span><span class="token-line" style="color:#393A34"><span class="token plain">hash=org.apache.shenyu.plugin.divide.balance.spi.HashLoadBalance</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><code>LoadBalanceEnum</code>的定义如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public enum LoadBalanceEnum {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Hash load balance enum.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    HASH(1, &quot;hash&quot;, true),</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Random load balance enum.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    RANDOM(2, &quot;random&quot;, true),</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Round robin load balance enum.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ROUND_ROBIN(3, &quot;roundRobin&quot;, true);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final int code;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final String name;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final boolean support;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="abstractloadbalance"></a>AbstractLoadBalance<a class="hash-link" href="#abstractloadbalance" title="Direct link to heading">#</a></h2><p>这个抽象类实做了<code>LoadBalance</code>接口, 定义了抽象方法<code>doSelect()</code>留给实作类处理，在模板方法<code>select()</code> 中先进行校验，之后调用由实作类实现的<code>doSelect()</code>方法。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">   /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Do select divide upstream.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param upstreamList the upstream list</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param ip           the ip</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the divide upstream</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected abstract DivideUpstream doSelect(List&lt;DivideUpstream&gt; upstreamList, String ip);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public DivideUpstream select(final List&lt;DivideUpstream&gt; upstreamList, final String ip) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (CollectionUtils.isEmpty(upstreamList)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (upstreamList.size() == 1) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return upstreamList.get(0);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return doSelect(upstreamList, ip);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>权重的处理方法<code>getWeight()</code>的逻辑是：当有时间戳，并且当前时间与时间戳间隔在流量预热warmup时间内，权重计算的公式为：
$$ {1-1}
ww = min(1,uptime/(warmup/weight))
$$
从公式可以看出，最终的权值，与设置的weigth成正比，时间间隔越接近warmup时间，权重就越大。也就是说等待的时间越长，被分派的权重越高。没有时间戳时等其他情况下，返回<code>DivideUpstream</code>设置的<code>weight</code>值。</p><p>考虑流量预热(warmup)的核心思想是避免在添加新服务器和启动新JVM时网关性能不佳。</p><p>下面我们看一下三个实做类的实现。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="randomloadbalance"></a>RandomLoadBalance<a class="hash-link" href="#randomloadbalance" title="Direct link to heading">#</a></h2><p>这里随机<code>LoadBalance</code> 可以处理两种情况：</p><ol><li>没有权重：所有服务器都没有设定权重，或者权重都一样， 会随机选择一个。</li><li>有权重：服务器设定有不同的权重，会根据权重，进行随机选择。</li></ol><p>下面是有权重时的随机选择代码<code>random()</code>： 遍历服务器列表，当产生的随机值小于某个服务器权重时，这个服务器被选中。 若遍历后没有满足条件，就返回服务器列表的第一个。这里<code>getWeight(DivideUpstream upstream)</code> 方法是在<code>AbstractLoadBalance</code> 中定义的，按公式计算权重。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    private DivideUpstream random(final int totalWeight, final List&lt;DivideUpstream&gt; upstreamList) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // If the weights are not the same and the weights are greater than 0, then random by the total number of weights</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int offset = RANDOM.nextInt(totalWeight);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Determine which segment the random value falls on</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (DivideUpstream divideUpstream : upstreamList) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            offset -= getWeight(divideUpstream);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (offset &lt; 0) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                return divideUpstream;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return upstreamList.get(0);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>因此，当采用<code>RandomLoadBalance</code>时，是按权重随机分派服务器的。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="hashloadbalance"></a>HashLoadBalance<a class="hash-link" href="#hashloadbalance" title="Direct link to heading">#</a></h2><p><code>Apache Shenyu</code>的<code>HashLoadBalance</code> 中采用了一致性hash算法，使用有序hash环，将key与服务器节点的hash映射缓存起来。对于请求的ip地址，计算出其<code>hash</code>值， 在hash环上顺时针查找距离这个key的hash值最近的节点，将其作为要路由的节点。一致性hash解决了传统取余hash算法的可伸缩性差的问题。</p><p><code>HashLoadBalance</code>中的采用的是加密的单向MD5散列函数，这个hash函数会hash后产生不可预期但确定性的()的结果，输出为32-bit的长整数。<code>hash</code>代码如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">private static long hash(final String key) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // md5 byte</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    MessageDigest md5;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        md5 = MessageDigest.getInstance(&quot;MD5&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (NoSuchAlgorithmException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new ShenyuException(&quot;MD5 not supported&quot;, e);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    md5.reset();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    byte[] keyBytes;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    keyBytes = key.getBytes(StandardCharsets.UTF_8);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    md5.update(keyBytes);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    byte[] digest = md5.digest();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // hash code, Truncate to 32-bits</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    long hashCode = (long) (digest[3] &amp; 0xFF) &lt;&lt; 24</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            | ((long) (digest[2] &amp; 0xFF) &lt;&lt; 16)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            | ((long) (digest[1] &amp; 0xFF) &lt;&lt; 8)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            | (digest[0] &amp; 0xFF);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return hashCode &amp; 0xffffffffL;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>再看一下<code>HashLoadBalance</code>的选择函数<code>doSelect()</code>的实现：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    private static final int VIRTUAL_NODE_NUM = 5;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public DivideUpstream doSelect(final List&lt;DivideUpstream&gt; upstreamList, final String ip) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        final ConcurrentSkipListMap&lt;Long, DivideUpstream&gt; treeMap = new ConcurrentSkipListMap&lt;&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (DivideUpstream address : upstreamList) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int i = 0; i &lt; VIRTUAL_NODE_NUM; i++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                long addressHash = hash(&quot;SOUL-&quot; + address.getUpstreamUrl() + &quot;-HASH-&quot; + i);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                treeMap.put(addressHash, address);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        long hash = hash(String.valueOf(ip));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        SortedMap&lt;Long, DivideUpstream&gt; lastRing = treeMap.tailMap(hash);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!lastRing.isEmpty()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return lastRing.get(lastRing.firstKey());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return treeMap.firstEntry().getValue();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这个方法中，生成带虚拟服务器节点的hash环， 一个实际节点会生成5个虚拟节点，因此整个hash环的均匀性大大增加，降低数据倾斜的发生。</p><p>为了实现hash环的有序性及顺时针查找功能，代码中使用Java 的<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentSkipListMap.html" target="_blank" rel="noopener noreferrer">ConcurrentSkipListMap</a> 来存储带虚拟节点的服务器节点及其hash值， 它既能保证线程安全，又能保证数据的有序性，支持高并发。 另外，<code>ConcurrentSkipListMap</code>提供了一个<code>tailMap(K fromKey)</code>方法，可从<code>map</code>中查找比<code>fromKey</code>大的值的集合，但并不需要遍历整个数据结构。</p><p>上述代码中，生成hash环之后，就是调用<code>ConcurrentSkipListMap</code>的<code>tailMap()</code>方法，找到大于等于请求的ip的hash值的子集，这个子集的第一个就是要路由的服务器节点。采用了合适的数据结构，这里的代码看上去是不是特别的简洁流畅？</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="roundrobinloadbalance"></a>RoundRobinLoadBalance<a class="hash-link" href="#roundrobinloadbalance" title="Direct link to heading">#</a></h2><p>Round-robin轮询方法的原始定义是顺序循环将请求依次循环地连接到每个服务器。当某个服务器发生故障（例如：一分钟连接不上的服务器)，从候选队列中取出，不参与下一次的轮询，直到其恢复正常。在 <code>RoundRobinLoadBalance</code>中实现的是组内加权轮询（<code>Weight Round Robin per-packet</code>)方法：</p><p>为了计算和存储每个服务器节点的轮询次数，在这个类中定义了一个静态内部类<code>WeigthRoundRobin</code>，我们先看一下它的主要代码（去掉了注释）：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">protected static class WeightedRoundRobin {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int weight;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final AtomicLong current = new AtomicLong(0);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private long lastUpdate;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    void setWeight(final int weight) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.weight = weight;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        current.set(0);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    long increaseCurrent() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return current.addAndGet(weight);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    void sel(final int total) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        current.addAndGet(-1 * total);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    void setLastUpdate(final long lastUpdate) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.lastUpdate = lastUpdate;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>请重点关注这几个方法：</p><ul><li><p><code>setWeight(final int weight)</code> ，为对象设定权重，并将current重置为0.</p></li><li><p><code>increaseCurrent()</code> : 对<code>AtomicLong</code>类型的对象<code>current</code>，累加其权重值。</p></li><li><p><code>sel(final int total)</code>:   <code>current</code>减去传入的 <code>total</code>值。</p></li></ul><p>下面我们看一下带权重的轮询过程是如何实现的。
首先定义了一个<code>ConcurrentMap</code>类型对象<code>methodWeightMap</code> 两层对象来存储服务器列表与其各个明细节点的轮询资料。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">private final ConcurrentMap&lt;String, ConcurrentMap&lt;String, WeightedRoundRobin&gt;&gt; methodWeightMap = new ConcurrentHashMap&lt;&gt;(16);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这个map对象第一层的key为当前服务器列表的第一个节点的<code>upstreamUrl</code>,  第二个对象<code>ConcurrentMap&lt;String, WeightedRoundRobin&gt;</code>存储了组内各个服务器节点的轮询情况，内层Map的key为组内每个服务器的<code>upstreamUrl</code>。<code>Map</code>对象使用<code>JUC</code>的<code>ConcurrentHashMap</code>，不仅存取高效，而且线程安全，支持高并发。</p><p>内层map的每个节点对应的<code>WeighedRoundRobin</code>作为静态内部类能确保线程安全，并实现组内的加权轮询选择功能。下面是这个类的<code>doSelect()</code>方法的代码。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public DivideUpstream doSelect(final List&lt;DivideUpstream&gt; upstreamList, final String ip) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    String key = upstreamList.get(0).getUpstreamUrl();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ConcurrentMap&lt;String, WeightedRoundRobin&gt; map = methodWeightMap.get(key);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (map == null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        methodWeightMap.putIfAbsent(key, new ConcurrentHashMap&lt;&gt;(16));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        map = methodWeightMap.get(key);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int totalWeight = 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    long maxCurrent = Long.MIN_VALUE;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    long now = System.currentTimeMillis();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    DivideUpstream selectedInvoker = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    WeightedRoundRobin selectedWRR = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (DivideUpstream upstream : upstreamList) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String rKey = upstream.getUpstreamUrl();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        WeightedRoundRobin weightedRoundRobin = map.get(rKey);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int weight = getWeight(upstream);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (weightedRoundRobin == null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            weightedRoundRobin = new WeightedRoundRobin();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            weightedRoundRobin.setWeight(weight);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            map.putIfAbsent(rKey, weightedRoundRobin);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (weight != weightedRoundRobin.getWeight()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            //weight changed</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            weightedRoundRobin.setWeight(weight);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        long cur = weightedRoundRobin.increaseCurrent();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        weightedRoundRobin.setLastUpdate(now);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (cur &gt; maxCurrent) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            maxCurrent = cur;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectedInvoker = upstream;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectedWRR = weightedRoundRobin;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        totalWeight += weight;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ......  //erase the section which handles the time-out upstreams. </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (selectedInvoker != null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        selectedWRR.sel(totalWeight);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return selectedInvoker;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // should not happen here</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return upstreamList.get(0);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>举例，若服务器组<code>upstreamUrl</code> 分别为： LIST = [upstream-20, upstream-50, upstream-30]时，经过一轮执行后，建立的<code>methodWeightMap</code> 资料如下：</p><p><img alt="methodWeightMap" src="/zh/assets/images/methodWeightMap-90b4a77aedffd8cd88bc12b9551739ad.png"></p><p>假设上述的LIST中，各个服务器节点的权重数组为: [20,50,30], 下图是内部类current 值变化和轮询选择过程：</p><p><img alt="weighted-roundrobin-demo" src="/zh/assets/images/weighted-roundrobin-demo-cec02fd422fb01ef73e882e0966a8cec.png"></p><p>每一轮，选择值current最大的服务器节点：</p><ul><li>Round1:<ul><li>对当前服务器LIST做遍历，当服务器节点的weightedRoundRobin 为null时，current被置为各自的权重； 不为null时，累加各自的权重。</li><li>即：遍历后current 分别为 [20, 50,30] ， 会选择Stream-50, Stream-50对应的WeightRoundRobin静态类做 sel(-total)处理，current 更新为[20,-50, 30].</li></ul></li><li>Round 2  遍历后的current是[40,0,60],  会选择Stream-30， current分别更新为[40,0,-40].</li><li>Round 3  遍历后的current是[60,50,-10],  会选择Stream-20，current分别更新为[-40,50,-10].</li></ul><p>中间进行了容错处理， 当服务器的个数与map个数不一样，就对methodWeightMap 加锁做处理。 用先copy 后modify的方式， 把超时的服务器remove掉，即移除掉发生故障的服务器，并更新Map资料。如下是异常时的处理代码：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Java"><pre tabindex="0" class="prism-code language-Java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    if (!updateLock.get() &amp;&amp; upstreamList.size() != map.size() &amp;&amp; updateLock.compareAndSet(false, true)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // copy -&gt; modify -&gt; update reference</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            ConcurrentMap&lt;String, WeightedRoundRobin&gt; newMap = new ConcurrentHashMap&lt;&gt;(map);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            newMap.entrySet().removeIf(item -&gt; now - item.getValue().getLastUpdate() &gt; recyclePeriod);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            methodWeightMap.put(key, newMap);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            updateLock.set(false);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (selectedInvoker != null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        selectedWRR.sel(totalWeight);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return selectedInvoker;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // should not happen here</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return upstreamList.get(0);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="loadbalanceutils"></a>LoadBalanceUtils<a class="hash-link" href="#loadbalanceutils" title="Direct link to heading">#</a></h2><p>在这个类中，提供了调用<code>LoadBalance</code>的静态方法, 其中<code>ExtensionLoader</code> 是<code>Apache Shenyu</code>的<code>SPI</code>执行入口。也就是说，LoadBalance模组是可配置、可扩展的。这个静态方法中的<code>algorithm</code>变量是<code>LoadBalanceEnum</code>中定义<code>name</code>枚举类型。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Selector divide upstream.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param upstreamList the upstream list</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param algorithm    the loadBalance algorithm</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param ip           the ip</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the divide upstream</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static DivideUpstream selector(final List&lt;DivideUpstream&gt; upstreamList, final String algorithm, final String ip) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        LoadBalance loadBalance = ExtensionLoader.getExtensionLoader(LoadBalance.class).getJoin(algorithm);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return loadBalance.select(upstreamList, ip);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="using-of-loadbalance-module"></a>Using of LoadBalance module<a class="hash-link" href="#using-of-loadbalance-module" title="Direct link to heading">#</a></h2><p>上面说明了<code>LoadBalance</code> SPI接口及三个实作类。下面看一下<code>LoadBalance</code>在<code>Apache Shenyu</code>中是如何被调用的。<code>DividePlugin</code>是路由选择插件，所有的Http请求都由该插件进行负载均衡处理。当请求头rpcType = http, 且开启该插件时，它将根据请求参数匹配规则，最终交由下游插件进行响应式代理调用。</p><p>在<code>DividePlugin</code>的<code>doExecute</code>方法中，先对要转发的请求的Header大小、content长度等做校验，</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@SneakyThrows</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">protected Mono&lt;Void&gt; doExecute(final ServerWebExchange exchange, final ShenyuPluginChain chain, final SelectorData selector, final RuleData rule) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   ......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>接口方法的第二个参数是<code>ShenyuPluginChain</code> 类型，代表<code>plugin</code>的调用链，具体可参见<code>Apache Sheyu</code> 的<code>plugin</code>的调用机制。第三个<code>SelectorData</code>类型的参数是选择器， 第四个是<code>RuldData</code>类型，代表规则。分别请查看对应的代码。</p><p> 下面给出了<code>doExecute</code>()方法中，有关<code>LoadBalance</code>调用的代码片段：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">   //取到要路由的服务器节点列表。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   List&lt;DivideUpstream&gt; upstreamList = UpstreamCacheManager.getInstance().findUpstreamListBySelectorId(selector.getId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ... </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //取到请求的ip</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    String ip =   Objects.requireNonNull(exchange.getRequest().getRemoteAddress()).getAddress().getHostAddress();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //调用Util方法，执行LoadBalance处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    DivideUpstream divideUpstream = LoadBalanceUtils.selector(upstreamList, ruleHandle.getLoadBalance(), ip);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>  这里<code>UpstreamCacheManager</code> 是缓存的要路由的服务器节点 ， <code>ruleHandle.getLoadBalance()</code>取到的是<code>LoadBalanceEnum</code>定义的枚举name, 如<code>random, hash, roundRobin</code>等.</p><p>  经过封装，调用负载均衡功能非常的方便。  未来增加新的<code>LoadBalance</code>类，这些调用的<code>Plugin</code>代码完全不需要变更。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="summary"></a>Summary<a class="hash-link" href="#summary" title="Direct link to heading">#</a></h2><p>经过上面的代码解读，从设计角度总结<code>LoadBalance</code> 模组具有如下的特点：</p><ol><li><p>可扩展性：面向接口的设计，及基于Apache Shenyu SPI的实现，使得系统具有良好的可扩展性。可以方便的扩展为其他的动态的负载均衡算法，如最少连接方式(least connection)、最快模式( fastest)。并支持集群处理，具有良好的可扩展性。</p></li><li><p>可伸缩性： 采用的一致性hash <code>LoadBalance</code>、权重随机和权重轮询，都可以无缝支持集群扩容或缩容。</p></li><li><p>流量预热等更细致的设计，能带来整体上更为平滑的负载均衡。</p></li></ol></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><a class="margin-horiz--sm" href="/zh/blog/tags/load-balance">load balance</a><a class="margin-horiz--sm" href="/zh/blog/tags/spi">SPI</a><a class="margin-horiz--sm" href="/zh/blog/tags/apache-shen-yu">Apache ShenYu</a></div></footer></article><article class="margin-bottom--xl"><header><h2 class="blogPostTitle_d4p0"><a href="/zh/blog/SPI-SourceCode-Analysis-MatchStrategy-SPI">MatchStrategy--基于SPI的代码分析</a></h2><div class="blogPostData_-Im+ margin-vert--md"><time datetime="2021-12-14T03:31:25.749Z">2021年12月14日</time> · One min read</div><div class="avatar margin-vert--md"><div class="avatar__intro"><div class="avatar__name"><a>Huihui Yin</a></div><small class="avatar__subtitle">Apache ShenYu Contributor</small></div></div></header><div class="markdown"><p><code>Apache Shenyu</code> 网关的各个<code>Plugin</code>（包括<code>Dubbo</code>, <code>gRPC</code>,<code>Spring-cloud</code>等) 中，<code>routing</code>参数均设计为可以接受多个条件的组合。 为了实现这样的目的，遵循其<code>SPI</code>的机制进行将参数及行为抽象为如下三部分，这些<code>SPI</code> 在<strong><em>shenyu-plugin-base</em></strong>模组中实现</p><ul><li><code>ParameterData</code>-参数资料</li><li><code>PredictJudge</code>-断言</li><li><code>MatchStrategy</code>-匹配策略</li></ul><p>相对而言，匹配策略是需要扩展点最少的部分。想象一下，对多个条件的组合判断，最常见的几种规则是：全部都满足、至少满足一个条件、至少满足第一个，或者大部分满足等等。 并且要做到对各种<code>plugin</code>的不同类型的参数，如<code>IP</code>, <code>header</code>, <code>uri</code>等。针对这些需求，如何将<code>MatchStrategy</code>设计得简单易用且容易扩展？</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="matchstrategy"></a>MatchStrategy<a class="hash-link" href="#matchstrategy" title="Direct link to heading">#</a></h2><p><code>MatchStrategy</code>的实现代码在<strong><em>shenyu-plugin-base</em></strong>模组中，基于<code>Apache Shenyu</code>的<code>SPI</code>创建机制， 设计上结合了工厂模式和策略模式，整体<code>MatchStrategy</code>的设计类图如下下：</p><p><img alt="MatchStrategy-class-diagram" src="/zh/assets/images/MatchStrategy-class-diagram-ac006eef5089ce92a972e039b431100b.PNG"></p><p>以接口<code>MatchStrategy</code>为基础，设计实现类，并由抽象类<code>AbstractMatchStrategy</code>实现公共方法，由工厂类<code>MatchStrategyFactory</code>提供创建和外部调用功能。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="matchstrategy-interface"></a>MatchStrategy Interface<a class="hash-link" href="#matchstrategy-interface" title="Direct link to heading">#</a></h2><p>首先来看<code>MatchStrategy</code> <code>SPI</code>接口的定义：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@SPI</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface MatchStrategy {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Boolean match(List&lt;ConditionData&gt; conditionDataList, ServerWebExchange exchange);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>@<code>SPI</code> <code>annotation</code>代表这是一个<code>SPI</code>接口。<code>ServerWebExchange</code> 是 <code>org.springframework.web.server.ServerWebExchange</code> ,代表<code>HTTP</code>的 <code>request-response</code>  的交互内容。<code>ConditionData</code>的代码如下，更多说明可以参考<code>PredicateJudge</code><a href="http://shenyu.apache.org/blog/PredicateJudge-SPI" target="_blank" rel="noopener noreferrer">代码分析</a>中的说明，</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public class ConditionData {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String paramType;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String operator;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String paramName;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String paramValue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="abstractmatchstrategy"></a>AbstractMatchStrategy<a class="hash-link" href="#abstractmatchstrategy" title="Direct link to heading">#</a></h2><p>在抽象类<code>AbstractMatchStrategy</code>中，定义<code>MatchStrategy</code>的公共方法， 用<code>buildRealData</code>方法中，用<code>ParameterData</code>工厂类<code>ParameterDataFactory</code>，将多种参数如  <code>Ip</code>, <code>Cookie</code>, <code>Header</code>,<code>uri</code>等资料都以统一的接口方法来呈现。这些参数格式及规则的修改，不会影响到对参数规则匹配<code>MatchStrategy</code>的调用。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public abstract class AbstractMatchStrategy {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String buildRealData(final ConditionData condition, final ServerWebExchange exchange) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ParameterDataFactory.builderData(condition.getParamType(), condition.getParamName(), exchange);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="实现类及profile"></a>实现类及Profile<a class="hash-link" href="#实现类及profile" title="Direct link to heading">#</a></h2><p>基于上述接口定义, <strong><em>shenyu-plugin-base</em></strong> 模组提供了两个<code>MatchStrategy</code>实现类</p><ul><li><p><code>AndMatchStrategy</code>-多个条件 AND</p></li><li><p><code>OrMatchStrategy</code>- 多个条件 OR</p><p>并在<code>SHENYU_DIRECTORY</code>目录下的配置文件中，对实作类做了配置。在系统启动时会由顶层<code>SPI</code>以<code>key-value</code>形式加载并<code>cache</code>起来。</p></li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI properties"><pre tabindex="0" class="prism-code language-properties codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">and=org.apache.shenyu.plugin.base.condition.strategy.AndMatchStrategy</span></span><span class="token-line" style="color:#393A34"><span class="token plain">or=org.apache.shenyu.plugin.base.condition.strategy.OrMatchStrategy</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p> 两个实现类<code>AndMatchStrategy</code> 继承<code>AbstractMatchStrategy</code> 并实做了<code>MatchStrategy</code>。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="andmatchstrategy---与的关系"></a>AndMatchStrategy-  “与”的关系<a class="hash-link" href="#andmatchstrategy---与的关系" title="Direct link to heading">#</a></h3><p>  由于<code>PredicateJudge</code>封装了条件判断的多样性，<code>ConditionData</code>和<code>ParameData</code>封装了多种参数。那么对于多个条件的匹配来说，采用<code>Stream</code>流处理及<code>lamda</code>表达式，非常简洁高效达成了：全部条件都满足，即&quot;AND&quot;的逻辑。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Join</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class AndMatchStrategy extends AbstractMatchStrategy implements MatchStrategy {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Boolean match(final List&lt;ConditionData&gt; conditionDataList, final ServerWebExchange exchange) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return conditionDataList</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .stream()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .allMatch(condition -&gt; PredicateJudgeFactory.judge(condition, buildRealData(condition, exchange)));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><code>OrMatchStrategy</code>是同样的实现方式，实现: 至少满足一个条件&quot;OR&quot;的规则，在此不做赘述。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="matchstrategyfactory"></a>MatchStrategyFactory<a class="hash-link" href="#matchstrategyfactory" title="Direct link to heading">#</a></h2><p>这是<code>MatchStrategy</code>的工厂类，实现了两个方法，一个是<code>newInstance()</code>方法根据策略代码和名称，返回由<code>SPI</code> <code>ExtensionLoader</code>按key来加载对应的<code>MatchStrategy</code>实现类。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    public static MatchStrategy newInstance(final Integer strategy) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String matchMode = MatchModeEnum.getMatchModeByCode(strategy);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ExtensionLoader.getExtensionLoader(MatchStrategy.class).getJoin(matchMode);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在<code>MatchModeEnum</code> 中定义了match策略的code和name。 调用时由策略名称，如&quot;and&quot;,&quot;or&quot;，根据启动时SPI加载的key-value资料，找到对应的实现类：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">AND(0, &quot;and&quot;),  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">OR(1, &quot;or&quot;);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>另一个是<code>match()</code>方法，调用实作类的<code>match</code>方法。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    public static boolean match(final Integer strategy, final List&lt;ConditionData&gt; conditionDataList, final ServerWebExchange exchange) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return newInstance(strategy).match(conditionDataList, exchange);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="调用方式"></a>调用方式<a class="hash-link" href="#调用方式" title="Direct link to heading">#</a></h2><p>在<code>shenyu-plugin</code>模组的各个<code>plugin</code>的基类<code>AbstractShenyuPlugin</code> 中，定义了两个选择的方法：<code>filterSelector</code> 和<code>filterRule</code> 它们都调用了<code>MatchStrategyFactory</code> 方法，下面是<code>AbstractShenyuPlugin</code>中<code>filterSelector</code>方法的代码：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    private Boolean filterSelector(final SelectorData selector, final ServerWebExchange exchange) {        if (selector.getType() == SelectorTypeEnum.CUSTOM_FLOW.getCode()) {            if (CollectionUtils.isEmpty(selector.getConditionList())) {                return false;            }            return MatchStrategyFactory.match(selector.getMatchMode(), selector.getConditionList(), exchange);        }        return true;    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这段代码中，先检测参数匹配条件<code>SelectorData</code>是否为空，之后调用<code>MatchStrategyFactory</code>的<code>match</code>方法，工厂方法将调用对应的实作类的<code>match</code>方法。同理，如下是<code>AbstractShenyuPlugin</code>中 <code>filterRule</code> 方法</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    private Boolean filterRule(final RuleData ruleData, final ServerWebExchange exchange) {        return ruleData.getEnabled() &amp;&amp; MatchStrategyFactory.match(ruleData.getMatchMode(), ruleData.getConditionDataList(), exchange);    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>也同样是调用<code>MatchStrategyFactory</code>的<code>match</code>方法，看上去是不是特别的简洁甚至是简单？ 在<code>PredicteJudge</code>的<a href="http://shenyu.apache.org/blog/PredicateJudge-SPI" target="_blank" rel="noopener noreferrer">代码分析</a>文中，对<code>shenyu-plugin</code>如何做参数调用方面做了更进一步的描述。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="summary"></a>Summary<a class="hash-link" href="#summary" title="Direct link to heading">#</a></h2><p>由于应用了<code>Apache shenyu</code>的<code>SPI</code>框架，使得整体上具有松耦合、易于扩展的特点。在多个参数规则策略方面，<code>MatchStrategy</code>提供了良好的设计，虽然目前只提供了两个AND 和OR的实现类，但未来可以很轻松地扩展为更多<code>MatchStrategy</code>规则，例如 <code>firstOf</code>：即必须满足第一个条件，或<code>mostOf</code>-满足大部分条件等更多复杂策略，而其他调用部分的代码完全不受影响。 </p><p>有兴趣的读者可以去阅读<code>Shenyu plugin</code>的源码了解更多内容。</p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><a class="margin-horiz--sm" href="/zh/blog/tags/spi">SPI</a><a class="margin-horiz--sm" href="/zh/blog/tags/apache-shen-yu">Apache ShenYu</a></div></footer></article><article class="margin-bottom--xl"><header><h2 class="blogPostTitle_d4p0"><a href="/zh/blog/SPI-SourceCode-Analysis-PredicateJudge-SPI">PredicateJudge-- 基于SPI的设计实现分析</a></h2><div class="blogPostData_-Im+ margin-vert--md"><time datetime="2021-12-14T03:31:25.749Z">2021年12月14日</time> · One min read</div><div class="avatar margin-vert--md"><div class="avatar__intro"><div class="avatar__name"><a>Huihui Yin</a></div><small class="avatar__subtitle">Apache ShenYu Contributor</small></div></div></header><div class="markdown"><p>灵活的插件和规则定义，是<a href="http://shenyu.apache.org/" target="_blank" rel="noopener noreferrer">Shenyu网关</a>的一大特色。它以插件形式支持多种网络协议和多种流行的微服务框架，如Dubbo, gRPC和 Spring-Cloud 等。 为了实现对各种协议及插件的配置规则的解析，网关在规则策略解析方面，采用了优雅的<code>SPI</code>(Service Provider Interface)实现，当添加新的插件时，规则解析部分可以沿用现有实现或采用<code>SPI</code>机制快速实现，具有良好的可扩展性。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="spi-的顶层设计"></a><code>SPI</code> 的顶层设计<a class="hash-link" href="#spi-的顶层设计" title="Direct link to heading">#</a></h2><p>Shenyu的<code>SPI</code>采用接口+ 工厂模式+配置文件的方式，来实现模组的动态加载。在其<strong><em>shen-<code>SPI</code></em></strong>-模组，做了<code>SPI</code>的顶层设计。定义了@ Join ，@<code>SPI</code> 两个annotation。 其中@Join  代表此类会加入扩展机制，相当于是做申请注册。 @<code>SPI</code> 标明当前类为<code>SPI</code>功能扩展类。</p><p>Fig 1 classes in the <strong><em>shenyu-spi</em></strong></p><p><img alt="toplevel-SPI" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASkAAACeCAYAAABuIfz7AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAABX0SURBVHhe7Z39kxXVmcf5l1L70/y2STbRaLTKJEQoeTFBBtYkG8iS2ggoiChCcBCFlEQriElF0RWoiplaYGCDMRiRXQEtglNmABdKN1izI+iaicBJP6fP6T4vz+nue29f7pnu78c65b3d5637nudzTx/udM8SAAAQMZAUACBqICkAQNRAUgCAqBmYpM5f/FCcfu+slcbPvi8uf/KpygEAAAOU1KvHTog9+3/npX0HjkhZge4ZHZ4lZg2Pqnc3hkG0GRvyHAyNiHH1HtQDK6kXXnhB7N69W0xMTKgtNpOTk2LPnj0yH6VuCElKpzN/Pqdygk6BpAbBuBgZgqT6ASspElRIVK6g+iWpKonqAD6QFGgSrKRITJyoXEG98cYbMnUDJNU/ICnQJIJrUq6oTp065Qnq+vXrMnVD3yU1PiKGZiWBYyQ3hmRgJdPz0ZGhNI85VR8dtsoOjYym0/nCQFRT/qzcsDBz6/bG3b55dRbXkzIqhs06jL5rYYzr4wrV4faj9FLFbtPsdj1tquMuqCc7h+q9Rm9/V/VxaMTOESqXU3JsVLbkcytvA3RD4cK5KSozaUH1giup3xx+TZy78IH4+Mon8v+vHP6DtZ9LQUkpwVhjSA0wc/DKQcUMNh0g3kBl8pqMjwyLvHp/jSKrwxzIeuAb9ZbVo4/PCsSknsSjEt1Ovl8FoFfHUHE7Fn7wj474x9Zbm+o9V48+P14dRJonzeL3k5D96/HYrPLM51bcBuiWQkkRrqjqEBThSuri/15Se1IufvgXaz+XeEnxg5RI5eN8K3vf9qHyKoAKJOUhA6qsPb9fHlY95f3ggsVuI63Dq0IGnisAhQrKULP1tKmOrUI91udjnZ8uJFXl2LL6c9jxBEnVTqmkCC2qugRFuJL6/OpVtSfl88+vWvu5xEqqaMA538LsoAqWL5cDkQ5oM1UYxMzsIFhPSUARsqyTwQooVYddf574utXxUx7mGOppkz/Hrgzk+6wPrrS6mUlVOLYKn1txG6BbKkmqH7iSmpz6WO1Joffmfi7FJak0OMxgStvL31cb7CX11CipojqCmLIxjqWeNqtJKq1LnS/ztaQbSSmKjq30c6vYBuiYaCQ19oc3xZVP/1/uo//Te3M/l1hJBQYp4Q52flCFyit5hKLMGbAE254ZbAqrH6X1hI9PI+srDPTyOkqR/cylU0+bFSWl8lFdcp/1GfJ18J91AO7Yyj435j2oh2gkpRMtoHPbucRLSg9q51vbGXhEaFClg9IWRbotSVkFjrTc+rNv5Xxw+3UkuOUq1BM6Pv1etmPt1GVK6qC2sg3O8SX7hu0TkpR3ZhE9t1lVUgnU/lByzEl+J3vaFzO/Oqf5Z93FsZn5CVWnvclsA9RFdJLqJIUkJdEDM0u2dIiiQZUNTJWGR90A8gNKB6FMVK/sQx4sur3sJw9Z3SqDoqweiXt8RiWyHadSLtCtdihZ58I/PvucMBLvQ5sEV0/SYioabzuh6tFtJPXpc5+21cWxVfjc7DZAXTRXUrXDB1AnYBDXSe+fR1XwuQ2WgUlq6vIn4tLk//WUqI4bhrrs6iUmMNhrRH4e/uy4H+BzGywDk1TM0OWFvcCrLi16HKgY7PUhz+UNmEUR+NwGCyQVQA5MY/2hjoDAYO+dbE3rBp5HfG6DBZICAEQNJAUAiBpICgAQNZAUACBqICkAQNRAUgCAqIGkAABRA0kBAKKmdZL627VpcXbqjDh64aA4dH6fTPSattE+AEBctEZS15P/3rn0pnj+9Hax6+0RNtE+ykN5AQBx0ApJTV/9q9g/8RIrJi5RXirTVCbunyWemjsiJtV7AGKm8ZKiWVEngtKJyhTNqCZ3Dokd/zDLS2NHVIZoGRfH5/ZPUjP3vIBYabyk6PKNk1CVRGVDUDD2FuijYuwLzQteeV6+MCz4B/TXQTPPGwjTaEnRQnhoDWrJ2rvEwhXflIlec3mobGgxHZLigaRA3TRaUmen3mXlQ2nL/gfEvGV3yESvuTyUqA6OIknRPv8SJw2up+4fzfab6aWdxo1Azo6Il5K8ep/djrpcc+rxxZC2p/ebfWHXpJw23TJV25XnpVBSaT2h8il233VfOz1vlFyZ6WOfUHXR65OBNTqs3cVBoyX1+sUxVjw63bt+gUzcPp2oDg4ZjAUD2B7geYDnBGYER4aTwB0Sx8+q994aUh7keYDmAjTfmwE8sTPvqxd8SZteQKuAz+uo0m65pCZ3DhccW4Lqiyuf41nfwuet/BjSY6d81mfhnXMi0A644TRaUofO7WPFo1MVSVEdHNy3uh2cuSj4wOWCIA1aLzBksOkgYgI7wWpDBWcowGxJ5f10sftdoV31vvi8OEhBOG1YMnfhzlvVY1DH7vUnbdcqb/ULDBJIqgdJuQHroWThf0sTTLCp/G6Q65Tm5QOZEwqV4fpoSapIaNYMo0q7/nsOPZvRKctfIteU8HkrPwZX0Dn258lICwwMXO6VSKrbyz1Jl5IqDtJqspCo+lxZDU5S6TFb+80ZS6Xj74+k0jpUPvM1GDitXTh//MCabOGcXnN5KHWzcJ6SfxvzeZlgU9uKv8E7kJQmCVQSlW7LDtRwm3adNUjKEQZh569y/J2dN7c/QUmVfl5gUDRaUoP8CYIdDFyA84FF9ZpCkdA3e1a2giyS/GNmvSWzCbZNR2x1ScqqU82A3PJcX/L3HZw37xiKJJVA52lu0lZynFY9YKA0WlJEP3/MSQHgJgpiGQju5YIOSDPIVRBRMoPOrdsOqmqyoD5k5Z2+sIFq9IUrU4ukEsxjk30gMbj53b44bYbOW/kxlEhKCbCo/+DG03hJ9evPYkAT4UUMBkvjJUXgD4xBJbBgHiWtkBRBsyK6fAutUVGifZQHM6h2Ii8FMYuKjtZISkML4bjpHTDR62ThtSowSFonKQDAzAKSAgBEDSQFAIgaSAoAEDWQFAAgaiApAEDUQFIAgKhpvKQuf/KpOHz0uNj18m/Fq8feUlsBADOFRkvqg798JJ7bMyp+/vw+mXa/clBMX7su/jQ1LQ5cuCL2nr8sE72mbbQPABAXjZUUzaBMQVHad/SE2HZ6Umx++yM20b5jlz7DH8UAEBGNlRRd4pmCembvfvHYiQ9ZObnpxYmPxWdXr6mamkfx7UpmMriLQRNprKR2vZzPop7Zs19s+a//EVv++OeORFU0ozLvi2Sm+G+WpgK5T5Iqu59Uf4GkmkhjJfXqsRNi9ytj8hKPxESC+vmLvxFPHvpvVkpcoku/EDIYewp07ja4Mx9ICtRNoxfOaSFcr0GRqEhQO/79P+Tr5b/eLxasf0LMXrFWfGfTDrHm8DuepKhsaDEdkuKBpEDdNFpSZ6amPfE89tYHYtFDj4ub5i8Wdz/6M7HkyV+KOSsfEbct/ZHYyFwKUh0cRZKiff6ln7o1bRJAer+ZrNvgqlsN6312O3kgmvX4Ykjb0/vNvrBrUk6bbpmq7crzUiap0raItL1QOxLvNsMjvKQKz2d+PsynGnf/5QPqptGSOnjxiiedZb8aFTcvXCLWH33P2r4pkZf5Xieqg0MGY8FgtkXAfcMHZlLynt/m3SFVWacuCqZcbLkAzfem+GJ5gnG1tqieak86Nuuh46Jt1nkuPZ+BciAaGi2pvecue9KZ/+AWOYNyt4cS1cFhziZ0soMzFwUfuJyk0gDyxCWDWAcaE7AJVhsq6L16FLakfKFp7H5XaJd5b1O1LQYpG70/VI/qYyabKudTnY+itsFAaaekNmz3todSkaTcgPVQsuCeWsJKSuV35adTmtcNxBROKFSG66MlqSKhWbOQKu2WyKZyWyl6hqNTVm+wHqePlc6nK20QG+283FswLNb9ftzavmbspPVep24v9yQqSDqVFBvEGdVkITGC1Oxr/JJKz41VjzmTCtbDS6r4fEJSsdO6hfPNpy6JOas2iJvm3SNoRjW8dZf4xvLV4ub5i8WGY+97+btZOE9JAya73PPyMpIKXsaYdCApTRLg4ZlDuE27zhokVbUtZlZl1xuqJ92e97HK+YSkYqfRkjJ/gmClRFQ0o5q3dkTMue9hsXjrs+Kh1+yZFaVefoJgD3wuwPkAonpNoUhoRpCVrSCLJH+UTzBOqNSW+17NiMx65TE4IqNtVM7sI9uedT4hqdhptKQI+kGmK5+qqezHnDT43UQBwgVQFmhmkKtgpGTKyq3bDqBqstABK8szwewFpdEXrkwnkjLryeoLHLfc57Vl1yP7mpRx5WceI6WxI+E+mvncY4ek4qbxkqJ5EP2JCyeholT2ZzEAgBtD4yVF0B8LdyKqpv+BMQAziVZIiqBZEV2+sWtUKtE+3KoFgLhojaQ0tBCOm94BMHNonaQAADMLSAoAEDWQFAAgaiApAEDUQFIAgKiBpAAAUQNJAQCiBpICAERN6yT1t2vT4uzUGXH0wkFx6Pw+meg1baN9AIC4aI2krif/vXPpTfH86e1i19sjbKJ9lIfyAgDioBWSmr76V7F/4iVWTFyivFSmn+D2IABUo/GSollRJ4LSicqUz6j4+xeVo8pBUgCU0nhJ0eWbKZ9nT42INc8tEwtWfEvcftc/iVvnfEl8e+nXxfKRe8TTxx618lLZYrqVFACgKo2WFC2Em2tQO08+JhatvFPMufc28dDuFeIXb22W27f9bp249+GFYvbiW8VTr2/I8lPZ4sV0SAqAftNoSZ2dejcTDqVVz3xfzF5yq3jmzY3JrGmjWL3zX8SKbUvEfTvuFTuOPiLuWT1X/GDj3VYZqiNMQFLqVsHmLWute2wn2GtSeT3WbXML7hUOQFtotKRevzhmCeeuZXdIUe1441HxzUVfE8s2f1ds2PMTccudXxI/fWWlfE3bzTJURxhGUu5DBAglLfM+5pykqFyex33yCQDtpNGSOnRunyWc2+d/VWz+7Sqx5rkfijv/+Ta5jS4Bb/n2F8XI/gfE4wfWSGGZZaiOMK6kwo9Qch9YwM6knIV0twwAbaRdkpr3FSmjnySXdwtXfEtu2/bqevG12f8onvjPdWLd8//qzaQ6kpSaMbmXdhL5tJP8qSihyz0TSAqAll3uzf3e7eL+XT+UM6avz/2yvPRbtGqOuH3BV8XSdfPE7OFbxY+fXGKVqXK5l82cICkAaqdVC+ckoHnL75A/Q6AZ1Y+3LxWPvPxvciF9ZSIs+hc/2meWKV44Ty/vcin1eLkHSQHg0WhJuT9BePr4JrkWtfj+uWLr4QflNlqTeiJ5TQvnOp9OZT9B4CRC27yFc2YxHZICoBqNlhTh/pjz6WTWtOyxRfIHnLQWdcudX5SXgat/8QMrHyX+x5ypUNKfCPhP3pUoKenE5YOkAKhG4yXV3z+LAQD0m8ZLiojxD4wBANVohaQImhXR5Zu5RuUm2kd5MIMCIB5aIykNLYTjpncAzBxaJykAwMwCkgIARA0kBQCIGkgKABA1kBQAIGogKQBA1EBSAICogaQAAFEDSQEAoqZ1ksIvzgGYWbRGUvjbPQBmJq2QFO6CAMDMpfGSollRJ4LSicqUzqjcm9tlN7FL0XfpLMpj3/wOAODSeEnR5Zspn7oes87eNTORlnl/c5nHEpC6A6exDZICoJhGS4oWws01qPoesx5+4IKJL6kE54kykBQAxTRaUv17zHq1pwuzknKeMANJAVBMoyXVz8esk1zkGlOBqMIzqdDz9wAALo2WVL8fs04SyhbEGVn5kvJnYJAUAMW0S1K1P2Y9JZtVOY+uMiWmk7uOBUkBUEyrLvfqf8y6ifqXO+Nf/Pg1KRtICoBiWrVwXv9j1h2ODENSANRMoyXl/gShvses09qS+1Ri/ynEkBQAvdNoSRHujzl7f8y6Jl0EL1pvgqQA6J3GS6qvfxYDAOg7jZcUgT8wBmDm0gpJETQross3c43KTbSP8mAGBUA8tEZSGloIx03vAJg5tE5SAICZBSQFAIgaSAoAEDWQFAAgaiApAEDUQFIAgKiBpAAAUQNJAQCipnWSmr52XfxpalocuHBF7D1/WSZ6TdtoHwAgLlojKdLPsUufiW2nJ8Xmtz9iE+2jPFAVAPHQCkl9dvWaeHHiY1ZMXKK8VOZG0aTbteDWM6BuGi8pmhV1IiidqEzpjKrkCcbV8B8Yyt0bnZJ+DFa8+MdSJzP3vIBeaLyk6PKNk1CVRGVDyBvalTzBuFuq3CyvGPvZfk2BPee10szzNtNptKRoITy0BrX81/vFgvVPiNkr1orvbNoh1hx+x8tDZakOn3Qw1yEkDkiKB5JqJ42W1JmpaU88m09dEnc98FNx0/zF4u5HfyaWPPlLMWflI+K2pT8SG0986OWnOnzSwVz2BONsfUY9Wl1fnrjl3HWcIknRPv8SJ++P3m8mS6ZuX6x28vu0m/X4Ykjb0/vNvrBrUk6bbpmq7crzUiiptJ5Q+RS777qvnZ43Sq7M9LFPqLro9cnAGh3W7qrTaEkdvHjFk86yX42KmxcuEeuPvmdt3/TWB9Z7nagODhpkciAWiCrLYw5GNdjNcu6AlcFYMIDt/HmA5wRmBPJpNuYDJNw1pDzI8wB1hZy+NwN4YmfeVy/41Lqd1Rd1DvI6qrRbLqnJncMFx5ag+uLK53jWt/B5Kz8G4/M2PwvvnBOBdgBLoyW199xlTzrzH9wiZ1Du9lCiOkJY3/qWJFJkwDJB5QYbJyldb1a/VU8uCj5wuSBIg9YLDBlsOoiYwE6w2lDBGQow+1jyfrrY/a7QrnpffF4cpCCcNpjPKYc7b1WPIfR5p+1a5a1+gTLaKakN273toVQkKU32Dep8Y7ryyXC+XTlJseVMlCz8b2mCCTaV3w1yndK8fCBzQqEyXB+tYykSmnUOqrTrv+fQn4VOWf4SuaaEz1v5MYQ/b/vzZKQFCmnn5d6CYbHu9+PW9jVjJ633OoUu93xUoBlBFKOkioO0miwkqj5XVoOTVHrM1n7Zhnpf6fj7I6m0DpXPfA0q0cqF8zmrNoib5t0jaEY1vHWX+Mby1eLm+YvFhmPve/n5hfMAZlAkyEHLBJU7mDuXVP5tzOdlgk1tK/4G70BSmuSYSVS6LftYwm3addYgKUcYhJ2/yvF3dt7c/gQlVfp5gSIaLangTxASUdGMat7aETHnvofF4q3Piodes2dWlIp/guB+G/qBRoNWzjTM4HOCmuhUUnZ+LsD5wKJ63bblN3tWtoIskvxjZr0lswm2Te8c1CMpq041A3LLc33J33dw3ip8jhZ0nuYmbSXHadUDSmm0pIh+/ZhTD2gaqDq5g1sPWv1P0jq5gzQU2G6iIJZ5XUHqgDSDXAURJbNfbt12UFWTBfUhK+/0hQ1Uoy9cmVoklWAem+wDicHN7/bFaTN03sqPoURSarwU9R/wNF5Sff2zmBKKBy1oF7yIQTmNlxQxqD8whqRABhbMu6YVkiJoVkSXb6E/k6FE+yhPrzMoDSQFNHIsYBbVFa2RlIYWwm/UTe8gKaDXyTAOuqd1kgIAzCwgKQBA1EBSAICogaQAAFEDSQEAogaSAgBEjBB/B3o1C04w+m2JAAAAAElFTkSuQmCC"></p><p>配置文件方面，定义<code>SPI</code>加载的目录为 <code>META-INF/shenyu/</code></p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">SHENYU_DIRECTORY = &quot;META-INF/shenyu/&quot;;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>系统启动时，会扫描 <code>SHENYU_DIRECTORY</code> 下的配置文件，并由 <code>ExtensionLoader</code> 类来加载所配置的<code>SPI</code>扩展类，并cache到内存中。  配置文件内容为 key=class的形式。 在系统执行期间， 由<code>ExtensionFactory</code>的实现类，返回key所对应的<code>SPI</code>实现类。 </p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="shenyu-plugin的spi-实现"></a>shenyu-plugin的<code>SPI</code> 实现<a class="hash-link" href="#shenyu-plugin的spi-实现" title="Direct link to heading">#</a></h2><p>在<strong><em>shenyu-plugin</em></strong>模组中，按照插件机制，实现了各种请求转发功能，包括支持request, redirect, response, rewrite等http协议功能，及 gRPC, dubbo, hystrix等微服务框架， 并且插件功能还在不断增加中。如果在各自的功能插件实做类中，还要做对routing 参数的解析等处理，不仅会造成程序的冗余，而且当要支持各自匹配规则，如通配符、正则表达式、SpEL解析等，会造成频繁对插件核心代码的修改。因此，在<strong><em>shenyu-plugin</em></strong>模组中，将routing参数解析做了更高一层的抽象，并按照<code>SPI</code>机制做了规则解析的实现。解析由三个部分组成：</p><ul><li><p><code>ParameterData</code>-参数资料,  </p></li><li><p><code>PredictJudge</code>-断言</p></li><li><p><code>MatchStrategy</code>-匹配策略三个<code>SPI</code>实现。</p><p>这些扩展类定义在 <strong><em>shenyu-plugin-base</em></strong> module中，经过这样抽象后，每个插件实现中，routing 参数解析的功能全部由AbstractShenyuPlugin 来调用上述三个<code>SPI</code>工厂类来定义和实现。做到了功能的专一，并易于扩展，符合SOLID原则。</p></li></ul><p>本节就其中的<code>PredictJudge</code>-断言做详细解析。可以看到这个module中的pom文件中，添加了对<strong><em>shenyu-<code>SPI</code></em></strong>的依赖</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI xml"><pre tabindex="0" class="prism-code language-xml codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">dependency</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">groupId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">org.apache.shenyu</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">groupId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">artifactId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">shenyu-spi</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">artifactId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">version</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">${project.version}</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">version</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">dependency</span><span class="token tag punctuation" style="color:#393A34">&gt;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="predicatejudge-spi-设计"></a>PredicateJudge <code>SPI</code> 设计<a class="hash-link" href="#predicatejudge-spi-设计" title="Direct link to heading">#</a></h3><p>PredicateJudge <code>SPI</code> 实现用来解析判断各类规则，当网关中配置的。这个类命名和功能都类似于java 的<a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html" target="_blank" rel="noopener noreferrer">Predicate</a>  ，但对接受行为做了更进一步的抽象。这个<code>SPI</code>通过一个工厂和策略模式实现，首先来看<code>PredicateJudge</code> <code>SPI</code>接口的定义：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@SPI</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@FunctionalInterface</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface PredicateJudge {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * judge conditionData and realData is match.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param conditionData {@linkplain ConditionData}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param realData       realData</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return true is pass  false is not pass.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Boolean judge(ConditionData conditionData, String realData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这部分的类图如下：</p><p>Fig 2-Predicate class diagram</p><p><img alt="predicate-class-diagram" src="/zh/assets/images/predicate-class-diagram-67a93b8c3e49800b23fe717c22027c54.png"></p><p><code>PredicateJudgeFactory</code>的重要方法如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    public static PredicateJudge newInstance(final String operator) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ExtensionLoader.getExtensionLoader(PredicateJudge.class).getJoin(processSpecialOperator(operator));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    public static Boolean judge(final ConditionData conditionData, final String realData) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (Objects.isNull(conditionData) || StringUtils.isBlank(realData)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return false;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return newInstance(conditionData.getOperator()).judge(conditionData, realData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这里<code>ConditionData</code>定义如下包含属性四个String类型的属性： <code>paramType, operator,paramName,paramValue</code></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="paramtypeenum"></a>ParamTypeEnum<a class="hash-link" href="#paramtypeenum" title="Direct link to heading">#</a></h4><p>参数 <code>paramType</code>必须为系统中枚举类型 <code>ParamTypeEnum</code>，默认支持的<code>paramType</code>有：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">post, uri,query, host, ip,header, cookie,req_method</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="operatorenum"></a>OperatorEnum<a class="hash-link" href="#operatorenum" title="Direct link to heading">#</a></h4><p> <code>operator</code> 必须为枚举类型 <code>OperatorEnum</code> ，目前支持的操作符有：（注意，严格区分大小写)</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">   match, =,regex, &gt;,&lt;, contains, SpEL,  Groovy, TimeBefore,TimeAfter</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>基于以上的规则, plugin 模组实现了如下8个 <code>PredicateJudge</code> 实现类，分别实现上述operator的逻辑匹配规则.</p><table><thead><tr><th>Implementation class</th><th>Rule denotes 规则说明</th><th>corespondece operator</th></tr></thead><tbody><tr><td><code>ContainsPredicateJudge</code></td><td>包含关系 &quot;contains&quot;， 实际结果，需要包含所定规则的值</td><td>contains</td></tr><tr><td><code>EqualsPredicateJudge</code></td><td>相等&quot;=&quot;，</td><td>=</td></tr><tr><td><code>MatchPredicateJudge</code></td><td>用于URI 路径匹配的处理</td><td>match</td></tr><tr><td><code>TimerAfterPredicateJudge</code></td><td>当前local时间是否晚于设定的时间</td><td>TimeBefore</td></tr><tr><td><code>TimerBeforePredicateJudge</code></td><td>当前local时间是否早于设定的时间</td><td>TimeAfter</td></tr><tr><td><code>GroovyPredicateJudge</code></td><td>Groovy,设定ParamName的值，与设定ParamValue相同</td><td>Groovy</td></tr><tr><td><code>RegexPredicateJudge</code></td><td>正则表达式匹配资料</td><td>regex</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="调用方法"></a>调用方法<a class="hash-link" href="#调用方法" title="Direct link to heading">#</a></h3><p>当要做一组参数的解析时，只需要调用<code>PredicateJudgeFactory</code>的judge方法即可：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">PredicateJudgeFactory.judge(final ConditionData conditionData, final String realData);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="spi配置文件"></a><code>SPI</code>配置文件<a class="hash-link" href="#spi配置文件" title="Direct link to heading">#</a></h3><p>这些<code>PredicateJudge</code>实现类在  <code>SHENYU_DIRECTORY</code> 中的config文件中做了配置，在启动时会加加载并cache到内存中。</p><p><code>PredicateJudge</code>文件的内容如下，为key=class形式，左边的operator要和<code>ParamEnum</code>中的定义一致。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI properties"><pre tabindex="0" class="prism-code language-properties codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">equals=org.apache.shenyu.plugin.base.condition.judge.EqualsPredicateJudge</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">contains=org.apache.shenyu.plugin.base.condition.judge.ContainsPredicateJudge</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Groovy=org.apache.shenyu.plugin.base.condition.judge.GroovyPredicateJudge</span></span><span class="token-line" style="color:#393A34"><span class="token plain">match=org.apache.shenyu.plugin.base.condition.judge.MatchPredicateJudge</span></span><span class="token-line" style="color:#393A34"><span class="token plain">regex=org.apache.shenyu.plugin.base.condition.judge.RegexPredicateJudge</span></span><span class="token-line" style="color:#393A34"><span class="token plain">SpEL=org.apache.shenyu.plugin.base.condition.judge.SpELPredicateJudge</span></span><span class="token-line" style="color:#393A34"><span class="token plain">TimeAfter=org.apache.shenyu.plugin.base.condition.judge.TimerAfterPredicateJudge</span></span><span class="token-line" style="color:#393A34"><span class="token plain">TimeBefore=org.apache.shenyu.plugin.base.condition.judge.TimerBeforePredicateJudge</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="predicatejudge-spi在网关plugin中的使用"></a>PredicateJudge <code>SPI</code>在网关Plugin中的使用<a class="hash-link" href="#predicatejudge-spi在网关plugin中的使用" title="Direct link to heading">#</a></h2><p>网关系统中，大部分的Plugin 都继承自<code>AbstractShenyuPlugin</code>，这个抽象类中，在做选择和规则解析时，调用了上述<code>SPI</code>中的<code>MatchStrategy</code>，继而在策略判断时调用<code>PredicateJudge</code> 的各个断言类来处理。</p><p>Plugin与<code>SPI</code> 的类图如下:</p><p>Fig 3- class diagram of plugins with PredicateJudge and <code>MatchStrategy</code> <code>SPI</code></p><p><img alt="plugin-SPI-class-diagram" src="/zh/assets/images/plugin-SPI-class-diagram-fa432591b833ff178cb662ce352f5b23.png"></p><p>从客户端发来的请求，在系统中调用规则部分的<code>SPI</code>的流程如下：</p><p>Fig 4- flow chart for Shenyu gateway filter  with parameter processing</p><p><img alt="SPI-flow-diagram" src="/zh/assets/images/SPI-flow-diagram-590f2cd298ae7655330a62a2010b006e.png"></p><ul><li>系统启动时，会加载目录下配置的<code>SPI</code>资料到内存中</li><li>当client有新的请求发到Apache shenyu 网关系统时，在网关内部，会调用对应的plugin</li><li>对实际请求资料做规则匹配时，会根据所包含的operator,调用的对应的PredicateJudge实现类</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="其他"></a>其他<a class="hash-link" href="#其他" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="predicatejudge--判断结果举例"></a>PredicateJudge  判断结果举例<a class="hash-link" href="#predicatejudge--判断结果举例" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="containspredicatejudge---contains-rule"></a>ContainsPredicateJudge- &quot; contains“ rule<a class="hash-link" href="#containspredicatejudge---contains-rule" title="Direct link to heading">#</a></h4><p> 举例：给定一组参数（ConditionData ）， paramType=&quot;uri&quot;, paramValue 是 &quot;/http/**&quot;</p><p>当应用 ContainsPredicateJudge包含关系时，判断结果如下表：</p><table><thead><tr><th>ConditionData  (operator=&quot;contains&quot;)</th><th>real data</th><th>judge result</th></tr></thead><tbody><tr><td>paramType=&quot;uri&quot;,    &quot;/http/**&quot;</td><td>&quot;/http/**/test&quot;</td><td>true</td></tr><tr><td></td><td>&quot;/test/http/**/other&quot;</td><td>true</td></tr><tr><td></td><td>&quot;/http1/**&quot;</td><td>false</td></tr></tbody></table><p>其他的几个PredicateJudge的具体功能可参考其代码和测试类.</p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><a class="margin-horiz--sm" href="/zh/blog/tags/spi">SPI</a><a class="margin-horiz--sm" href="/zh/blog/tags/apache-shen-yu">Apache ShenYu</a></div></footer></article><article class="margin-bottom--xl"><header><h2 class="blogPostTitle_d4p0"><a href="/zh/blog/code-analysis-ratelimiter-spi">RateLimiter SPI 代码分析</a></h2><div class="blogPostData_-Im+ margin-vert--md"><time datetime="2021-12-14T03:31:25.749Z">2021年12月14日</time> · One min read</div><div class="avatar margin-vert--md"><div class="avatar__intro"><div class="avatar__name"><a href="https://github.com/changanjennifer/" target="_blank" rel="noopener noreferrer">Huihui Yin</a></div><small class="avatar__subtitle">Apache ShenYu Contributor</small></div></div></header><div class="markdown"><p>限流是网关必备的功能，用来应对高并发请求的场景。当系统受到异常攻击，短期内聚集了大量的流量；当有大量低级别的请求，处理这些请求会影响关键业务的处理，需要限制这些请求的访问速度; 或者系统内部出现一些异常，不能满负荷的服务整个应用请求等等。这些情况下，都需要启用限流来保护系统。可以拒绝服务、等待或降级处理，将流量限制到系统可接受的量，或者只允许某些域名(或某些业务)的请求优先处理。</p><p>   针对以上的场景需求，在设计一个<code>API</code>网关的限流功能时，就需要考虑如下的扩展点：</p><ol><li><p>可以支持多种限流的算法，并易于扩展。</p></li><li><p>要可以支持多种限流的方式，能区分用户群、高低优先级的请求。</p></li><li><p>要支持高并发，能快速的做出限制或通过的决策。</p></li><li><p>要有容错处理，如果限流程序出错，网关系统能继续执行。</p><p>本文会先介绍shenyu网关限流部分的总体技术架构，之后重点分析<code>RateLimiter</code> SPI扩展实现的代码。</p></li></ol><blockquote><p>This article based on <code>shenyu-2.4.0</code> version of the source code analysis.</p></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="ratelimiter--总体设计说明"></a>RateLimiter  总体设计说明<a class="hash-link" href="#ratelimiter--总体设计说明" title="Direct link to heading">#</a></h2><p>​        WebFlux是Spring 提供的基于Reactor模型的异步非阻塞框架，能提升吞吐量，使系统有更好的可伸缩性。Apache Shenyu网关的插件功能基于WebFlux框架实现的。RateLimiter功能是在<code>ratelimiter-plugin</code>中实现。在限流过程中，常用的算法有令牌桶、漏桶等算法，这些算法执行中，需要检核请求的来源，对已使用的流量做计数及逻辑计算，判定是否允许通过。为了提高并发及性能， 将计数和算法逻辑处理，都放到redis中。Java代码负责做数据参数的传递。在调用redis时，<a href="https://www.lua.org/" target="_blank" rel="noopener noreferrer">lua</a>脚本可以常驻在redis内存中，能减少网络开销，并可以作为一个整体执行，具有原子性。<a href="https://spring.io/projects/spring-data-redis" target="_blank" rel="noopener noreferrer">Spring Data Redis</a> 提供了对<a href="https://redis.io/commands" target="_blank" rel="noopener noreferrer">redis命令</a>执行的抽象，执行序列化，及自动使用redis 脚本缓存。在这个plugin中，由于采用了reactor 非阻塞框架，所以采用Spring Redis Reactive类库实现对redis的功能调用。</p><p>​        这个plugin中的类包图如下，重点标出了与<code>RateLimiter</code> <code>SPI</code>相关的两个package: resolver 和algorithm.</p><p><img alt="ratelimiter-package-diagram" src="/zh/assets/images/ratelimiter-package-diagram-b041571cdf2f8592c23ab33bf07fbc71.png"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="ratelimiter-spi的设计"></a>RateLimiter SPI的设计<a class="hash-link" href="#ratelimiter-spi的设计" title="Direct link to heading">#</a></h2><p>由于采用了Spring data+ Redis +lua架构实现了高并发的需求。 如何做到对算法和限流方式的扩展呢？ Shenyu ratelimiter  plugin中设计了两个SPI来实现这两个需求：</p><ul><li><code>RateLimiterAlgorithm</code>：用来扩展不同的限流算法。</li><li><code>RateLimiterKeyResolver</code>： 用于扩展获取请求的关键信息，用于区分流量，例如按IP 地址、按某一段域名等来区分访问的请求。</li></ul><p>SPI的具体实作类与配置信息位于：<code>SHENYU_DIRECTORY</code>目录下 (默认在<code>/META-INF/shenyu</code>)下。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="ratelimiterkeyresolver"></a>RateLimiterKeyResolver<a class="hash-link" href="#ratelimiterkeyresolver" title="Direct link to heading">#</a></h3><p>获取请求的关键信息，用于分组限流，例如按URL/ 用户 / IP 等， <code>RateLimiterKeyResolver</code> 接口定义如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@SPI</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface RateLimiterKeyResolver {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * get Key resolver&#x27;s name.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return Key resolver&#x27;s name</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    String getKeyResolverName();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * resolve.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param exchange exchange the current server exchange {@linkplain ServerWebExchange}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return rate limiter key</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    String resolve(ServerWebExchange exchange);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><code>@SPI</code>将当前interface 注册为Shenyu SPI 接口。resolve(ServerWebExchange exchange)方法用来提供解析方式。</p><p>RateLimiterKeyResolver  SPI 提供了两种key resolver, <code>WholeKeyResolve</code>和 <code>RemoteAddrKeyResolver</code>，其中<code>RemoteAddrKeyResolver</code>中的<code>resolve</code>方法代码如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String resolve(final ServerWebExchange exchange) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Objects.requireNonNull(exchange.getRequest().getRemoteAddress()).getAddress().getHostAddress();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>其key值为请求的IP地址。 基于SPI及工厂类的实现，可以非常方便的扩展实现新的key resolver，如URL,用户等等。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="ratelimiteralgorithm-spi"></a>RateLimiterAlgorithm SPI<a class="hash-link" href="#ratelimiteralgorithm-spi" title="Direct link to heading">#</a></h3><p><code>RateLimiterAlgorithm</code> SPI 用来实现对不同限流算法的识别、加载和定义，其类图如下：</p><p><img alt="ratelimiteral-class-diagram" src="/zh/assets/images/ratelimiteral-class-diagram-24df4785848602bdc5b321cf609d5cda.png"></p><p>本模组使用了工厂模式，提供了接口类、抽象类和工厂类，提供了4个实现类，其中实现类对应的Lua脚本在 <code>RateLimitEnum</code> 中做了定义，放置在 <code>/META-INF/scripts</code> 目录下。接口<code>RateLimiterAlgorithm</code>的代码如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@SPI</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface RateLimiterAlgorithm&lt;T&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    RedisScript&lt;T&gt; getScript();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    List&lt;String&gt; getKeys(String id);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Callback string.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param script the script</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param keys the keys</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param scriptArgs the script args</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    default void callback(final RedisScript&lt;?&gt; script, final List&lt;String&gt; keys, final List&lt;String&gt; scriptArgs) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><code>@SPI</code> 将这个接口注册为shenyu SPI, 其中定义了三个方法：</p><ul><li><code>getScript()</code> 方法返回一个 <code>RedisScript</code>对象，这个对象将传递给Redis。</li><li><code>getKeys(String id)</code> 返回一个键值的List.</li><li><code>callback()</code>回调函数用于异步处理一些需要在返回后做的处理，缺省是空方法。</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="抽象类-abstractratelimiteralgorithm"></a>抽象类 AbstractRateLimiterAlgorithm<a class="hash-link" href="#抽象类-abstractratelimiteralgorithm" title="Direct link to heading">#</a></h4><p>在这个类中，实现了接口的模板方法，使用参数类型为<code>List&lt;Long&gt;</code>,  抽象方法getScriptName() 和getKeyName() 留给各个实作类来实现。如下的getScript() 是这个类中读取lua脚本的处理代码。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    public RedisScript&lt;List&lt;Long&gt;&gt; getScript() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!this.initialized.get()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            DefaultRedisScript redisScript = new DefaultRedisScript&lt;&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            String scriptPath = &quot;/META-INF/scripts/&quot; + getScriptName();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            redisScript.setScriptSource(new ResourceScriptSource(new ClassPathResource(scriptPath)));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            redisScript.setResultType(List.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.script = redisScript;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            initialized.compareAndSet(false, true);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return redisScript;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return script;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><code>AtomicBoolean</code>类型的变量<code>initialized</code> 用来标记lua脚本是否有被加载。 如果还没有加载，就从/META-INF/scripts/目录下，读取<code>scriptName</code>指定的Lua文件，加载成<code>RedisScript</code>对象。指定结果为<code>List</code>类型， 设定量<code>initialized</code>为true,避免重复加载。 返回 <code>RedisScript</code>对象。</p><p><code>AbstractRateLimiterAlgorithm</code>中<code>getKeys()</code>的代码如下，</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public List&lt;String&gt; getKeys(final String id) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String prefix = getKeyName() + &quot;.{&quot; + id;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String tokenKey = prefix + &quot;}.tokens&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String timestampKey = prefix + &quot;}.timestamp&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Arrays.asList(tokenKey, timestampKey);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这个模板方法中，产生了两个字符串，其中，<code>tokenKey</code>会作为Key传递给<code>redis</code>, 指向一个有序集合。 <code>timestampKey</code>是一个以传入id 为识别的字符串。</p><p>可以从上面的类图中看到，<code>ConcurrentRateLimiterAlgorithm</code> 和<code>SlidingWindowRateLimiterAlgorithm</code> 有覆写<code>getKeys(String id)</code>方法，而两外两个算法程序，则采用的是抽象类中的实现。也只有 <code>ConcurrentRateLimiterAlgorithm</code> 重写了<code>callback()</code>方法。下文中我们会对此做进一步的分析。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="工厂类ratelimiteralgorithmfactory"></a>工厂类RateLimiterAlgorithmFactory<a class="hash-link" href="#工厂类ratelimiteralgorithmfactory" title="Direct link to heading">#</a></h4><p><code>RateLimiterAlgorithmFactory</code> 中依据算法名称，获取RateLimiterAlgorithm实例的方法代码如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public static RateLimiterAlgorithm&lt;?&gt; newInstance(final String name) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return Optional.ofNullable(ExtensionLoader.getExtensionLoader(RateLimiterAlgorithm.class).getJoin(name)).orElse(new TokenBucketRateLimiterAlgorithm());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>按照Apache shenyu SPI的规则，由加载器<code>ExtensionLoader</code>获得实作类，当找不到算法时，默认返回令牌桶算法实现类。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="与redis做资料交互"></a>与Redis做资料交互<a class="hash-link" href="#与redis做资料交互" title="Direct link to heading">#</a></h3><p>从上面代码我们了解到Apache Shenyu网关中，RateLimiter SPI 的基本扩展点，在Shenyu网关运行中，应用ReactiveRedisTemplate 来异步执行对redis的调用处理。实现代码在RedisRateLimiter类的isAllowed()方法中，其部分代码如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    public Mono&lt;RateLimiterResponse&gt; isAllowed(final String id, final RateLimiterHandle limiterHandle) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // get parameters that will pass to redis from RateLimiterHandle Object</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        double replenishRate = limiterHandle.getReplenishRate();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        double burstCapacity = limiterHandle.getBurstCapacity();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        double requestCount = limiterHandle.getRequestCount();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // get the current used RateLimiterAlgorithm</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        RateLimiterAlgorithm&lt;?&gt; rateLimiterAlgorithm = RateLimiterAlgorithmFactory.newInstance(limiterHandle.getAlgorithmName());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ........</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Flux&lt;List&lt;Long&gt;&gt; resultFlux = Singleton.INST.get(ReactiveRedisTemplate.class).execute(script, keys, scriptArgs);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return resultFlux.onErrorResume(throwable -&gt; Flux.just(Arrays.asList(1L, -1L)))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .reduce(new ArrayList&lt;Long&gt;(), (longs, l) -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    longs.addAll(l);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return longs;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }).map(results -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    boolean allowed = results.get(0) == 1L;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Long tokensLeft = results.get(1);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return new RateLimiterResponse(allowed, tokensLeft);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                })</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .doOnError(throwable -&gt; log.error(&quot;Error occurred while judging if user is allowed by RedisRateLimiter:{}&quot;, throwable.getMessage()))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .doFinally(signalType -&gt; rateLimiterAlgorithm.callback(script, keys, scriptArgs));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>POJO 对象RateLimiterHandle 中，定义了限流所需的属性算法名称, 速录，容量，请求的数量 。首先 从limiterHandle 包装类中取得需要传入redis的几个参数。之后从RateLimiterAlgorithmFactory 从工厂类取得当前配置的限流算法。 之后做Key值和参数的传递。</p><p>为了更方便阅读，下图给出了java代码与redis执行参数输入、输出的传递过程。左边是<code>isAllowed</code>() 函数的后半部分代码，右边是一个Lua脚本的输入输出代码。</p><p>下面说明Java代码的执行过程：</p><ol><li><p>从<code>getKeys()</code>方法获得两个键值<code>List&lt;String&gt;</code>. 其中第一个Key会映射为Redis中的有序集合。</p></li><li><p>设定4个参数：速率 replenishRate ,容量 burstCapacity, 时间戳， 返回当前java 纪元秒数(长整数)EpochSecond, 请求的数量 requestcount.</p></li><li><p>按所设定的脚本、Key值、参数调用<code>ReactiveRedisTemplate</code>功能，执行redis处理。返回参数是<code>Flux&lt;List&lt;Long&gt;&gt;</code>类型</p></li><li><p>通过reduce方法将其返回值从<code>Flux&lt;ArrayList&lt;Long&gt;&gt;</code> 类型转换为<code>Mono&lt;ArrayList&lt;Long&gt;&gt;</code>，再经过map方法，转换为<code>Mono&lt;RateLimiterResponse&gt;</code>返回。</p><p> 返回结果有两个资料，allowed =1, 代表允许通过，0-不通过；而第二个返回参数tokensLeft，是可用的剩余请求数量。</p></li></ol><p>5.容错性方面，由于使用的是reactor 的非阻塞通讯模型，当发生错误时，会执行onErrorResume()语句，Flux.just产生返回资料， 默认为<code>allowed</code>=1, 代表允许通过， 并丢出错误日志。</p><p>6.之后执行doFinally()方法,执行算法实现类的callback方法。</p><p><img alt="io-with-lua" src="/zh/assets/images/io-with-lua-eefcd28d4b59a8bd0e69e29400018c50.png"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="4种限流算法"></a>4种限流算法<a class="hash-link" href="#4种限流算法" title="Direct link to heading">#</a></h2><p>上面我们了解了网关中如何通过Java代码如何与Redis 做通讯，这一节我们通过简要分析网关中提供的4种限流算法中的一些代码，来理解如何开发使用<code>RateLimiter SPI</code>的接口方法,并与Redis有效协作。</p><p><code>Ratelimiter SPI</code>目前提供了4种限流算法:</p><table><thead><tr><th>Algorithm name</th><th>Java class</th><th>Lua script file</th></tr></thead><tbody><tr><td>Request rate limiter</td><td><code>TokenBucketRateLimiterAlgorithm</code></td><td>request_rate_limiter.lua</td></tr><tr><td>Slide window rate limiter</td><td><code>SlidingWindowRateLimiterAlgorithm</code></td><td>liding_window_request_rate_limiter.lua</td></tr><tr><td>Concurrent rate limiter</td><td><code>ConcurrentRateLimiterAlgorithm</code></td><td>concurrent_request_rate_limiter.lua</td></tr><tr><td>Leaky bucket algorithm</td><td><code>LeakyBucketRateLimiterAlgorithm</code></td><td>request_leaky_rate_limiter.lua</td></tr></tbody></table><ol><li>令牌桶限流：按请求数量限流，设置每秒N个请求，超过N的请求会拒绝服务。算法实现时，以时间间隔计算匀速产生令牌的数量。若每次请求的数量，小于桶内令牌的数量，则允许通过。 时间窗口为 2*容积/速率。</li><li>滑动窗口限流：与令牌桶限流不同在于，其窗口大小比令牌桶的窗口小，为一个容积/速率。并且每次移动向后一个时间时间窗口。其他限流原理与令牌桶类似。</li><li>并发的请求速率限流：严格限制并发访问量为N个请求，大于N的请求会被拒绝。每次当有新请求，查看计数是否大于N, 若小于N则允许通过，计数加1。 当这个请求调用结束时，会释放这个信号（计数减1）</li><li>漏桶算法:  相对于令牌桶算法，漏桶算法有助于减少流量聚集，实现更为平滑的限流处理。 漏桶算法强制以常数N的速率输出流量，其以漏桶为模型，可漏水的量为时间间隔 *速率。若可漏水量&gt;已使用量，则已使用量设为0( 清空漏桶)，否则已使用量要减去可漏水量。  若请求数量+ 已使用量&lt; 总容量，则允许请求通过。</li></ol><p>下面以 并行限流算法为例，解读Lua和Java代码，查看callback 方法的使用。 通过解读令牌桶和滑动窗口算法代码，了解getKey()方法的使用。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="并发请求数限流中使用callback方法"></a>并发请求数限流中使用callback方法<a class="hash-link" href="#并发请求数限流中使用callback方法" title="Direct link to heading">#</a></h3><p>首先<code>ConcurrentRateLimiterAlgorithm</code> 的<code>getKeys()</code> 方法覆写了抽象类中的模板方法：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public List&lt;String&gt; getKeys(final String id) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String tokenKey = getKeyName() + &quot;.{&quot; + id + &quot;}.tokens&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String requestKey = UUIDUtils.getInstance().generateShortUuid();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Arrays.asList(tokenKey, requestKey);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>第二个元素 requestKey 是一个long型不重复值(由一个分布式ID产生器产生的，递增，比当前时间EpochSecond小)， 相应的concurrent_request_rate_limiter.lua的代码：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI lua"><pre tabindex="0" class="prism-code language-lua codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">local key = KEYS[1]</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">local capacity = tonumber(ARGV[2])</span></span><span class="token-line" style="color:#393A34"><span class="token plain">local timestamp = tonumber(ARGV[3])</span></span><span class="token-line" style="color:#393A34"><span class="token plain">local id = KEYS[2]</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这里id 即是取得上面的getKeys()方法产生的requestKey， 一个uuid.  后续的处理如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI lua"><pre tabindex="0" class="prism-code language-lua codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">local count = redis.call(&quot;zcard&quot;, key)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">local allowed = 0</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">if count &lt; capacity then</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  redis.call(&quot;zadd&quot;, key, timestamp, id)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  allowed = 1</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  count = count + 1</span></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span></span><span class="token-line" style="color:#393A34"><span class="token plain">return { allowed, count }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>先用zcard命令统计redis中key值所对应的有序集合中的元素个数，若元素总数count小于容量，则允许通过，并用zadd key score member方法，向key所在的有序集合中，添加一个元素id, 其score为timestamp.  则此时元素的总个数count实际为count+1.  </p><p>以上的代码都是在redis中作为一个原子操作来执行的。当同一个key (例如Ip下)有大量并发请求时，redis记录的该ip的有序集合的数量count也在不断累加中。当超过容量限制，则会拒绝服务。</p><p>并发请求数限流算法中，要求当请求调用结束时，要释放这个信号量，lua代码中并没有做这个处理。</p><p>我们来看看 <code>ConcurrentRateLimiterAlgorithm</code>类中的回调函数：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @SuppressWarnings(&quot;unchecked&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void callback(final RedisScript&lt;?&gt; script, final List&lt;String&gt; keys, final List&lt;String&gt; scriptArgs) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Singleton.INST.get(ReactiveRedisTemplate.class).opsForZSet().remove(keys.get(0), keys.get(1)).subscribe();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这里做了一个异步的订阅处理，通过<code>ReactiveRedisTemplate</code>删除redis中(key, id)的元素，等待调用结束后，释放这个信号。这个remove的处理不能放到lua脚本中执行，否则逻辑就是错误的。这也正是<code>RateLimiterAlgorithm</code> SPI 设计<code>callback</code>方法的用意。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="令牌桶算法中使用getkeys"></a>令牌桶算法中使用getKeys()<a class="hash-link" href="#令牌桶算法中使用getkeys" title="Direct link to heading">#</a></h3><p>对应的Lua 代码如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">local tokens_key = KEYS[1]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">local timestamp_key = KEYS[2]</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>省略获取参数的代码</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI lua"><pre tabindex="0" class="prism-code language-lua codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">local fill_time = capacity/rate</span></span><span class="token-line" style="color:#393A34"><span class="token plain">local ttl = math.floor(fill_time*2)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>时间窗口ttl 大概是 2* 容量/速率.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI lua"><pre tabindex="0" class="prism-code language-lua codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">local last_tokens = tonumber(redis.call(&quot;get&quot;, tokens_key))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">if last_tokens == nil then</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  last_tokens = capacity</span></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>从有序集合中取得上次使用的token,如果没有则last_tokens = 容量。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI lua"><pre tabindex="0" class="prism-code language-lua codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">local last_refreshed = tonumber(redis.call(&quot;get&quot;, timestamp_key))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">if last_refreshed == nil then</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  last_refreshed = 0</span></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>以timestamp_key为key,从有序集合中取得上次刷新时间，默认为0.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI lua"><pre tabindex="0" class="prism-code language-lua codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">local delta = math.max(0, now-last_refreshed)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">local filled_tokens = math.min(capacity, last_tokens+(delta*rate))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">local allowed = filled_tokens &gt;= requested</span></span><span class="token-line" style="color:#393A34"><span class="token plain">local allowed_num = 0</span></span><span class="token-line" style="color:#393A34"><span class="token plain">if allowed then</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  new_tokens = filled_tokens - requested</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  allowed_num = 1</span></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>时间间隔*速率匀速产生令牌，若令牌数量&gt;请求数量，则allowed=1, 并且更新令牌数量。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI lua"><pre tabindex="0" class="prism-code language-lua codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">redis.call(&quot;setex&quot;, tokens_key, ttl, new_tokens)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">redis.call(&quot;setex&quot;, timestamp_key, ttl, now)</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">return { allowed_num, new_tokens }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这里now是传入的当前时间(EpochSecond)，设置<code>tokens_key</code>所对应的有序集合的值为 <code>new_tokens</code>（即新令牌数量) ， 过期时间为<code>ttl</code>。 更新集合中，<code>timestamp_key</code>的值为当前时间，过期时间为<code>ttl</code>.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="滑动窗口算法中使用getkeys方法"></a>滑动窗口算法中使用<code>getKeys</code>方法<a class="hash-link" href="#滑动窗口算法中使用getkeys方法" title="Direct link to heading">#</a></h3><p>在<code>SlidingWindowRateLimiterAlgorithm</code> 的<code>getKeys()</code>同样覆写了父类，代码与<code>ConcurrentRateLimiterAlgorithm</code> 方法代码一致。</p><p>如下为滑动窗口算法的Lua代码，省略了其他参数的接收代码。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI lua"><pre tabindex="0" class="prism-code language-lua codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">local timestamp_key = KEYS[2]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">...... </span></span><span class="token-line" style="color:#393A34"><span class="token plain">local window_size = tonumber(capacity / rate)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">local window_time = 1</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>设定窗口大小为容积/速率。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI lua"><pre tabindex="0" class="prism-code language-lua codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">local last_requested = 0</span></span><span class="token-line" style="color:#393A34"><span class="token plain">local exists_key = redis.call(&#x27;exists&#x27;, tokens_key)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">if (exists_key == 1) then</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    last_requested = redis.call(&#x27;zcard&#x27;, tokens_key)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>获取当前key 的基数</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI lua"><pre tabindex="0" class="prism-code language-lua codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">local remain_request = capacity - last_requested</span></span><span class="token-line" style="color:#393A34"><span class="token plain">local allowed_num = 0</span></span><span class="token-line" style="color:#393A34"><span class="token plain">if (last_requested &lt; capacity) then</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    allowed_num = 1</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    redis.call(&#x27;zadd&#x27;, tokens_key, now, timestamp_key)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>计算剩余可用量 = 容量 减去已使用量，若<code>last_requested</code> &lt; capacity ,则允许通过，并且在<code>tokens_key</code>为key的有序集合中，增加一个 元素（key =<code>timestam_key</code>,value= <code>now</code>)</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI lua"><pre tabindex="0" class="prism-code language-lua codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">redis.call(&#x27;zremrangebyscore&#x27;, tokens_key, 0, now - window_size / window_time)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">redis.call(&#x27;expire&#x27;, tokens_key, window_size)</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">return { allowed_num, remain_request }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>前面已经设定<code>window_time</code>=1, 用Redis的 <code>zremrangebyscore</code>命令，移除有序集合中，score为[0- 当前时间-窗口大小]的元素，即移动一个窗口大小。设定tokens_key的过期时间为窗口大小。</p><p>在<code>AbstractRateLimiterAlgorithm</code>的模板方法中，<code>getKeys(final String id)</code> 给出的第二个值(以<code>secondKey</code>指代)，是拼接了{id} (即resolve key)的一个固定字符串。从上面三个算法代码可以看到，在令牌桶算法中，<code>secondKey</code>在Lua代码执行中会更新为最新的时间，所以无所谓传入的值。而在并发限流算法中，会以此<code>secondKey</code>为条件，在java <code>callback</code>方法中移除对应的元素。而在滑动窗口算法中，这个<code>secondKey</code>的值，会作为一个新元素的key, 增加到当前有序集合中，并在做窗口滑动中，过期的资料会被删除掉。</p><p>总之，当设计新的限流算法时，要根据算法需要仔细设计<code>getKey()</code>方法。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="如何调用-ratelimiter-spi"></a>如何调用 RateLimiter SPI<a class="hash-link" href="#如何调用-ratelimiter-spi" title="Direct link to heading">#</a></h2><p>在<code>RateLimiter</code> Plug中的<code>doExecute()</code>方法中，传入的三个参数 exchange 为请求的连接， chain 为shenyu插件的调用链，selector 是选择器，rule是系统中配置的规则参数资料。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">protected Mono&lt;Void&gt; doExecute(final ServerWebExchange exchange, final ShenyuPluginChain chain, final SelectorData selector, final RuleData rule) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    RateLimiterHandle limiterHandle = RatelimiterRuleHandleCache.getInstance()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        .obtainHandle(CacheKeyUtils.INST.getKey(rule));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    String resolverKey = Optional.ofNullable(limiterHandle.getKeyResolverName())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        .flatMap(name -&gt; Optional.of(&quot;-&quot; + RateLimiterKeyResolverFactory.newInstance(name).resolve(exchange)))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        .orElse(&quot;&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return redisRateLimiter.isAllowed(rule.getId() + resolverKey, limiterHandle)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        .flatMap(response -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!response.isAllowed()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                exchange.getResponse().setStatusCode(HttpStatus.TOO_MANY_REQUESTS);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                Object error = ShenyuResultWrap.error(ShenyuResultEnum.TOO_MANY_REQUESTS.getCode(), ShenyuResultEnum.TOO_MANY_REQUESTS.getMsg(), null);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                return WebFluxResultUtils.result(exchange, error);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return chain.execute(exchange);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>1.首先，从缓存中，取得系统设定的限流参数<code>RateLimiterHandle</code>实例 <code>limiterHandle</code>.
2.根据name指定的Resolver 获得请求的连接Key信息（如地址等).
3.调用 RedisRateLimiter的 isAllowed方法, 获取返回值后，
4.若<code>isAllowd</code>=false,做错误处理
5.如果 <code>isAllowed</code>=true，return chain.execute(exchange)， 对该请求做后续处理，传递到调用链的下一关。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="summary"></a>Summary<a class="hash-link" href="#summary" title="Direct link to heading">#</a></h2><p>整个<code>RateLimiter</code> plugin框架基于Spring WebFlux开发，用redis 和lua脚本做限流计数及核心逻辑处理，支持高并发及弹性扩展。</p><ol><li><p><code>RateLimiter</code> <code>SPI</code> 提供了两个<code>SPI</code> 接口，通过应用面向接口设计及各种设计模式，可以方便的增加新的限流算法，以及各种流量解析规则。</p></li><li><p>提供了令牌桶、并发速率限流、滑动窗口、漏桶4种限流算法。在设计算法实现时，需要根据算法特征设计KEY值，用Lua脚本实现在redis中要处理的逻辑，设计<code>callback()</code>方法做后续的数据处理。</p></li><li><p>响应式编程，实现过程简洁高效。</p></li></ol></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><a class="margin-horiz--sm" href="/zh/blog/tags/rate-limiter">rate limiter</a><a class="margin-horiz--sm" href="/zh/blog/tags/spi">SPI</a><a class="margin-horiz--sm" href="/zh/blog/tags/apache-shen-yu">Apache ShenYu</a></div></footer></article><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/zh/blog/page/2"><div class="pagination-nav__label">Older Entries »</div></a></div></nav></main></div></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">ShenYu</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/zh/download">下载</a></li><li class="footer__item"><a class="footer__link-item" href="/zh/docs/index">文档</a></li><li class="footer__item"><a class="footer__link-item" href="/zh/news">新闻</a></li><li class="footer__item"><a class="footer__link-item" href="/zh/blog">博客</a></li><li class="footer__item"><a href="https://github.com/apache/incubator-shenyu/releases" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>版本<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">社区</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/zh/community/subscribe-email">社区</a></li><li class="footer__item"><a href="https://github.com/apache/incubator-shenyu" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://github.com/apache/incubator-shenyu/issues" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Issue Tracker<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">订阅邮件组</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/zh/community/subscribe-email">如何订阅</a></li><li class="footer__item"><a href="mailto://dev-subscribe@shenyu.apache.org" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>订阅邮件<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://lists.apache.org/list.html?dev@shenyu.apache.org" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>邮件归档<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright"><div><img style="height:50px" alt="Apache Software Foundation" src="/img/incubator-logo.png"><p style="color:#ffffffcf;font-size:14px;text-align:left">Apache ShenYu is an effort undergoing incubation at The Apache Software Foundation (ASF), sponsored by the Apache Incubator. Incubation is required of all newly accepted projects until a further review indicates that the infrastructure, communications, and decision making process have stabilized in a manner consistent with other successful ASF projects. While incubation status is not necessarily a reflection of the completeness or stability of the code, it does indicate that the project has yet to be fully endorsed by the ASF.</p>
      <p style="color:white;font-size:14px;"> Copyright © 2021 The Apache Software Foundation. Licensed under the Apache License, Version 2.0. Apache ShenYu, Apache Incubator, Apache, the Apache feather logo, the Apache ShenYu logo and the Apache Incubator project logo are trademarks of The Apache Software Foundation.</p>
      <div></div></div></div></div></div></footer></div>
<script src="/zh/assets/js/runtime~main.9f932cca.js"></script>
<script src="/zh/assets/js/main.26b40e3d.js"></script>
</body>
</html>