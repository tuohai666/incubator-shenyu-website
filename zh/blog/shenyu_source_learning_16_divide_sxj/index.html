<!doctype html><html><head><title>Apache ShenYu网关学习divide插件源码解读 · Apache ShenYu</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="The girl on the prairie"><meta name=generator content="Hugo 0.55.5"><link rel="shortcut icon" href=/img/favicon.png type=image/png><link href=https://unpkg.com/purecss@1.0.0/build/base-min.css rel=stylesheet><link href=/css/main.css rel=stylesheet><link href=/css/zoom-image.css rel=stylesheet><script src=/js/iconfont.js></script><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script><script>window.SITE_LANGUAGE="zh"</script><script src=/js/app.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-187960192-2','auto');ga('send','pageview');}</script></head><body><header class=ss-header><nav class=navbar role=navigation aria-label="main navigation"><div class=navbar-brand><a class=logo-link style=font-size:25px;margin-right:50px href=/zh/><img class=logo src=/img/logo/apache-shenyu.png></a><div class=-show-mobile><a id=mobile-menu-icon><svg class="icon" aria-hidden="true"><use xlink:href="#icon-menu"/></svg></a><nav id=mobile-menu><div id=js-menu-search-mobile class=navbar-search-mobile><input class=input placeholder=请输入要搜索的关键词><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div><a href=/zh/projects/shenyu/download/><span>下载</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/projects/shenyu/overview/><span>文档</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/community/subscribe-email/><span>社区</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/news/><span>新闻</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/awesome/><span>Awesome</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/blog/shenyu_source_learning_16_divide_sxj/><span>English</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-transfer"/></svg></a></nav></div></div><div class="navbar-menu -hidden-mobile"><div class=navbar-start><a class=navbar-item href=/zh/projects/shenyu/download/>下载</a>
<a class=navbar-item href=/zh/projects/shenyu/overview/>文档</a>
<a class=navbar-item href=/zh/community/subscribe-email/>社区</a>
<a class=navbar-item href=/zh/news/>新闻</a>
<a class=navbar-item href=/zh/awesome/>Awesome</a>
<span class="navbar-item nav-hover"><a>Links</a><div class=dropdown-menu><a class=dropdown-item href=https://www.apache.org/>Apache Software Foundation</a>
<a class=dropdown-item href=https://github.com/apache/incubator-shenyu/issues>GitHub Issue Tracker</a>
<a class=dropdown-item href=https://www.apache.org/>License</a>
<a class=dropdown-item href=http://www.apache.org/events/current-event>Apache Events</a>
<a class=dropdown-item href=https://www.apache.org/licenses/>Security</a>
<a class=dropdown-item href=http://www.apache.org/foundation/sponsorship.html>Sponsor and Donate</a>
<a class=dropdown-item href=http://www.apache.org/foundation/thanks.html>Thanks</a></div></span></div><div class=navbar-end><div class=navbar-item><div id=js-menu-search class=navbar-search><input class=input placeholder=请输入要搜索的关键词><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div></div><div class=navbar-item><a class=translation href=/blog/shenyu_source_learning_16_divide_sxj/>En</a></div></div></div></nav></header><div class=ss-layout-container><main class="ss-layout-main -card"><div class=ss-meta><h1 class=title>Apache ShenYu网关学习divide插件源码解读</h1><div class=meta>2021-02-01 ·
沈祥俊 ·
<span class=tags><a class=tag href=/zh/tags/apache-shenyu/ rel=tag>#Apache ShenYu</a></span></div></div><article class=typo><h2 id=插件概述>插件概述</h2><p><strong>插件定位</strong></p><p>divide 插件是一个 http 正向代理插件，所有的 http 请求都由该插件进行负载均衡处理（具体的负载均衡策略在规则中指定）。</p><p><strong>生效时机</strong></p><p>当请求头的 rpcType = http 且插件开启时，它将根据请求参数匹配规则，最终交由下游插件进行响应式代理调用。</p><h2 id=插件处理流程>插件处理流程</h2><p>1）先回顾下请求处理类插件的通用流程（AbstractSoulPlugin # execute）：</p><pre><code class=language-java>public Mono&lt;Void&gt; execute(final ServerWebExchange exchange, final SoulPluginChain chain) {
    // 获取插件数据
    String pluginName = named();
    final PluginData pluginData = BaseDataCache.getInstance().obtainPluginData(pluginName);
    if (pluginData != null &amp;&amp; pluginData.getEnabled()) {
        // 获取选择器数据
        final Collection&lt;SelectorData&gt; selectors = BaseDataCache.getInstance().obtainSelectorData(pluginName);
        ...
        // 匹配选择器
        final SelectorData selectorData = matchSelector(exchange, selectors);
        ...
        // 获取规则数据
        final List&lt;RuleData&gt; rules = BaseDataCache.getInstance().obtainRuleData(selectorData.getId());
        ...
        // 匹配规则
        RuleData rule;
        if (selectorData.getType() == SelectorTypeEnum.FULL_FLOW.getCode()) {
            //get last
            rule = rules.get(rules.size() - 1);
        } else {
            rule = matchRule(exchange, rules);
        }
        ...
        // 执行自定义处理
        return doExecute(exchange, chain, selectorData, rule);
    }
    // 继续执行插件链处理
    return chain.execute(exchange);
}
</code></pre><p>AbstractSoulPlugin 先匹配到对应的选择器和规则，匹配通过则执行插件的自定义处理。</p><p>2）再来看看 divide 插件的自定义处理流程（DividePlugin # doExecute）：</p><pre><code class=language-java>protected Mono&lt;Void&gt; doExecute(final ServerWebExchange exchange, final SoulPluginChain chain, final SelectorData selector, final RuleData rule) {
    ...
    // 准备规则处理对象（内部持有：负载均衡算法名、重试次数以及超时时间）
    final DivideRuleHandle ruleHandle = GsonUtils.getInstance().fromJson(rule.getHandle(), DivideRuleHandle.class);
    // 获取选择器对应的可用服务列表
    final List&lt;DivideUpstream&gt; upstreamList = UpstreamCacheManager.getInstance().findUpstreamListBySelectorId(selector.getId());
    ...
    // 选择具体分发的服务实例ip（负载均衡）
    final String ip = Objects.requireNonNull(exchange.getRequest().getRemoteAddress()).getAddress().getHostAddress();
    DivideUpstream divideUpstream = LoadBalanceUtils.selector(upstreamList, ruleHandle.getLoadBalance(), ip);
    ...
    //设置 http url、超时时间以及重试次数
    String domain = buildDomain(divideUpstream);
    String realURL = buildRealURL(domain, soulContext, exchange);
    exchange.getAttributes().put(Constants.HTTP_URL, realURL);
    exchange.getAttributes().put(Constants.HTTP_TIME_OUT, ruleHandle.getTimeout());
    exchange.getAttributes().put(Constants.HTTP_RETRY, ruleHandle.getRetry());
    // 继续执行插件链处理
    return chain.execute(exchange);
}
</code></pre><p>DividePlugin 先获取到选择器对应的可用服务列表，然后进行负载均衡选择即将分发的目标服务器实例ip，最后设置最终的 url、超时时间以及重试次数并交由插件链下游进行处理。</p><p><strong>注意：</strong></p><p>divide 插件自身只是负责根据选择器、规则和负载均衡策略选出待分发的服务器实例，并不直接向后端服务发起 http 请求。</p><h2 id=主机探活>主机探活</h2><p>上面提到，divide 需要获取服务列表，看下获取的实现（UpstreamCacheManager # findUpstreamListBySelectorId）：</p><pre><code class=language-java>public List&lt;DivideUpstream&gt; findUpstreamListBySelectorId(final String selectorId) {
    return UPSTREAM_MAP_TEMP.get(selectorId);
}
</code></pre><p>内部通过 UPSTREAM_MAP_TEMP 获取存活服务列表。</p><p>UpstreamCacheManager 内部维护了两份散列表：</p><ul><li>UPSTREAM_MAP：</li></ul><p>全量服务散列表，负责存放全量的上游服务信息，key 为 选择器 id，value 为使用相同选择器的服务列表。</p><ul><li>UPSTREAM_MAP_TEMP：</li></ul><p>临时服务散列表，负责存放活动的上游服务信息，key 为 选择器 id，value 为使用相同选择器的服务列表。</p><p>前面章节我们提到，数据同步时，submit 方法同时更新了 UPSTREAM_MAP 和 UPSTREAM_MAP_TEMP，但后续服务下线如何维护 UPSTREAM_MAP_TEMP 呢，一切还得从 ip 探活说起。</p><h4 id=3-1-探活时机>3.1 探活时机</h4><p>探活时机得从 UpstreamCacheManager 初始化说起：</p><pre><code class=language-java>private UpstreamCacheManager() {
    // 探活开关检查
    boolean check = Boolean.parseBoolean(System.getProperty(&quot;soul.upstream.check&quot;, &quot;false&quot;));
    if (check) {
        // 启动定时探活任务
        new ScheduledThreadPoolExecutor(1, SoulThreadFactory.create(&quot;scheduled-upstream-task&quot;, false))
                .scheduleWithFixedDelay(this::scheduled,
                        30, Integer.parseInt(System.getProperty(&quot;soul.upstream.scheduledTime&quot;, &quot;30&quot;)), TimeUnit.SECONDS);
    }
}
</code></pre><p>UpstreamCacheManager 初始化时，若探活开关打开，则创建定时探活任务，此处默认 30 秒执行一次。</p><p>此处共涉及到两个配置参数：</p><ul><li>soul.upstream.check 探活开关：默认为 ture，设置为false表示不检测</li><li>soul.upstream.scheduledTime 探活时间间隔，默认10秒</li></ul><h4 id=3-2-探活任务>3.2 探活任务</h4><p>1）接下来看看探活任务实现（UpstreamCacheManager # scheduled）：</p><pre><code class=language-java>private void scheduled() {
    if (UPSTREAM_MAP.size() &gt; 0) {
        UPSTREAM_MAP.forEach((k, v) -&gt; {
            // 活动检查
            List&lt;DivideUpstream&gt; result = check(v);
            if (result.size() &gt; 0) {
                UPSTREAM_MAP_TEMP.put(k, result);
            } else {
                UPSTREAM_MAP_TEMP.remove(k);
            }
        });
    }
}
</code></pre><p>任务负责逐条遍历登记全量服务散列表，检查服务活性：</p><ul><li>若存活数大于0，则更新存活服务散列表</li><li>否则，移除存活服务散列表相应内容</li></ul><p>2）继续看服务列表活性检查处理（UpstreamCacheManager # check）：</p><pre><code class=language-java>private List&lt;DivideUpstream&gt; check(final List&lt;DivideUpstream&gt; upstreamList) {
    List&lt;DivideUpstream&gt; resultList = Lists.newArrayListWithCapacity(upstreamList.size());
    for (DivideUpstream divideUpstream : upstreamList) {
        // 检查服务活性
        final boolean pass = UpstreamCheckUtils.checkUrl(divideUpstream.getUpstreamUrl());
        if (pass) {
            // 更新服务状态
            if (!divideUpstream.isStatus()) {
                divideUpstream.setTimestamp(System.currentTimeMillis());
                divideUpstream.setStatus(true);
                ...
            }
            // 记录存活的服务
            resultList.add(divideUpstream);
        } else {
            // 更新服务状态
            divideUpstream.setStatus(false);
            ...
        }
    }
    return resultList;
}
</code></pre><p>负责遍历服务列表，根据 url 检查各服务活性并登记存活的服务。</p><h4 id=3-3-活性检查>3.3 活性检查</h4><p>1）服务活性检查实现（UpstreamCheckUtils # checkUrl）：</p><pre><code class=language-java>public static boolean checkUrl(final String url) {
    ...
    // 检查url是否为ip+端口格式
    if (checkIP(url)) {
        // 处理 ip 和端口
        String[] hostPort;
        if (url.startsWith(HTTP)) {
            final String[] http = StringUtils.split(url, &quot;\\/\\/&quot;);
            hostPort = StringUtils.split(http[1], Constants.COLONS);
        } else {
            hostPort = StringUtils.split(url, Constants.COLONS);
        }
        // 测试主机是否可连通
        return isHostConnector(hostPort[0], Integer.parseInt(hostPort[1]));
    } else {
        // 测试主机是否可达
        return isHostReachable(url);
    }
}
</code></pre><p>检查 url 是否为 ip + port 格式：</p><ul><li>若为 ip + 端口格式，则测试主机是否可连接</li><li>否则，测试主机是否可达</li></ul><p>2）测试主机是否可连接（UpstreamCheckUtils # isHostConnector）：</p><pre><code class=language-java>private static boolean isHostConnector(final String host, final int port) {
    try (Socket socket = new Socket()) {
        socket.connect(new InetSocketAddress(host, port));
    } catch (IOException e) {
        return false;
    }
    return true;
}
</code></pre><p>通过 socket 的 connection 测试 ip 的连通性。</p><p>3）测试主机是否可达（UpstreamCheckUtils # isHostReachable）：</p><pre><code class=language-java>private static boolean isHostReachable(final String host) {
    try {
        return InetAddress.getByName(host).isReachable(1000);
    } catch (IOException ignored) {
    }
    return false;
}
</code></pre><p>非 ip + 端口格式 url 尝试使用域名格式测试主机是否可达。</p><p>整体看下来，divide插件从缓存里拿到的服务器信息，来源于数据同步，由探活任务定期主动更新。</p><h2 id=负载均衡>负载均衡</h2><p>上面提到，divide 通过负载均衡算法挑选最终分发的服务 ip，看下负载均衡的实现（LoadBalanceUtils # selector）：</p><pre><code class=language-java>public static DivideUpstream selector(final List&lt;DivideUpstream&gt; upstreamList, final String algorithm, final String ip) {
    LoadBalance loadBalance = ExtensionLoader.getExtensionLoader(LoadBalance.class).getJoin(algorithm);
    return loadBalance.select(upstreamList, ip);
}
</code></pre><p>内部使用 ExtensionLoader 实现 SPI 机制，然后通过算法名加载对应的负载均衡算法，执行负载均衡计算最终分发到的服务 ip。</p><p>soul网关里默认支持三种负载均衡策略</p><ul><li>HASH(需要计算，可能存在不均衡的情况)</li><li>RANDOM(最简单最快，大量请求下几乎平均)</li><li>ROUND_ROBIN(需要记录状态，有一定的影响，大数据量下随机和轮询并无太大结果上的差异)</li></ul><p>默认为 RANDOM 随机算法，算法处理如下（RandomLoadBalance # doSelect）：</p><pre><code class=language-java>public DivideUpstream doSelect(final List&lt;DivideUpstream&gt; upstreamList, final String ip) {
    int totalWeight = calculateTotalWeight(upstreamList);
    boolean sameWeight = isAllUpStreamSameWeight(upstreamList);
    // 若权重不一致，则按总权重随机
    if (totalWeight &gt; 0 &amp;&amp; !sameWeight) {
        return random(totalWeight, upstreamList);
    }
    // 按服务数随机
    return random(upstreamList);
}
</code></pre><p>判断服务列表内服务的权重是否一致：</p><ul><li>若权重不一致，则按总权重随机</li><li>否则，按服务数随机</li></ul><p>按总权重随机细节（RandomLoadBalance # random）：</p><pre><code class=language-java>private DivideUpstream random(final int totalWeight, final List&lt;DivideUpstream&gt; upstreamList) {
    // 按总权重取随机数
    int offset = RANDOM.nextInt(totalWeight);
    // 确定随机值落在哪个段上
    for (DivideUpstream divideUpstream : upstreamList) {
        offset -= getWeight(divideUpstream);
        if (offset &lt; 0) {
            return divideUpstream;
        }
    }
    return upstreamList.get(0);
}
</code></pre><h2 id=总结>总结</h2><p>divide插件处理流程：</p><ul><li><p>获取可用服务列表</p><ul><li>服务列表最初来自 <code>soul-admin</code> 数据同步</li><li>可用服务列表默认每 30 秒主动探活更新</li></ul></li><li><p>负载均衡</p><ul><li>扩展加载器加载目标负载均衡算法</li><li>执行具体均衡策略</li><li>返回一个最终选择的服务信息</li></ul></li><li><p>设置最终服务的的url信息</p></li><li><p>交由插件链下游进行处理</p></li></ul></article><div class=-show-mobile><nav class=ss-pagination-next><a class=link-prev href=/zh/blog/shenyu_source_learning_18_ratelimiter/><span class=text>上一篇:</span>
<span class=text>Apache ShenYu网关学习RateLimiter插件原理解析</span></a>
<a class=link-next href=/zh/blog/apache-cloud-native-meet-02/><span class=text>下一篇:</span>
<span class=text>Apache ShenYu 源码01期阅读分享会02</span></a></nav></div></main><aside class=ss-layout-aside><div class=ss-card><h2 class=card-title>相关推荐</h2><ul class=ss-aside-related><li><a href=/zh/blog/shenyu_source_learning_18_ratelimiter/>Apache ShenYu网关学习RateLimiter插件原理解析</a></li><li><a href=/zh/blog/shenyu_source_learning_11_spi/>Apache ShenYu网关学习SPI学习使用</a></li><li><a href=/zh/blog/shenyu_source_learning_12_sign/>Apache ShenYu网关学习Sign插件</a></li><li><a href=/zh/blog/shenyu_source_learning_09_httplongpolling_02/>Apache ShenYu网关学习Http长轮询解析02</a></li><li><a href=/zh/blog/shenyu_source_learning_17_http/>Apache ShenYu网关学习Http请求探险</a></li></ul></div><div class="ss-aside-tags ss-card"><h2 class=card-title>标签
<span class=card-extra></span></h2><ul class=tag-list><li class=tag><a href=/zh/tags/apache-shenyu/>Apache ShenYu</a></li><li class=tag><a href=/zh/tags/code-conduct/>Code Conduct</a></li><li class=tag><a href=/zh/tags/committer/>Committer</a></li><li class=tag><a href=/zh/tags/contributor/>Contributor</a></li><li class=tag><a href=/zh/tags/dreamcode/>DreamCode</a></li><li class=tag><a href=/zh/tags/gateway/>GateWay</a></li><li class=tag><a href=/zh/tags/icla/>ICLA</a></li><li class=tag><a href=/zh/tags/issue-pr/>Issue-PR</a></li><li class=tag><a href=/zh/tags/reactor/>Reactor</a></li><li class=tag><a href=/zh/tags/shenyu/>ShenYu</a></li><li class=tag><a href=/zh/tags/subscribe-email/>Subscribe-Email</a></li><li class=tag><a href=/zh/tags/two-fa/>Two-FA</a></li><li class=tag><a href=/zh/tags/vote-committer/>Vote-Committer</a></li></ul></div></aside></div><footer class=ss-footer><div class=container><div class=links><div class="cate  -show-mobile"><h2 class=cate-title>Apache</h2><a class=link href=https://www.apache.org/>Foundation</a>
<a class=link href=https://github.com/apache/incubator-shenyu/issues>GitHub Issue Tracker</a>
<a class=link href=https://www.apache.org/licenses/>License</a>
<a class=link href=https://www.apache.org/security/>Security</a>
<a class=link href=http://www.apache.org/events/current-event>Events</a>
<a class=link href=http://www.apache.org/foundation/sponsorship.html>Sponsorship</a>
<a class=link href=http://www.apache.org/foundation/thanks.html>Thanks</a></div><div class=cate><h2 class=cate-title>资源</h2><a class=link href=https://github.com/apache/incubator-shenyu>Github</a>
<a class=link href=/zh/projects/shenyu/overview/>文档</a></div><div class=cate><h2 class=cate-title>参与进来</h2><a class=link href=https://github.com/apache/incubator-shenyu/issues/new>反馈</a>
<a class=link href=/zh/community>社区</a>
<a class=link href=/zh/news>新闻</a></div><div class=cate><h2 class=cate-title>订阅邮件组</h2><a class=link href=/zh/community/subscribe-email/>如何订阅</a>
<a class=link href=mailto://dev-subscribe@shenyu.apache.org>订阅邮件</a>
<a class=link href=https://lists.apache.org/list.html?dev@shenyu.apache.org>邮件归档</a></div></div><div class=qrcode><div><img class=qrcode-img src=/img/qrcode/WechatIMG127.jpeg><p class=qrcode-desc>微信公众号</p></div></div></div><div class=copyright><p>Copyright © 2021 The Apache Software Foundation. Licensed under the Apache License, Version 2.0.
Apache ShenYu, Apache Incubator, Apache, the Apache feather logo, the Apache ShenYu logo and the Apache Incubator project logo are trademarks of The Apache Software Foundation.
Apache ShenYu is an effort undergoing incubation at The Apache Software Foundation (ASF), sponsored by the Apache Incubator.
Incubation is required of all newly accepted projects until a further review indicates that the infrastructure, communications, and decision making process have stabilized in a manner consistent with other successful ASF projects.
While incubation status is not necessarily a reflection of the completeness or stability of the code,
it does indicate that the project has yet to be fully endorsed by the ASF.</p></div></footer></body></html>