<!doctype html><html><head><title>Apache ShenYu网关学习WebSocket数据同步解析 · Apache ShenYu</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="The girl on the prairie"><meta name=generator content="Hugo 0.55.5"><link rel="shortcut icon" href=/img/favicon.png type=image/png><link href=https://unpkg.com/purecss@1.0.0/build/base-min.css rel=stylesheet><link href=/css/main.css rel=stylesheet><link href=/css/zoom-image.css rel=stylesheet><script src=/js/iconfont.js></script><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script><script>window.SITE_LANGUAGE="zh"</script><script src=/js/app.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-187960192-2','auto');ga('send','pageview');}</script></head><body><header class=ss-header><nav class=navbar role=navigation aria-label="main navigation"><div class=navbar-brand><a class=logo-link style=font-size:25px;margin-right:50px href=/zh/><img class=logo src=/img/logo/apache-shenyu.png></a><div class=-show-mobile><a id=mobile-menu-icon><svg class="icon" aria-hidden="true"><use xlink:href="#icon-menu"/></svg></a><nav id=mobile-menu><div id=js-menu-search-mobile class=navbar-search-mobile><input class=input placeholder=请输入要搜索的关键词><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div><a href=/zh/projects/shenyu/download/><span>下载</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/projects/shenyu/overview/><span>文档</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/community/subscribe-email/><span>社区</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/news/><span>新闻</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/awesome/><span>Awesome</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/blog/shenyu_source_learning_10_websocket/><span>English</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-transfer"/></svg></a></nav></div></div><div class="navbar-menu -hidden-mobile"><div class=navbar-start><a class=navbar-item href=/zh/projects/shenyu/download/>下载</a>
<a class=navbar-item href=/zh/projects/shenyu/overview/>文档</a>
<a class=navbar-item href=/zh/community/subscribe-email/>社区</a>
<a class=navbar-item href=/zh/news/>新闻</a>
<a class=navbar-item href=/zh/awesome/>Awesome</a>
<span class="navbar-item nav-hover"><a>Links</a><div class=dropdown-menu><a class=dropdown-item href=https://www.apache.org/>Apache Software Foundation</a>
<a class=dropdown-item href=https://github.com/apache/incubator-shenyu/issues>GitHub Issue Tracker</a>
<a class=dropdown-item href=https://www.apache.org/>License</a>
<a class=dropdown-item href=http://www.apache.org/events/current-event>Apache Events</a>
<a class=dropdown-item href=https://www.apache.org/licenses/>Security</a>
<a class=dropdown-item href=http://www.apache.org/foundation/sponsorship.html>Sponsor and Donate</a>
<a class=dropdown-item href=http://www.apache.org/foundation/thanks.html>Thanks</a></div></span></div><div class=navbar-end><div class=navbar-item><div id=js-menu-search class=navbar-search><input class=input placeholder=请输入要搜索的关键词><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div></div><div class=navbar-item><a class=translation href=/blog/shenyu_source_learning_10_websocket/>En</a></div></div></div></nav></header><div class=ss-layout-container><main class="ss-layout-main -card"><div class=ss-meta><h1 class=title>Apache ShenYu网关学习WebSocket数据同步解析</h1><div class=meta>2021-01-22 ·
范金鹏,朱明 ·
<span class=tags><a class=tag href=/zh/tags/apache-shenyu/ rel=tag>#Apache ShenYu</a></span></div></div><article class=typo><blockquote><p>范金鹏</p></blockquote><h1 id=1-前情回顾>1.前情回顾</h1><p>在第4篇中，我们分析了 HTTP 用户业务系统接入 Apache ShenYu 网关后，会调用 soul-admin 的注册接口，把需要网关代理的接口信息全部注册到 soul-admin 上，在最后，会通过 websocket 长连接，将soul-admin 接收到的接口信息同步给 Apache ShenYu 网关（即 soul-bootstrap），今天就来接着继续分析，数据是怎么同步到 soul-bootstrap 的。</p><p>不清楚流程的可以出门左转看下第4篇文章 <a href=https://blog.csdn.net/hellboy0621/article/details/112727101>【Soul源码阅读】4.HTTP 用户接入 ShenYu 调用 /soul-client/springmvc-register 接口逻辑分析</a></p><h1 id=2-soul-admin-与-soul-bootstrap-数据同步>2.soul-admin 与 soul-bootstrap 数据同步</h1><p>这里为了验证数据同步流程，其实也没必要非得启动业务系统，完全可以只启动 soul-admin 和 soul-bootstrap 两个系统即可，可以在页面打开或关闭插件，看看这个流程是怎么实现的。</p><p>数据同步策略官网链接 <a href=https://dromara.org/zh-cn/docs/soul/user-dataSync.html>https://dromara.org/zh-cn/docs/soul/user-dataSync.html</a></p><h2 id=2-1-启动2个系统>2.1 启动2个系统</h2><p>都是按照项目默认启动的，无需修改任何配置文件。</p><h2 id=2-2-页面操作查找接口>2.2 页面操作查找接口</h2><p>这里把 divide 插件启动，F12，看下前台会调用 soul-admin 哪个接口。</p><p><img src=/img/shenyu/blog3/open_divide_plugin.png alt=open_divide_plugin></p><p>可以看到前台向后台发送了一个 PUT 请求：<a href=http://localhost:9095/plugin/5>http://localhost:9095/plugin/5</a></p><h2 id=2-3-后台接口>2.3 后台接口</h2><p>在项目中搜索这个接口</p><pre><code class=language-java>// PluginController.java
@RestController
@RequestMapping(&quot;/plugin&quot;)
public class PluginController {
 
...
 
    /**
     * update plugin.
     *
     * @param id        primary key.
     * @param pluginDTO plugin.
     * @return {@linkplain SoulAdminResult}
     */
    @PutMapping(&quot;/{id}&quot;)
    public SoulAdminResult updatePlugin(@PathVariable(&quot;id&quot;) final String id, @RequestBody final PluginDTO pluginDTO) {
        Objects.requireNonNull(pluginDTO);
        pluginDTO.setId(id);
        final String result = pluginService.createOrUpdate(pluginDTO);
        if (StringUtils.isNoneBlank(result)) {
            return SoulAdminResult.error(result);
        }
        return SoulAdminResult.success(SoulResultMessage.UPDATE_SUCCESS);
    }
 
...
 
}
</code></pre><p>进到实现类里</p><pre><code class=language-java>// PluginServiceImpl.java
/**
     * create or update plugin.
     *
     * @param pluginDTO {@linkplain PluginDTO}
     * @return rows
     */
    @Override
    @Transactional(rollbackFor = Exception.class)
    public String createOrUpdate(final PluginDTO pluginDTO) {
        final String msg = checkData(pluginDTO);
        if (StringUtils.isNoneBlank(msg)) {
            return msg;
        }
        PluginDO pluginDO = PluginDO.buildPluginDO(pluginDTO);
        DataEventTypeEnum eventType = DataEventTypeEnum.CREATE;
        if (StringUtils.isBlank(pluginDTO.getId())) {
            pluginMapper.insertSelective(pluginDO);
        } else {
            eventType = DataEventTypeEnum.UPDATE;
            pluginMapper.updateSelective(pluginDO);
        }
 
        // publish change event.
        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.PLUGIN, eventType,
                Collections.singletonList(PluginTransfer.INSTANCE.mapToData(pluginDO))));
        return StringUtils.EMPTY;
    }
</code></pre><p>这里可以看出来，前半部分都是在操作数据库，把相关信息持久化；后半部分是发布了一个事件。</p><h2 id=2-4-发布事件>2.4 发布事件</h2><p>这里发布的事件用 DataChangedEvent 封装了一层，再看里面有1个枚举，这里有很多种类型：</p><pre><code class=language-java>/**
 * configuration group.
 *
 * @author huangxiaofeng
 */
public enum ConfigGroupEnum {
 
    APP_AUTH,
 
    PLUGIN,
 
    RULE,
 
    SELECTOR,
 
    META_DATA;
 
...
 
}
</code></pre><p>看到这几种类型，如果对第4篇还有印象的话，可以看出当时发送事件的类型就是 SELECTOR 和 RULE，现在是 PLUGIN，虽然类型不同，但不影响我们继续分析后面的逻辑，我们继续。</p><p>另外一个 eventType 也是枚举，这里有 DELETE、CREATE、UPDATE、REFRESH、MYSELF 5种类型，此时是 UPDATE。</p><pre><code class=language-java>/**
 * The enum Data event type.
 *
 * @author xiaoyu
 */
public enum DataEventTypeEnum {
    /**
     * delete event.
     */
    DELETE,
    /**
     * insert event.
     */
    CREATE,
    /**
     * update event.
     */
    UPDATE,
    /**
     * REFRESH data event type enum.
     */
    REFRESH,
    /**
     * Myself data event type enum.
     */
    MYSELF;
 
...
 
}
</code></pre><h2 id=2-5-监听事件>2.5 监听事件</h2><p>找到监听事件的代码：</p><pre><code class=language-java>// DataChangedEventDispatcher.java
@Component
public class DataChangedEventDispatcher implements ApplicationListener&lt;DataChangedEvent&gt;, InitializingBean {
 
    private ApplicationContext applicationContext;
 
    private List&lt;DataChangedListener&gt; listeners;
 
    public DataChangedEventDispatcher(final ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }
 
    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public void onApplicationEvent(final DataChangedEvent event) {
        for (DataChangedListener listener : listeners) {
            switch (event.getGroupKey()) {
                case APP_AUTH:
                    listener.onAppAuthChanged((List&lt;AppAuthData&gt;) event.getSource(), event.getEventType());
                    break;
                case PLUGIN:
                    listener.onPluginChanged((List&lt;PluginData&gt;) event.getSource(), event.getEventType());
                    break;
                case RULE:
                    listener.onRuleChanged((List&lt;RuleData&gt;) event.getSource(), event.getEventType());
                    break;
                case SELECTOR:
                    listener.onSelectorChanged((List&lt;SelectorData&gt;) event.getSource(), event.getEventType());
                    break;
                case META_DATA:
                    listener.onMetaDataChanged((List&lt;MetaData&gt;) event.getSource(), event.getEventType());
                    break;
                default:
                    throw new IllegalStateException(&quot;Unexpected value: &quot; + event.getGroupKey());
            }
        }
    }
 
    @Override
    public void afterPropertiesSet() {
        Collection&lt;DataChangedListener&gt; listenerBeans = applicationContext.getBeansOfType(DataChangedListener.class).values();
        this.listeners = Collections.unmodifiableList(new ArrayList&lt;&gt;(listenerBeans));
    }
}
</code></pre><h3 id=2-5-1-监听器注入>2.5.1 监听器注入</h3><p>可以看到 DataChangedEventDispatcher 实现了 InitializingBean 接口，覆写了 afterPropertiesSet 方法，并且使用了 @Component，当 Spring 启动时，会在容器加载完成后调用这个覆写方法。
afterPropertiesSet 方法中，把 DataChangedListener 类型的 Bean 全部获取后，放到类属性 listeners 里。</p><p>那么问题来了，这些监听器是什么时候注入到容器中的呢？</p><p>先看下 DataChangedListener 接口定义：</p><pre><code class=language-java>/**
 * Event listener, used to send notification of event changes,
 * used to support HTTP, websocket, zookeeper and other event notifications.
 *
 * @author huangxiaofeng
 * @author xiaoyu
 */
public interface DataChangedListener {
 
    /**
     * invoke this method when AppAuth was received.
     *
     * @param changed   the changed
     * @param eventType the event type
     */
    default void onAppAuthChanged(List&lt;AppAuthData&gt; changed, DataEventTypeEnum eventType) {
    }
 
    /**
     * invoke this method when Plugin was received.
     *
     * @param changed   the changed
     * @param eventType the event type
     */
    default void onPluginChanged(List&lt;PluginData&gt; changed, DataEventTypeEnum eventType) {
    }
 
    /**
     * invoke this method when Selector was received.
     *
     * @param changed   the changed
     * @param eventType the event type
     */
    default void onSelectorChanged(List&lt;SelectorData&gt; changed, DataEventTypeEnum eventType) {
    }
 
    /**
     * On meta data changed.
     *
     * @param changed   the changed
     * @param eventType the event type
     */
    default void onMetaDataChanged(List&lt;MetaData&gt; changed, DataEventTypeEnum eventType) {
 
    }
 
    /**
     * invoke this method when Rule was received.
     *
     * @param changed   the changed
     * @param eventType the event type
     */
    default void onRuleChanged(List&lt;RuleData&gt; changed, DataEventTypeEnum eventType) {
    }
 
}
</code></pre><p>可以看到接口中定义了5个方法，分别针对当监听到 appAuth、plugin、selector、metaData、rule 数据变动时对应的处理方法。</p><p>其继承关系：</p><p><img src=/img/shenyu/blog3/DataChangedListener.png alt=DataChangedListener></p><p>因为默认是采用的 websocket，这里的监听器对应的就是 WebsocketDataChangedListener，Alt + F7，搜索到这个类实例化的地方，就是如下的配置类：</p><pre><code class=language-java>// DataSyncConfiguration.java
@Configuration
public class DataSyncConfiguration {
 
    /**
     * http long polling.
     */
    @Configuration
    @ConditionalOnProperty(name = &quot;soul.sync.http.enabled&quot;, havingValue = &quot;true&quot;)
    @EnableConfigurationProperties(HttpSyncProperties.class)
    static class HttpLongPollingListener {
        @Bean
        @ConditionalOnMissingBean(HttpLongPollingDataChangedListener.class)
        public HttpLongPollingDataChangedListener httpLongPollingDataChangedListener(final HttpSyncProperties httpSyncProperties) {
            return new HttpLongPollingDataChangedListener(httpSyncProperties);
        }
    }
 
    /**
     * The type Zookeeper listener.
     */
    @Configuration
    @ConditionalOnProperty(prefix = &quot;soul.sync.zookeeper&quot;, name = &quot;url&quot;)
    @Import(ZookeeperConfiguration.class)
    static class ZookeeperListener {
        @Bean
        @ConditionalOnMissingBean(ZookeeperDataChangedListener.class)
        public DataChangedListener zookeeperDataChangedListener(final ZkClient zkClient) {
            return new ZookeeperDataChangedListener(zkClient);
        }
        @Bean
        @ConditionalOnMissingBean(ZookeeperDataInit.class)
        public ZookeeperDataInit zookeeperDataInit(final ZkClient zkClient, final SyncDataService syncDataService) {
            return new ZookeeperDataInit(zkClient, syncDataService);
        }
    }
 
    /**
     * The type Nacos listener.
     */
    @Configuration
    @ConditionalOnProperty(prefix = &quot;soul.sync.nacos&quot;, name = &quot;url&quot;)
    @Import(NacosConfiguration.class)
    static class NacosListener {
        @Bean
        @ConditionalOnMissingBean(NacosDataChangedListener.class)
        public DataChangedListener nacosDataChangedListener(final ConfigService configService) {
            return new NacosDataChangedListener(configService);
        }
    }
 
    /**
     * The WebsocketListener(default strategy).
     */
    @Configuration
    @ConditionalOnProperty(name = &quot;soul.sync.websocket.enabled&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)
    @EnableConfigurationProperties(WebsocketSyncProperties.class)
    static class WebsocketListener {
        @Bean
        @ConditionalOnMissingBean(WebsocketDataChangedListener.class)
        public DataChangedListener websocketDataChangedListener() {
            return new WebsocketDataChangedListener();
        }
        @Bean
        @ConditionalOnMissingBean(WebsocketCollector.class)
        public WebsocketCollector websocketCollector() {
            return new WebsocketCollector();
        }
        @Bean
        @ConditionalOnMissingBean(ServerEndpointExporter.class)
        public ServerEndpointExporter serverEndpointExporter() {
            return new ServerEndpointExporter();
        }
    }
}
</code></pre><p>一共有4种同步数据策略，http长轮询、zookeeper、nacos、websocket（默认策略）。</p><p>看到 websocket 的注解 @ConditionalOnProperty(name = &ldquo;soul.sync.websocket.enabled&rdquo;, havingValue = &ldquo;true&rdquo;, matchIfMissing = true)，到配置文件中找到如下配置：</p><pre><code class=language-yaml>soul:
  sync:
    websocket:
      enabled: true
</code></pre><p>到这里就真相大白了。</p><p>如果不想使用 websocket 的默认同步策略，在配置文件中写上对应的配置即可。</p><h3 id=2-5-2-监听事件处理逻辑>2.5.2 监听事件处理逻辑</h3><p>为了防止大家再翻回去看，不方便，我这里再把处理逻辑代码贴出来：</p><pre><code class=language-java>// DataChangedEventDispatcher.java
@Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public void onApplicationEvent(final DataChangedEvent event) {
        for (DataChangedListener listener : listeners) {
            switch (event.getGroupKey()) {
                case APP_AUTH:
                    listener.onAppAuthChanged((List&lt;AppAuthData&gt;) event.getSource(), event.getEventType());
                    break;
                case PLUGIN:
                    listener.onPluginChanged((List&lt;PluginData&gt;) event.getSource(), event.getEventType());
                    break;
                case RULE:
                    listener.onRuleChanged((List&lt;RuleData&gt;) event.getSource(), event.getEventType());
                    break;
                case SELECTOR:
                    listener.onSelectorChanged((List&lt;SelectorData&gt;) event.getSource(), event.getEventType());
                    break;
                case META_DATA:
                    listener.onMetaDataChanged((List&lt;MetaData&gt;) event.getSource(), event.getEventType());
                    break;
                default:
                    throw new IllegalStateException(&quot;Unexpected value: &quot; + event.getGroupKey());
            }
        }
    }
</code></pre><p>这里遍历所有的监听器，对于目前的 websocket 只会有一个监听器，其他多个的情况暂时不知道什么时候会出现，这里存疑，后续碰到相关的 case 时再回来补充（// TODO）。</p><p>根据发布事件的类型走不同的逻辑，这里分的类型跟 DataChangedListener 接口中定义的方法一一对应。</p><p>这里的 listener 是 WebsocketDataChangedListener 的实例，会进到类中对应的方法：</p><pre><code class=language-java>// WebsocketDataChangedListener.java
public class WebsocketDataChangedListener implements DataChangedListener {
 
    @Override
    public void onPluginChanged(final List&lt;PluginData&gt; pluginDataList, final DataEventTypeEnum eventType) {
        WebsocketData&lt;PluginData&gt; websocketData =
                new WebsocketData&lt;&gt;(ConfigGroupEnum.PLUGIN.name(), eventType.name(), pluginDataList);
        WebsocketCollector.send(GsonUtils.getInstance().toJson(websocketData), eventType);
    }
 
    @Override
    public void onSelectorChanged(final List&lt;SelectorData&gt; selectorDataList, final DataEventTypeEnum eventType) {
        WebsocketData&lt;SelectorData&gt; websocketData =
                new WebsocketData&lt;&gt;(ConfigGroupEnum.SELECTOR.name(), eventType.name(), selectorDataList);
        WebsocketCollector.send(GsonUtils.getInstance().toJson(websocketData), eventType);
    }
 
    @Override
    public void onRuleChanged(final List&lt;RuleData&gt; ruleDataList, final DataEventTypeEnum eventType) {
        WebsocketData&lt;RuleData&gt; configData =
                new WebsocketData&lt;&gt;(ConfigGroupEnum.RULE.name(), eventType.name(), ruleDataList);
        WebsocketCollector.send(GsonUtils.getInstance().toJson(configData), eventType);
    }
 
    @Override
    public void onAppAuthChanged(final List&lt;AppAuthData&gt; appAuthDataList, final DataEventTypeEnum eventType) {
        WebsocketData&lt;AppAuthData&gt; configData =
                new WebsocketData&lt;&gt;(ConfigGroupEnum.APP_AUTH.name(), eventType.name(), appAuthDataList);
        WebsocketCollector.send(GsonUtils.getInstance().toJson(configData), eventType);
    }
 
    @Override
    public void onMetaDataChanged(final List&lt;MetaData&gt; metaDataList, final DataEventTypeEnum eventType) {
        WebsocketData&lt;MetaData&gt; configData =
                new WebsocketData&lt;&gt;(ConfigGroupEnum.META_DATA.name(), eventType.name(), metaDataList);
        WebsocketCollector.send(GsonUtils.getInstance().toJson(configData), eventType);
    }
 
}
</code></pre><p>看到代码中，将数据封装为 WebsocketData 后，使用 WebsocketController.send 方法发送出去了。</p><h2 id=2-6-同步数据给-soul-bootstrap>2.6 同步数据给 soul-bootstrap</h2><pre><code class=language-java>// WebsocketCollector.java
@Slf4j
@ServerEndpoint(&quot;/websocket&quot;)
public class WebsocketCollector {
 
    private static final Set&lt;Session&gt; SESSION_SET = new CopyOnWriteArraySet&lt;&gt;();
 
    private static final String SESSION_KEY = &quot;sessionKey&quot;;
 
    /**
     * On open.
     *
     * @param session the session
     */
    @OnOpen
    public void onOpen(final Session session) {
        log.info(&quot;websocket on open successful....&quot;);
        SESSION_SET.add(session);
    }
 
    /**
     * On message.
     *
     * @param message the message
     * @param session the session
     */
    @OnMessage
    public void onMessage(final String message, final Session session) {
        if (message.equals(DataEventTypeEnum.MYSELF.name())) {
            try {
                ThreadLocalUtil.put(SESSION_KEY, session);
                SpringBeanUtils.getInstance().getBean(SyncDataService.class).syncAll(DataEventTypeEnum.MYSELF);
            } finally {
                ThreadLocalUtil.clear();
            }
        }
    }
 
    /**
     * On close.
     *
     * @param session the session
     */
    @OnClose
    public void onClose(final Session session) {
        SESSION_SET.remove(session);
        ThreadLocalUtil.clear();
    }
 
    /**
     * On error.
     *
     * @param session the session
     * @param error   the error
     */
    @OnError
    public void onError(final Session session, final Throwable error) {
        SESSION_SET.remove(session);
        ThreadLocalUtil.clear();
        log.error(&quot;websocket collection error: &quot;, error);
    }
 
    /**
     * Send.
     *
     * @param message the message
     * @param type    the type
     */
    public static void send(final String message, final DataEventTypeEnum type) {
        if (StringUtils.isNotBlank(message)) {
            if (DataEventTypeEnum.MYSELF == type) {
                try {
                    Session session = (Session) ThreadLocalUtil.get(SESSION_KEY);
                    if (session != null) {
                        session.getBasicRemote().sendText(message);
                    }
                } catch (IOException e) {
                    log.error(&quot;websocket send result is exception: &quot;, e);
                }
                return;
            }
            for (Session session : SESSION_SET) {
                try {
                    session.getBasicRemote().sendText(message);
                } catch (IOException e) {
                    log.error(&quot;websocket send result is exception: &quot;, e);
                }
            }
        }
    }
}
</code></pre><p>WebsocketController 使用了 @ServerEndpoint(&ldquo;/websocket&rdquo;) 注解，开启了一个 websocket 服务接口，等待连接。</p><p>当 soul-bootstrap 启动后，会连接这个 websocket，这时触发 onOpen 方法，将此次连接信息的 Session 存放在 SESSION_SET 这个 Set 集合里。</p><p>在 send 方法中，会先判断 DataEventTypeEnum type 是不是 MYSELF，这个 type 可以追溯到 2.3-2.4，此次是 UPDATE，关于什么时候是 MYSELF，还需要后续补充，此处存疑（// TODO）。</p><p>下面的 for 循环遍历所有的 websocket 连接 Session，发送变动数据。</p><p>到这里，默认的 websocket 同步数据策略就分析清楚了。</p><blockquote><p>朱明</p></blockquote><h2 id=后台与网关数据同步-websocket篇>后台与网关数据同步 (Websocket篇)</h2><h3 id=后台如何建立websocket>后台如何建立Websocket?</h3><p><img src=/img/shenyu/blog1/05.png alt=05>
DataSyncConfiguration: 作为 Spring Bean 的配置工厂, 可以根据配置信息, 构建各类监听器, 包括 HTTP 长轮询方式、Zookeeper 方式、Nacos 方式、Websocket 方法.</p><pre><code class=language-java>@Configuration
public class DataSyncConfiguration {
  
  // soul-admin 项目的配置信息中, 使用 soul.sync.websocket.enabled 开启或关闭 websocket
  @Configuration
  @ConditionalOnProperty(name = &quot;soul.sync.websocket.enabled&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)
  @EnableConfigurationProperties(WebsocketSyncProperties.class)
  static class WebsocketListener {
    
    @Bean
    @ConditionalOnMissingBean(WebsocketCollector.class)
    public WebsocketCollector websocketCollector() {
      return new WebsocketCollector();
    }
  }
}
</code></pre><p>WebsocketListener: 作为 <code>DataSyncConfiguration</code> 的内部类, 负责 websocket 监听器初始化.
WebsocketCollector: 监听 websocket 连接及接收信息, 维护所有连接后台的 session 会话, 提供 <code>send()</code> 方法通知 session 信息.</p><h3 id=网关如何建立websocket>网关如何建立Websocket?</h3><p><img src=/img/shenyu/blog1/06.png alt=06></p><p>WebsocketSyncDataConfiguration: 作为 Spring Bean 的配置工厂, 是网关端构建 Websocket 通信的入口. (独立出一个启动项目 <code>soul-spring-boot-starter-sync-data-websocket</code> , 供网关自由选用)</p><pre><code class=language-java>@Configuration
@ConditionalOnClass(WebsocketSyncDataService.class)
@ConditionalOnProperty(prefix = &quot;soul.sync.websocket&quot;, name = &quot;urls&quot;)
@Slf4j
public class WebsocketSyncDataConfiguration {
  
  // 收集所有注册为 Bean 的订阅器,  如 PluginDataSubscriber、MetaDataSubscriber、AuthDataSubscriber
  @Bean
  public SyncDataService websocketSyncDataService(final ObjectProvider&lt;WebsocketConfig&gt; websocketConfig, final ObjectProvider&lt;PluginDataSubscriber&gt; pluginSubscriber, final ObjectProvider&lt;List&lt;MetaDataSubscriber&gt;&gt; metaSubscribers, final ObjectProvider&lt;List&lt;AuthDataSubscriber&gt;&gt; authSubscribers) {
    log.info(&quot;you use websocket sync soul data.......&quot;);
    return new WebsocketSyncDataService(websocketConfig.getIfAvailable(WebsocketConfig::new), pluginSubscriber.getIfAvailable(), metaSubscribers.getIfAvailable(Collections::emptyList), authSubscribers.getIfAvailable(Collections::emptyList));
  }
  
  // soul-bootstrap 项目的配置信息中, 使用 soul.sync.websocket 配置要建立连接的后台路径
  @Bean
  @ConfigurationProperties(prefix = &quot;soul.sync.websocket&quot;)
  public WebsocketConfig websocketConfig() {
    return new WebsocketConfig();
  }
}
</code></pre><p>WebsocketSyncDataService: 获取所有注册为 Bean 的 <code>WebsocketConfig</code> 以及各种 <code>DataSubscriber</code> 订阅器, 构建实现了 <code>WebsocketClient</code> 的 <code>SoulWebsocketClient</code> 列表</p><p>SoulWebsocketClient: <code>Websocket</code> 通信类, 监听 websocket 连接及接收信息, 在接收到后台传来的信息后会通知各个订阅器.</p><pre><code class=language-java>public final class SoulWebsocketClient extends WebSocketClient {
  
  private final WebsocketDataHandler websocketDataHandler;
  
    private void handleResult(final String result) {
    WebsocketData websocketData = GsonUtils.getInstance().fromJson(result, WebsocketData.class);
    ConfigGroupEnum groupEnum = ConfigGroupEnum.acquireByName(websocketData.getGroupType());
    // 根据传入信息得到数据变更的事件类型, 如 refresh、update、delete 等
    String eventType = websocketData.getEventType();
    String json = GsonUtils.getInstance().toJson(websocketData.getData());
    websocketDataHandler.executor(groupEnum, json, eventType);
  }
}
</code></pre><p>WebsocketDataHandler: 初始化时构建各类实现 <code>AbstractDataHandler</code> 的数据处理类并缓存.</p><pre><code class=language-java>public class WebsocketDataHandler {
  
  // 缓存所有 DataHandler 数据变动处理类
  private static final EnumMap&lt;ConfigGroupEnum, DataHandler&gt; ENUM_MAP = new EnumMap&lt;&gt;(ConfigGroupEnum.class);

  public WebsocketDataHandler(final PluginDataSubscriber pluginDataSubscriber,
                              final List&lt;MetaDataSubscriber&gt; metaDataSubscribers,
                              final List&lt;AuthDataSubscriber&gt; authDataSubscribers) {
    ENUM_MAP.put(ConfigGroupEnum.PLUGIN, new PluginDataHandler(pluginDataSubscriber));
    ENUM_MAP.put(ConfigGroupEnum.SELECTOR, new SelectorDataHandler(pluginDataSubscriber));
    ENUM_MAP.put(ConfigGroupEnum.RULE, new RuleDataHandler(pluginDataSubscriber));
    ENUM_MAP.put(ConfigGroupEnum.APP_AUTH, new AuthDataHandler(authDataSubscribers));
    ENUM_MAP.put(ConfigGroupEnum.META_DATA, new MetaDataHandler(metaDataSubscribers));
  }

  public void executor(final ConfigGroupEnum type, final String json, final String eventType) {
    // 根据数据变动事件类型, 调用相应的 DataHandler 数据处理类
    ENUM_MAP.get(type).handle(json, eventType);
  }
}
</code></pre><h3 id=网关数据变动调用链>网关数据变动调用链</h3><p>实现 Websocket 通信的入口类 <code>SoulWebsocketClient</code> 在接到后台通信后, 调用 <code>WebsocketDataHandler</code> 的 <code>executor()</code> 方法匹配信息类型, 并调用对应的 <code>DataHandler</code> 的 <code>handler()</code> 去处理信息.</p><p><img src=/img/shenyu/blog1/07.png alt=07></p><p>AbstractDataHandler: 实现 <code>handler()</code> 方法, 根据事件的类型 (如刷新、更新、创建、删除等), 调用对应事件抽象方法.</p><pre><code class=language-java>public abstract class AbstractDataHandler&lt;T&gt; implements DataHandler {

  // 根据数据的事件类型 (eventType) 分发到各自方法, 这些被调用的方法由子类实现, 因为不同类型的元数据处理类的处理方式不同
  @Override
  public void handle(final String json, final String eventType) {
    List&lt;T&gt; dataList = convert(json);
    if (CollectionUtils.isNotEmpty(dataList)) {
      DataEventTypeEnum eventTypeEnum = DataEventTypeEnum.acquireByName(eventType);
      switch (eventTypeEnum) {
        case REFRESH:
        case MYSELF:
          doRefresh(dataList);
          break;
        case UPDATE:
        case CREATE:
          doUpdate(dataList);
          break;
        case DELETE:
          doDelete(dataList);
          break;
        default:
          break;
      }
    }
  }
}
</code></pre><p>XXXDataHandler: 这里指的是 <code>AbstractDataHandler</code> 的各个实现类 (如 <code>PluginDataHandler</code> 等), 主要作用是调用其订阅器.</p><p>不同的 <code>DataHandler</code> 调用的订阅方法不同:</p><ul><li><code>PluginDataHandler</code> 会调用 <code>onSubscribe()</code> 通知插件元数据变更</li><li><code>SelectorDataHandler</code> 会调用 <code>onSelectorSubscribe()</code> 通知选择器元数据变更</li><li><code>RuleDataHandler</code> 会调用 <code>onRuleSubscribe()</code> 通知规则元数据变更</li></ul><pre><code class=language-java>@RequiredArgsConstructor
public class PluginDataHandler extends AbstractDataHandler&lt;PluginData&gt; {
  
  private final PluginDataSubscriber pluginDataSubscriber;
  
  @Override
  protected void doUpdate(final List&lt;PluginData&gt; dataList) {
    // 调用订阅器的 onSubscribe(), 发送数据对象 PluginData
    dataList.forEach(pluginDataSubscriber::onSubscribe);
  }
  
  // ...
}
</code></pre><p>CommonPluginDataSubscriber: 订阅器的 <code>onSubscribe()</code> 方法会通知到所有注入为 Bean 的 <code>PluginDataHandler</code> 类 (不要和前面的同名类混淆, 它是 <code>soul-plugin-base</code> 下的接口, 它的实现类在各个可插拔插件包)</p><p><img src=/img/shenyu/blog1/image-20210122172333111.png alt=image-20210122172333111></p><pre><code class=language-java>public class CommonPluginDataSubscriber implements PluginDataSubscriber {
  
  // 收集所有注册为 Bean 的数据处理器并缓存, 比如 HTTP 插件 divide 下的 DividePluginDataHandler
  private final Map&lt;String, PluginDataHandler&gt; handlerMap;
  
  // 插件元数据变动调用
  @Override
  public void onSubscribe(final PluginData pluginData) {
    BaseDataCache.getInstance().cachePluginData(pluginData);
    Optional.ofNullable(handlerMap.get(pluginData.getName())).ifPresent(handler -&gt; handler.handlerPlugin(pluginData));
  }
  
  // 选择器元数据变动调用
  @Override
  public void onSelectorSubscribe(final SelectorData selectorData) {
    BaseDataCache.getInstance().cacheSelectData(selectorData);
    Optional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -&gt; handler.handlerSelector(selectorData));
  }
  
  // 规则元数据变动调用
  @Override
  public void onRuleSubscribe(final RuleData ruleData) {
    BaseDataCache.getInstance().cacheRuleData(ruleData);
    Optional.ofNullable(handlerMap.get(ruleData.getPluginName())).ifPresent(handler -&gt; handler.handlerRule(ruleData));
  }
}
</code></pre><h3 id=tips>TIPS</h3><p>整个大项目下存在两个同名的类 PluginDataHandler, 其中一个在项目 <code>soul-sync-data-websocket</code> 下, 用于通知插件元数据变更, 另一个在 <code>soul-plugin-base</code> 下, 用于定义各个插件的各个类型元数据更新.</p><p>总结下这两个类命名的意义, <strong><code>soul-sync-data-websocket</code> 下类名的 &ldquo;plugin&rdquo; 指元数据的类型为插件类, <code>soul-plugin-base</code> 下类名的 &ldquo;plugin&rdquo; 指继承它的子类来自与各个可插播插件, 比如divide、dubbo插件等</strong></p></article><div class=-show-mobile><nav class=ss-pagination-next><a class=link-prev href=/zh/blog/apache-cloud-native-meet/><span class=text>上一篇:</span>
<span class=text>Apache ShenYu 源码01期阅读分享会01</span></a>
<a class=link-next href=/zh/blog/shenyu_source_learning_08_httplongpolling_01/><span class=text>下一篇:</span>
<span class=text>Apache ShenYu网关学习Http长轮询解析01</span></a></nav></div></main><aside class=ss-layout-aside><div class=ss-card><h2 class=card-title>相关推荐</h2><ul class=ss-aside-related><li><a href=/zh/blog/shenyu_source_learning_13_zookeeper_02/>Apache ShenYu网关学习Zookeeper数据同步02</a></li><li><a href=/zh/blog/shenyu_source_learning_15_plugin_chain/>Apache ShenYu网关学习插件链实现</a></li><li><a href=/zh/blog/shenyu_resource_learning_07_admin/>Apache ShenYu网关学习Admin源码分析</a></li><li><a href=/zh/blog/shenyu_source_learning_13_zookeeper_01/>Apache ShenYu网关学习Zookeeper数据同步01</a></li><li><a href=/zh/blog/shenyu_source_learning_02_http_client_register/>Apache ShenYu网关学习(2-3)Http客户端接入源码解析</a></li></ul></div><div class="ss-aside-tags ss-card"><h2 class=card-title>标签
<span class=card-extra></span></h2><ul class=tag-list><li class=tag><a href=/zh/tags/apache-shenyu/>Apache ShenYu</a></li><li class=tag><a href=/zh/tags/code-conduct/>Code Conduct</a></li><li class=tag><a href=/zh/tags/committer/>Committer</a></li><li class=tag><a href=/zh/tags/contributor/>Contributor</a></li><li class=tag><a href=/zh/tags/dreamcode/>DreamCode</a></li><li class=tag><a href=/zh/tags/gateway/>GateWay</a></li><li class=tag><a href=/zh/tags/icla/>ICLA</a></li><li class=tag><a href=/zh/tags/issue-pr/>Issue-PR</a></li><li class=tag><a href=/zh/tags/reactor/>Reactor</a></li><li class=tag><a href=/zh/tags/shenyu/>ShenYu</a></li><li class=tag><a href=/zh/tags/subscribe-email/>Subscribe-Email</a></li><li class=tag><a href=/zh/tags/two-fa/>Two-FA</a></li><li class=tag><a href=/zh/tags/vote-committer/>Vote-Committer</a></li></ul></div></aside></div><footer class=ss-footer><div class=container><div class=links><div class="cate  -show-mobile"><h2 class=cate-title>Apache</h2><a class=link href=https://www.apache.org/>Foundation</a>
<a class=link href=https://github.com/apache/incubator-shenyu/issues>GitHub Issue Tracker</a>
<a class=link href=https://www.apache.org/licenses/>License</a>
<a class=link href=https://www.apache.org/security/>Security</a>
<a class=link href=http://www.apache.org/events/current-event>Events</a>
<a class=link href=http://www.apache.org/foundation/sponsorship.html>Sponsorship</a>
<a class=link href=http://www.apache.org/foundation/thanks.html>Thanks</a></div><div class=cate><h2 class=cate-title>资源</h2><a class=link href=https://github.com/apache/incubator-shenyu>Github</a>
<a class=link href=/zh/projects/shenyu/overview/>文档</a></div><div class=cate><h2 class=cate-title>参与进来</h2><a class=link href=https://github.com/apache/incubator-shenyu/issues/new>反馈</a>
<a class=link href=/zh/community>社区</a>
<a class=link href=/zh/news>新闻</a></div><div class=cate><h2 class=cate-title>订阅邮件组</h2><a class=link href=/zh/community/subscribe-email/>如何订阅</a>
<a class=link href=mailto://dev-subscribe@shenyu.apache.org>订阅邮件</a>
<a class=link href=https://lists.apache.org/list.html?dev@shenyu.apache.org>邮件归档</a></div></div><div class=qrcode><div><img class=qrcode-img src=/img/qrcode/WechatIMG127.jpeg><p class=qrcode-desc>微信公众号</p></div></div></div><div class=copyright><p>Copyright © 2021 The Apache Software Foundation. Licensed under the Apache License, Version 2.0.
Apache ShenYu, Apache Incubator, Apache, the Apache feather logo, the Apache ShenYu logo and the Apache Incubator project logo are trademarks of The Apache Software Foundation.
Apache ShenYu is an effort undergoing incubation at The Apache Software Foundation (ASF), sponsored by the Apache Incubator.
Incubation is required of all newly accepted projects until a further review indicates that the infrastructure, communications, and decision making process have stabilized in a manner consistent with other successful ASF projects.
While incubation status is not necessarily a reflection of the completeness or stability of the code,
it does indicate that the project has yet to be fully endorsed by the ASF.</p></div></footer></body></html>