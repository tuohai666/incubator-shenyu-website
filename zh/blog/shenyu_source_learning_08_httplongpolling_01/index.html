<!doctype html><html><head><title>Apache ShenYu网关学习Http长轮询解析01 · Apache ShenYu</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="The girl on the prairie"><meta name=generator content="Hugo 0.55.5"><link rel="shortcut icon" href=/img/favicon.png type=image/png><link href=https://unpkg.com/purecss@1.0.0/build/base-min.css rel=stylesheet><link href=/css/main.css rel=stylesheet><link href=/css/zoom-image.css rel=stylesheet><script src=/js/iconfont.js></script><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script><script>window.SITE_LANGUAGE="zh"</script><script src=/js/app.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-187960192-2','auto');ga('send','pageview');}</script></head><body><header class=ss-header><nav class=navbar role=navigation aria-label="main navigation"><div class=navbar-brand><a class=logo-link style=font-size:25px;margin-right:50px href=/zh/><img class=logo src=/img/logo/apache-shenyu.png></a><div class=-show-mobile><a id=mobile-menu-icon><svg class="icon" aria-hidden="true"><use xlink:href="#icon-menu"/></svg></a><nav id=mobile-menu><div id=js-menu-search-mobile class=navbar-search-mobile><input class=input placeholder=请输入要搜索的关键词><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div><a href=/zh/projects/shenyu/download/><span>下载</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/projects/shenyu/overview/><span>文档</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/community/subscribe-email/><span>社区</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/news/><span>新闻</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/awesome/><span>Awesome</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/blog/shenyu_source_learning_08_httplongpolling_01/><span>English</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-transfer"/></svg></a></nav></div></div><div class="navbar-menu -hidden-mobile"><div class=navbar-start><a class=navbar-item href=/zh/projects/shenyu/download/>下载</a>
<a class=navbar-item href=/zh/projects/shenyu/overview/>文档</a>
<a class=navbar-item href=/zh/community/subscribe-email/>社区</a>
<a class=navbar-item href=/zh/news/>新闻</a>
<a class=navbar-item href=/zh/awesome/>Awesome</a>
<span class="navbar-item nav-hover"><a>Links</a><div class=dropdown-menu><a class=dropdown-item href=https://www.apache.org/>Apache Software Foundation</a>
<a class=dropdown-item href=https://github.com/apache/incubator-shenyu/issues>GitHub Issue Tracker</a>
<a class=dropdown-item href=https://www.apache.org/>License</a>
<a class=dropdown-item href=http://www.apache.org/events/current-event>Apache Events</a>
<a class=dropdown-item href=https://www.apache.org/licenses/>Security</a>
<a class=dropdown-item href=http://www.apache.org/foundation/sponsorship.html>Sponsor and Donate</a>
<a class=dropdown-item href=http://www.apache.org/foundation/thanks.html>Thanks</a></div></span></div><div class=navbar-end><div class=navbar-item><div id=js-menu-search class=navbar-search><input class=input placeholder=请输入要搜索的关键词><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div></div><div class=navbar-item><a class=translation href=/blog/shenyu_source_learning_08_httplongpolling_01/>En</a></div></div></div></nav></header><div class=ss-layout-container><main class="ss-layout-main -card"><div class=ss-meta><h1 class=title>Apache ShenYu网关学习Http长轮询解析01</h1><div class=meta>2021-01-25 ·
朱明 ·
<span class=tags><a class=tag href=/zh/tags/apache-shenyu/ rel=tag>#Apache ShenYu</a></span></div></div><article class=typo><h2 id=后台与网关数据同步-http长轮询篇>后台与网关数据同步 (Http长轮询篇)</h2><h3 id=配置>配置</h3><p><strong>后台信息模式切换</strong></p><p>在上篇分析 Zookeeper 同步的文章 (<a href=https://blog.csdn.net/zm469568595/article/details/113065463>ShenYu网关源码分析-11期</a>) 中, 我们通过 DataSyncConfiguration 这个配置类做的切换, 这次有了经验, 直接贴配置</p><pre><code class=language-yml>soul:
  sync:
    websocket:
      enabled: false
    http:
      enabled: true
</code></pre><p><strong>网关信息模式切换</strong></p><p>后台模式切换完成, 接下来就是网关, 继续照葫芦画瓢找到关键配置类上的参数设置. 这里也直接贴网关配置</p><pre><code class=language-yml>soul:
  sync:
#        websocket:
#            urls: ws://localhost:9095/websocket
  http:
    url: http://localhost:9095
</code></pre><h3 id=datachangedlistener-体系>DataChangedListener 体系</h3><p>后台数据初始化 DataSyncConfiguration 配置关键 Bean , 看看这里关于 Http 长轮询的 Bean</p><pre><code class=language-java>@Configuration
public class DataSyncConfiguration {
  
  @Configuration
  @ConditionalOnProperty(name = &quot;soul.sync.http.enabled&quot;, havingValue = &quot;true&quot;)
  @EnableConfigurationProperties(HttpSyncProperties.class)
  static class HttpLongPollingListener {

    @Bean
    @ConditionalOnMissingBean(HttpLongPollingDataChangedListener.class)
    public HttpLongPollingDataChangedListener httpLongPollingDataChangedListener(final HttpSyncProperties httpSyncProperties) {
      return new HttpLongPollingDataChangedListener(httpSyncProperties);
    }
  }
}
</code></pre><p>HttpLongPollingDataChangedListener 继承自 AbstractDataChangedListener, 他们都实现自接口 DataChangedListener.</p><p>DataChangedListener 这个接口我们应该非常熟悉了, 它提供了众多不同数据类型变动的方法, 供 DataChangedEventDispatcher 调用, 这个类更是一个 &ldquo;老朋友&rdquo; 了, 作为一个中转站, 辛勤的<strong>处理数据同步的事件分类及分发</strong></p><pre><code class=language-java>public class DataChangedEventDispatcher implements ApplicationListener&lt;DataChangedEvent&gt;, InitializingBean {
  // 持有 DataChangedListener 集合
  private List&lt;DataChangedListener&gt; listeners;
  
  // 事件变动时, 通知 DataChangedListener 的不同事件类型的方法
  public void onApplicationEvent(final DataChangedEvent event) {
    for (DataChangedListener listener : listeners) {
      switch (event.getGroupKey()) {
        case APP_AUTH:
          listener.onAppAuthChanged((List&lt;AppAuthData&gt;) event.getSource(), event.getEventType());
          break;
        case PLUGIN:
          listener.onPluginChanged((List&lt;PluginData&gt;) event.getSource(), event.getEventType());
          break;
        case RULE:
          listener.onRuleChanged((List&lt;RuleData&gt;) event.getSource(), event.getEventType());
          break;
        case SELECTOR:
          listener.onSelectorChanged((List&lt;SelectorData&gt;) event.getSource(), event.getEventType());
          break;
        case META_DATA:
          listener.onMetaDataChanged((List&lt;MetaData&gt;) event.getSource(), event.getEventType());
          break;
        default:
          throw new IllegalStateException(&quot;Unexpected value: &quot; + event.getGroupKey());
      }
    }
  }
}
</code></pre><pre><code class=language-java>public interface DataChangedListener {
    
  default void onAppAuthChanged(List&lt;AppAuthData&gt; changed, DataEventTypeEnum eventType) {}

  default void onPluginChanged(List&lt;PluginData&gt; changed, DataEventTypeEnum eventType) {}

  default void onSelectorChanged(List&lt;SelectorData&gt; changed, DataEventTypeEnum eventType) {}

  default void onMetaDataChanged(List&lt;MetaData&gt; changed, DataEventTypeEnum eventType) {}

  default void onRuleChanged(List&lt;RuleData&gt; changed, DataEventTypeEnum eventType) {}
}
</code></pre><p>这两个的作用了解了, 那 AbstractDataChangedListener 又做了什么事情? 举个 onPluginChanged() 的例子:</p><pre><code class=language-java>public abstract class AbstractDataChangedListener implements DataChangedListener, InitializingBean {
  
  protected static final ConcurrentMap&lt;String, ConfigDataCache&gt; CACHE = new ConcurrentHashMap&lt;&gt;();

    @Override
  public void onPluginChanged(final List&lt;PluginData&gt; changed, final DataEventTypeEnum eventType) {
    if (CollectionUtils.isEmpty(changed)) {
      return;
    }
    this.updatePluginCache();
    this.afterPluginChanged(changed, eventType);
  }
  
  // 修改缓存 (可重写)
  protected void updatePluginCache() {
    this.updateCache(ConfigGroupEnum.PLUGIN, pluginService.listAll());
  }
  
  protected &lt;T&gt; void updateCache(final ConfigGroupEnum group, final List&lt;T&gt; data) {
    String json = GsonUtils.getInstance().toJson(data);
    ConfigDataCache newVal = new ConfigDataCache(group.name(), json, Md5Utils.md5(json), System.currentTimeMillis());
    ConfigDataCache oldVal = CACHE.put(newVal.getGroup(), newVal);
    log.info(&quot;update config cache[{}], old: {}, updated: {}&quot;, group, oldVal, newVal);
  }
  
  // 钩子, 自定义结束数据变动后要干什么 (可重写)
  protected void afterPluginChanged(final List&lt;PluginData&gt; changed, final DataEventTypeEnum eventType) {
  }
}
</code></pre><p>对于一个插件数据变动方法 (onPluginChanged), 其实 AbstractDataChangedListener 就是定义了一个模板, 让子类可以按照指定步骤进行工作, 具体每个步骤的工作细节可以由子类自己实现.</p><p>其次, 如果不重写它的缓存更新, 就由这个类在 CACHE 中维护.</p><h3 id=其他同步策略此时在干什么>其他同步策略此时在干什么?</h3><p>在 DataChangedEventDispatcher 调取 onPluginChanged() 之后, 长轮询模块会怎么实现呢? <strong>不妨先想想其他同步方式在此时做了什么</strong></p><p>举例 websocket 模式, 它自己重写了 onPluginChanged(), 发送 websocket 信息给持有会话, 其中就有网关.</p><pre><code class=language-java>public class WebsocketDataChangedListener implements DataChangedListener {
  
    @Override
  public void onPluginChanged(final List&lt;PluginData&gt; pluginDataList, final DataEventTypeEnum eventType) {
    WebsocketData&lt;PluginData&gt; websocketData =
      new WebsocketData&lt;&gt;(ConfigGroupEnum.PLUGIN.name(), eventType.name(), pluginDataList);
    WebsocketCollector.send(GsonUtils.getInstance().toJson(websocketData), eventType);
  }
}
</code></pre><p>再看 zookeeper 模式, 它也重写了 onPluginChanged(), 去修改 zookeeper 上的节点信息, 这样网关端会监听到他们的节点变动.</p><pre><code class=language-java>public class ZookeeperDataChangedListener implements DataChangedListener {
  
    @Override
  public void onPluginChanged(final List&lt;PluginData&gt; changed, final DataEventTypeEnum eventType) {
    for (PluginData data : changed) {
      String pluginPath = ZkPathConstants.buildPluginPath(data.getName());
      // delete
      if (eventType == DataEventTypeEnum.DELETE) {
        deleteZkPathRecursive(pluginPath);
        String selectorParentPath = ZkPathConstants.buildSelectorParentPath(data.getName());
        deleteZkPathRecursive(selectorParentPath);
        String ruleParentPath = ZkPathConstants.buildRuleParentPath(data.getName());
        deleteZkPathRecursive(ruleParentPath);
        continue;
      }
      //create or update
      insertZkNode(pluginPath, data);
    }
  }
}
</code></pre><p>可以知道, 到这个节骨眼, 其他同步策略已经在忙着通知网关了, 那 Http 长轮询也肯定要做这事.</p><p>这两个策略的通知方式也不同, websocket 是好人做到底, 直接找到 session 会话把信息亲自送过去. zookeeper 将节点信息改变后撒手不管, 网关自己监听到变更再做的同步.</p><p>那么我们的 Http 长轮询现在要以何种方式去通知网关呢? 接着看.</p><h3 id=长轮询实现方式思考>长轮询实现方式思考</h3><p>先思考下我自己设计长轮询, 会怎么实现 ?</p><p>正常的长轮询实现应该由网关主动请求, 后台接住这个请求并hold住, 如果有更新就直接返回, 没有就阻塞一定时间. 而后台则是做好数据的更新, hold住时检查数据是否有变化.</p><p>那这里涉及到三个点:</p><ol><li>数据怎样知道是有变化的, 是不是设置个最后更新时间, 与网关的请求时间比较, 得出是否有数据修改?</li><li>hold住之后, 后台怎么获知是否数据更新, 反复遍历还是阻塞等待?</li><li>那些用于更新的数据放哪里, 用缓存的话, 考虑后台缓存与数据库的交互是怎样的.</li></ol><h3 id=httplongpollingdatachangedlistener-长轮询实现>HttpLongPollingDataChangedListener 长轮询实现</h3><p>围绕我们的思考, 看看 HttpLongPollingDataChangedListener 是如何实现的. 先看看关于父类 onPluginChanged() 这块的实现</p><pre><code class=language-java>public class HttpLongPollingDataChangedListener extends AbstractDataChangedListener {
  
  private final ScheduledExecutorService scheduler;
  
  @Override
  protected void afterPluginChanged(final List&lt;PluginData&gt; changed, final DataEventTypeEnum eventType) {
    scheduler.execute(new DataChangeTask(ConfigGroupEnum.PLUGIN));
  }
}
</code></pre><p>Http 长轮询不会直接覆盖 onPluginChanged() 而是直接使用其父类的, 意味着使用了它的 CACHE, 那最终我们的信息获取肯定也少不了分析这个, 先暂放一边.</p><p>接下来的逻辑会调用到我们这块实现的 afterPluginChanged() 方法, 这里用了一个定时类型的线程池, 去跑一个 Runnable 类型的任务 DataChangeTask.</p><pre><code class=language-java>class DataChangeTask implements Runnable {
  
  @Override
  public void run() {
    // 遍历 clients
    for (Iterator&lt;LongPollingClient&gt; iter = clients.iterator(); iter.hasNext();) {
      LongPollingClient client = iter.next();
      iter.remove();
      // 说明完成 response 响应了
      client.sendResponse(Collections.singletonList(groupKey));
      log.info(&quot;send response with the changed group,ip={}, group={}, changeTime={}&quot;, client.ip, groupKey, changeTime);
    }
  }
}
</code></pre><p>数据变动后使用线程池调到了这个方法, 拿取所有 <code>clients</code> , 一边遍历一边剔除元素, 且调用方法 sendResponse(), 像是标记已完成了响应.</p><p>我来猜测下它干了什么, 这里的 <code>clients</code> 很有可能就是网关被 hold 住的请求, 而 sendResponse() 则很有可能就是真的给请求上下文加了响应信息. 还有一个关键动作就是结束 hold, 让网关接收到响应信息, 并在集合中剔除这个请求.</p><p>我们现在追踪下 <code>client</code> 的产生, 它是 HttpLongPollingDataChangedListener 里的一个 BlockingQueue 阻塞队列, 在 LongPollingClient 中被定时检测</p><pre><code class=language-java>class LongPollingClient implements Runnable {
  
  @Override
  public void run() {
    this.asyncTimeoutFuture = scheduler.schedule(() -&gt; {
      clients.remove(LongPollingClient.this);
      List&lt;ConfigGroupEnum&gt; changedGroups = compareChangedGroup((HttpServletRequest) asyncContext.getRequest());
      sendResponse(changedGroups);
    }, timeoutTime, TimeUnit.MILLISECONDS);
    // 这里是关键, 表明来源
    clients.add(this);
  }
}
</code></pre><p>先不去分析这个 remove() 的检测代码块, 直接看到最后一句的 add(), 这里就是 <code>clients</code> 数据来源.</p><p>找到 LongPollingClient 被调用处, HttpLongPollingDataChangedListener#doLongPolling</p><pre><code class=language-java>public void doLongPolling(final HttpServletRequest request, final HttpServletResponse response) {

  // ...

  // listen for configuration changed.
  // 开启同步阻塞请求
  final AsyncContext asyncContext = request.startAsync();

  // AsyncContext.settimeout() does not timeout properly, so you have to control it yourself
  asyncContext.setTimeout(0L);

  // block client's thread.
  // 线程池调用 LongPollingClient#run
  scheduler.execute(new LongPollingClient(asyncContext, clientIp, HttpConstants.SERVER_MAX_HOLD_TIMEOUT));
}
</code></pre><p>这里的最后一句会调用并添加 <code>client</code>, 这里有行关键代码阻塞住了请求:</p><pre><code class=language-java>final AsyncContext asyncContext = request.startAsync();
</code></pre><p>而在 LongPollingClient#sendResponse 中, 刚刚也分析了, 除了包装注入响应信息, 还会将hold住的请求释放</p><pre><code class=language-java>class LongPollingClient implements Runnable {
  
    void sendResponse(final List&lt;ConfigGroupEnum&gt; changedGroups) {
    // cancel scheduler
    if (null != asyncTimeoutFuture) {
      asyncTimeoutFuture.cancel(false);
    }
    generateResponse((HttpServletResponse) asyncContext.getResponse(), changedGroups);
    // 同步完成结束阻塞
    asyncContext.complete();
  }
}
</code></pre><p>这块分析完了再回到 doLongPolling(), 其中线程池调用这还有个关键点</p><pre><code class=language-java>scheduler.execute(new LongPollingClient(asyncContext, clientIp, HttpConstants.SERVER_MAX_HOLD_TIMEOUT));
</code></pre><p>这里给 LongPollingClient 传入了 60S 的 timeout 时间, 做什么用的呢? 还记得我们在 LongPollingClient#run 时略过的一块代码吗</p><pre><code class=language-java>class LongPollingClient implements Runnable {
  
  @Override
  public void run() {
    // 定时启动, 延迟时间根据 timeoutTime
    this.asyncTimeoutFuture = scheduler.schedule(() -&gt; {
      // 移除管理的连接
      clients.remove(LongPollingClient.this);
      List&lt;ConfigGroupEnum&gt; changedGroups = compareChangedGroup((HttpServletRequest) asyncContext.getRequest());
      // 这个方法会将阻塞的请求释放
      sendResponse(changedGroups);
    }, timeoutTime, TimeUnit.MILLISECONDS);

    clients.add(this);
  }
}
</code></pre><p>这里我们已经搞懂了后台这块对长轮询流程的实现, 最后再看看 doLongPolling() 是怎么被调用到的, 找到调用类 ConfigController</p><pre><code class=language-java>@ConditionalOnBean(HttpLongPollingDataChangedListener.class)
@RestController
@RequestMapping(&quot;/configs&quot;)
@Slf4j
public class ConfigController {
  
  @PostMapping(value = &quot;/listener&quot;)
  public void listener(final HttpServletRequest request, final HttpServletResponse response) {
    longPollingListener.doLongPolling(request, response);
  }
}
</code></pre><p>看到这也基本明了, 后台通过这个 Controller 暴露 http 路径供网关调用并监听数据变化.</p><h3 id=总结>总结</h3><ul><li>后台通过 Controller 层暴露 API 给网关, 网关请求后台时后台并不是立即返回响应 (数据有无变化), 而是 hold 住请求最大 60 秒的时间. 这些被 hold 住的请求会加入到阻塞队列中作为内存缓存.</li><li>这 60 秒钟如果有数据变化, 通过 DataChangedEventDispatcher 分发到我们的 HttpLongPollingDataChangedListener , 则 <strong>立即调用线程池</strong> 在阻塞队列中遍历所有被 hold 住的请求, 塞入响应信息并释放掉.</li><li>如果 60 秒过后依然没有数据变化, hold 住的请求会被释放, 且阻塞队列的对应请求对象被剔除.</li></ul><p>到这里, 我们已经理清它最最基本的长轮询逻辑, 那么对应下一开始的思考, 看有什么结论or疑惑.</p><blockquote><ol><li>数据怎样知道是有变化的, 是不是设置个最后更新时间, 与网关的请求时间比较, 得出是否有数据修改?</li><li>hold住之后, 后台怎么获知是否数据更新, 反复遍历还是阻塞等待?</li><li>那些用于更新的数据放哪里, 用缓存的话, 考虑后台缓存与数据库的交互是怎样的.</li></ol></blockquote><p>针对第 1 点, 我们是如何得知数据有变化的呢?</p><ul><li>目前我们分析的数据变动来源是 DataChangedEventDispatcher, 它可不仅仅只会在数据变动时告知我们信息, 每次手动点下后台同步这里立马就来调用了.</li></ul><p>那么这里肯定有新旧数据比对之类的东西了, 不然每次调用就直接把网关的阻塞请求放跑了, 这可不成, 白白的IO 消耗肯定不是个好设计.</p><p>针对第 2 点, 我们现在知道了模式是阻塞等待, 利用的是 <code>AsyncContext</code> 这种方式, 这块我也没有了解过, 会出个番外讨论一二.</p><p>针对第 3 点, 我们知道后台配置肯定修改完是要落盘到数据库的, 所以这块缓存与数据库的交互也是个值得分析的点. 这些疑问我会在下一章继续分析~</p></article><div class=-show-mobile><nav class=ss-pagination-next><a class=link-prev href=/zh/blog/shenyu_source_learning_10_websocket/><span class=text>上一篇:</span>
<span class=text>Apache ShenYu网关学习WebSocket数据同步解析</span></a>
<a class=link-next href=/zh/blog/shenyu_source_learning_14_nacos/><span class=text>下一篇:</span>
<span class=text>Apache ShenYu网关学习Nacos数据同步</span></a></nav></div></main><aside class=ss-layout-aside><div class=ss-card><h2 class=card-title>相关推荐</h2><ul class=ss-aside-related><li><a href=/zh/blog/shenyu_source_learning_10_websocket/>Apache ShenYu网关学习WebSocket数据同步解析</a></li><li><a href=/zh/blog/shenyu_source_learning_13_zookeeper_02/>Apache ShenYu网关学习Zookeeper数据同步02</a></li><li><a href=/zh/blog/shenyu_source_learning_15_plugin_chain/>Apache ShenYu网关学习插件链实现</a></li><li><a href=/zh/blog/shenyu_resource_learning_07_admin/>Apache ShenYu网关学习Admin源码分析</a></li><li><a href=/zh/blog/shenyu_source_learning_13_zookeeper_01/>Apache ShenYu网关学习Zookeeper数据同步01</a></li></ul></div><div class="ss-aside-tags ss-card"><h2 class=card-title>标签
<span class=card-extra></span></h2><ul class=tag-list><li class=tag><a href=/zh/tags/apache-shenyu/>Apache ShenYu</a></li><li class=tag><a href=/zh/tags/code-conduct/>Code Conduct</a></li><li class=tag><a href=/zh/tags/committer/>Committer</a></li><li class=tag><a href=/zh/tags/contributor/>Contributor</a></li><li class=tag><a href=/zh/tags/dreamcode/>DreamCode</a></li><li class=tag><a href=/zh/tags/gateway/>GateWay</a></li><li class=tag><a href=/zh/tags/icla/>ICLA</a></li><li class=tag><a href=/zh/tags/issue-pr/>Issue-PR</a></li><li class=tag><a href=/zh/tags/reactor/>Reactor</a></li><li class=tag><a href=/zh/tags/shenyu/>ShenYu</a></li><li class=tag><a href=/zh/tags/subscribe-email/>Subscribe-Email</a></li><li class=tag><a href=/zh/tags/two-fa/>Two-FA</a></li><li class=tag><a href=/zh/tags/vote-committer/>Vote-Committer</a></li></ul></div></aside></div><footer class=ss-footer><div class=container><div class=links><div class="cate  -show-mobile"><h2 class=cate-title>Apache</h2><a class=link href=https://www.apache.org/>Foundation</a>
<a class=link href=https://github.com/apache/incubator-shenyu/issues>GitHub Issue Tracker</a>
<a class=link href=https://www.apache.org/licenses/>License</a>
<a class=link href=https://www.apache.org/security/>Security</a>
<a class=link href=http://www.apache.org/events/current-event>Events</a>
<a class=link href=http://www.apache.org/foundation/sponsorship.html>Sponsorship</a>
<a class=link href=http://www.apache.org/foundation/thanks.html>Thanks</a></div><div class=cate><h2 class=cate-title>资源</h2><a class=link href=https://github.com/apache/incubator-shenyu>Github</a>
<a class=link href=/zh/projects/shenyu/overview/>文档</a></div><div class=cate><h2 class=cate-title>参与进来</h2><a class=link href=https://github.com/apache/incubator-shenyu/issues/new>反馈</a>
<a class=link href=/zh/community>社区</a>
<a class=link href=/zh/news>新闻</a></div><div class=cate><h2 class=cate-title>订阅邮件组</h2><a class=link href=/zh/community/subscribe-email/>如何订阅</a>
<a class=link href=mailto://dev-subscribe@shenyu.apache.org>订阅邮件</a>
<a class=link href=https://lists.apache.org/list.html?dev@shenyu.apache.org>邮件归档</a></div></div><div class=qrcode><div><img class=qrcode-img src=/img/qrcode/WechatIMG127.jpeg><p class=qrcode-desc>微信公众号</p></div></div></div><div class=copyright><p>Copyright © 2021 The Apache Software Foundation. Licensed under the Apache License, Version 2.0.
Apache ShenYu, Apache Incubator, Apache, the Apache feather logo, the Apache ShenYu logo and the Apache Incubator project logo are trademarks of The Apache Software Foundation.
Apache ShenYu is an effort undergoing incubation at The Apache Software Foundation (ASF), sponsored by the Apache Incubator.
Incubation is required of all newly accepted projects until a further review indicates that the infrastructure, communications, and decision making process have stabilized in a manner consistent with other successful ASF projects.
While incubation status is not necessarily a reflection of the completeness or stability of the code,
it does indicate that the project has yet to be fully endorsed by the ASF.</p></div></footer></body></html>