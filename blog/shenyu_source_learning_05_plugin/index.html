<!doctype html><html><head><title>Apache ShenYu Gateway learning plugin chain and load balancing analysis · Apache ShenYu</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="The girl on the prairie"><meta name=generator content="Hugo 0.55.5"><link rel="shortcut icon" href=/img/favicon.png type=image/png><link href=https://unpkg.com/purecss@1.0.0/build/base-min.css rel=stylesheet><link href=/css/main.css rel=stylesheet><link href=/css/zoom-image.css rel=stylesheet><script src=/js/iconfont.js></script><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script><script>window.SITE_LANGUAGE="en"</script><script src=/js/app.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-187960192-2','auto');ga('send','pageview');}</script></head><body><header class=ss-header><nav class=navbar role=navigation aria-label="main navigation"><div class=navbar-brand><a class=logo-link style=font-size:25px;margin-right:50px href=/><img class=logo src=/img/logo/apache-shenyu.png></a><div class=-show-mobile><a id=mobile-menu-icon><svg class="icon" aria-hidden="true"><use xlink:href="#icon-menu"/></svg></a><nav id=mobile-menu><div id=js-menu-search-mobile class=navbar-search-mobile><input class=input placeholder=Search><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div><a href=/projects/shenyu/download/><span>Download</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/projects/shenyu/overview/><span>Documentation</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/community/subscribe-email/><span>Community</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/news/><span>News</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/awesome/><span>Awesome</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/blog/shenyu_source_learning_05_plugin/><span>中文</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-transfer"/></svg></a></nav></div></div><div class="navbar-menu -hidden-mobile"><div class=navbar-start><a class=navbar-item href=/projects/shenyu/download/>Download</a>
<a class=navbar-item href=/projects/shenyu/overview/>Documentation</a>
<a class=navbar-item href=/community/subscribe-email/>Community</a>
<a class=navbar-item href=/news/>News</a>
<a class=navbar-item href=/awesome/>Awesome</a>
<span class="navbar-item nav-hover"><a>Links</a><div class=dropdown-menu><a class=dropdown-item href=https://www.apache.org/>Apache Software Foundation</a>
<a class=dropdown-item href=https://github.com/apache/incubator-shenyu/issues>GitHub Issue Tracker</a>
<a class=dropdown-item href=https://www.apache.org/>License</a>
<a class=dropdown-item href=http://www.apache.org/events/current-event>Apache Events</a>
<a class=dropdown-item href=https://www.apache.org/licenses/>Security</a>
<a class=dropdown-item href=http://www.apache.org/foundation/sponsorship.html>Sponsor and Donate</a>
<a class=dropdown-item href=http://www.apache.org/foundation/thanks.html>Thanks</a></div></span></div><div class=navbar-end><div class=navbar-item><div id=js-menu-search class=navbar-search><input class=input placeholder=Search><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div></div><div class=navbar-item><a class=translation href=/zh/blog/shenyu_source_learning_05_plugin/>中</a></div></div></div></nav></header><div class=ss-layout-container><main class="ss-layout-main -card"><div class=ss-meta><h1 class=title>Apache ShenYu Gateway learning plugin chain and load balancing analysis</h1><div class=meta>2021-01-15 ·
zhuming ·
<span class=tags><a class=tag href=/tags/apache-shenyu/ rel=tag>#Apache ShenYu</a></span></div></div><article class=typo><h1 id=插件链总结>插件链总结</h1><p>从一个类关系图说起:</p><p><img src=01.png alt=plugin关系图></p><p>其中两个最基本的插件类:</p><ul><li><p>SoulPlugin: 定义插件职责的接口, 重点方法<code>execute()</code> 被上层调用, <code>skip()</code> 方法可以使某些插件在某些请求中被跳过.</p></li><li><p>AbstractPlugin: 抽象类, 实现接口的 <code>execute()</code>, 定义一套通用的执行流程, 并使用模板方法的设计模式, 提供<code>doExecute()</code>抽象方法供实现类写自己的逻辑.</p></li></ul><h2 id=abstractsoulplugin>AbstractSoulPlugin</h2><p>具体分析下 <code>AbstractSoulPlugin</code> 类的 <code>execute()</code>:</p><pre><code class=language-java>public Mono&lt;Void&gt; execute(final ServerWebExchange exchange, final SoulPluginChain chain) {
  String pluginName = named();
  final PluginData pluginData = BaseDataCache.getInstance().obtainPluginData(pluginName);
  // 如果 pluginData.getEnabled() 为 false, 会直接跳到下个插件, 仅有为数不多的插件会进入这个条件判断 (DividePlugin、AlibabaDubboPlugin等)
  if (pluginData != null &amp;&amp; pluginData.getEnabled()) {
    // 获得插件上的所有选择器
    final Collection&lt;SelectorData&gt; selectors = BaseDataCache.getInstance().obtainSelectorData(pluginName);
    if (CollectionUtils.isEmpty(selectors)) {
      return CheckUtils.checkSelector(pluginName, exchange, chain);
    }
    // 检查上下文中的请求路径, 是否与选择器匹配, 并得到唯一一个匹配的选择器数据
    final SelectorData selectorData = matchSelector(exchange, selectors);
    if (Objects.isNull(selectorData)) {
      if (PluginEnum.WAF.getName().equals(pluginName)) {
        return doExecute(exchange, chain, null, null);
      }
      return CheckUtils.checkSelector(pluginName, exchange, chain);
    }
    if (selectorData.getLoged()) {
      log.info(&quot;{} selector success match , selector name :{}&quot;, pluginName, selectorData.getName());
    }
    // 获得选择器中的各个资源规则
    final List&lt;RuleData&gt; rules = BaseDataCache.getInstance().obtainRuleData(selectorData.getId());
    if (CollectionUtils.isEmpty(rules)) {
      if (PluginEnum.WAF.getName().equals(pluginName)) {
        return doExecute(exchange, chain, null, null);
      }
      return CheckUtils.checkRule(pluginName, exchange, chain);
    }
    RuleData rule;
    if (selectorData.getType() == SelectorTypeEnum.FULL_FLOW.getCode()) {
      rule = rules.get(rules.size() - 1);
    } else {
      // 匹配路径, 获得唯一一个规则
      rule = matchRule(exchange, rules);
    }
    if (Objects.isNull(rule)) {
      return CheckUtils.checkRule(pluginName, exchange, chain);
    }
    if (rule.getLoged()) {
      log.info(&quot;{} rule success match ,rule name :{}&quot;, pluginName, rule.getName());
    }
    // 执行子类的方法
    return doExecute(exchange, chain, selectorData, rule);
  }
  // 执行插件链上的下个插件
  return chain.execute(exchange);
}
</code></pre><p>通过代码分析, 可以得到一些结论:</p><ul><li>execute() 有两个逻辑: 一是请求路径与选择器和规则的匹配, 最终确认一个唯一规则, 并调用子类 doExecute(); 二是执行插件链上的下个插件.</li><li>execute() 实际抽象了一套规则匹配逻辑, 供所有&rdquo;转发类型&rdquo;的插件使用的, 转发类型的插件目前我了解的有 <code>DividePlugin</code> (http请求) 和 <code>AlibabaDubboPlugin</code> (dubbo请求), 其他类型的插件如果不重写 execute() 的方法, 会直接走入下个插件.</li></ul><h2 id=soulpluginchain>SoulPluginChain</h2><p>这里还有个点, 就是插件链的形成与链式调用, 我们来分析下 <code>SoulPluginChain</code> 这块:</p><p><img src=02.png alt=plugin02></p><p>SoulPluginChain 接口同样定义了 <code>execute()</code> 方法供调用者使用, 它的唯一子类 DefaultSoulPluginChain 实现了链式调用:</p><pre><code class=language-java>public Mono&lt;Void&gt; execute(final ServerWebExchange exchange) {
  return Mono.defer(() -&gt; {
    // plugins 中包含所有网关加载的插件
    if (this.index &lt; plugins.size()) {
      // 每次调用execute()方法, index索引自增, 会调用到下一个插件
      SoulPlugin plugin = plugins.get(this.index++);
      // 结合上下文判断当前插件是否需要跳过
      Boolean skip = plugin.skip(exchange);
      if (skip) {
        return this.execute(exchange);
      } else {
        return plugin.execute(exchange, this);
      }
    } else {
      return Mono.empty();
    }
  });
}
</code></pre><p>看到这会很好奇 <code>plugins</code> 这个插件列表是哪里来的, 这里来解释下, DefaultSoulPluginChain 是 SoulWebHandler 的静态内部类, <code>plugins</code>就是 SoulWebHandle 中的一个属性:</p><pre><code class=language-java>public final class SoulWebHandler implements WebHandler {
    
    private List&lt;SoulPlugin&gt; plugins;

    public SoulWebHandler(final List&lt;SoulPlugin&gt; plugins) {
        this.plugins = plugins;
        // ...
    }
  
    @Override
    public Mono&lt;Void&gt; handle(@NonNull final ServerWebExchange exchange) {
                // ...
        return new DefaultSoulPluginChain(plugins).execute(exchange).subscribeOn(scheduler)
                .doOnSuccess(t -&gt; startTimer.ifPresent(time -&gt; MetricsTrackerFacade.getInstance().histogramObserveDuration(time)));
    }
  
    private static class DefaultSoulPluginChain implements SoulPluginChain {
    }
}
</code></pre><p>那么 SoulWebHandler 中的 <code>plugins</code> 又是怎么来的呢? 可以继续追溯下它构造器被调用的地方:</p><pre><code class=language-java>@Configuration
public class SoulConfiguration {
    
    @Bean(&quot;webHandler&quot;)
    public SoulWebHandler soulWebHandler(final ObjectProvider&lt;List&lt;SoulPlugin&gt;&gt; plugins) {
        List&lt;SoulPlugin&gt; pluginList = plugins.getIfAvailable(Collections::emptyList);
        final List&lt;SoulPlugin&gt; soulPlugins = pluginList.stream()
                .sorted(Comparator.comparingInt(SoulPlugin::getOrder)).collect(Collectors.toList());
        soulPlugins.forEach(soulPlugin -&gt; log.info(&quot;loader plugin:[{}] [{}]&quot;, soulPlugin.named(), soulPlugin.getClass().getName()));
        return new SoulWebHandler(soulPlugins);
    }
}
</code></pre><p>可以看到是通过 Spring Bean的方式开始写入 <code>plugins</code>, 即在容器启动时, 加载了所有插件. 这里入口参数使用 <code>ObjectProvider</code> 就是延迟加载所有 SoulPlugin 类型的 Bean(若一个都没有也不会报错), 并注入到 SoulWebHandler 中.</p><p><strong>有个小坑需要注意 !</strong></p><p>包括 DividePlugin、AlibabaDubboPlugin等等的所有插件, 都是由各自的 <code>soul-spring-boot-starter-plugin-xx</code> 项目中的 XXPluginConfiguration 配置类, 注册自己的插件成为 Bean, 类似下面示例:</p><pre><code class=language-java>@Configuration
public class DividePluginConfiguration {

    @Bean
    public SoulPlugin dividePlugin() {
        return new DividePlugin();
    }
}
</code></pre><p>所以在网关项目 <code>soul-bootstrap</code> 中, 如果需要用到某个插件, 不仅仅是在管理后台开启这个插件, 还需要确认下 <code>soul-bootstrap</code> 的 <code>pom.xml</code> 中是否存在相关插件所在的 <code>soul-spring-boot-starter-plugin-xx</code> 依赖, 比如:</p><pre><code class=language-xml>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.shenyu&lt;/groupId&gt;
  &lt;artifactId&gt;soul-spring-boot-starter-plugin-divide&lt;/artifactId&gt;
  &lt;version&gt;${project.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>如果这里你给注释了或者根本不存在, 不要幻想在插件链上看到它&hellip;</p><h2 id=插件项目结构>插件项目结构</h2><p>最后简单说下各个插件项目的功能:</p><ol><li><p>首先是刚刚提到的spring bean启动类项目 , 列出个大概:</p><pre><code>soul-spring-boot-starter-plugin-alibaba-dubbo
soul-spring-boot-starter-plugin-apache-dubbo
soul-spring-boot-starter-plugin-context-path
soul-spring-boot-starter-plugin-divide
soul-spring-boot-starter-plugin-global
soul-spring-boot-starter-plugin-httpclient
soul-spring-boot-starter-plugin-hystrix
soul-spring-boot-starter-plugin-monitor
soul-spring-boot-starter-plugin-ratelimiter
soul-spring-boot-starter-plugin-resilience4j
soul-spring-boot-starter-plugin-rewrite
soul-spring-boot-starter-plugin-sentinel
soul-spring-boot-starter-plugin-sign
soul-spring-boot-starter-plugin-sofa
soul-spring-boot-starter-plugin-springcloud
soul-spring-boot-starter-plugin-tars
soul-spring-boot-starter-plugin-waf
</code></pre></li></ol><p>它们的主要作用刚刚也提到了, 将自身的 SoulPlugin子类注册为 spring bean, 以及注册 spring bean 给 AbstractSoulPlugin 中调用到的 PluginDataHandler 接口, 提供自身的实现子类, 比如 DividePluginDataHandler.</p><ol><li><p>具体的插件类所在项目:</p><pre><code>soul-plugin-alibaba-dubbo
soul-plugin-apache-dubbo
soul-plugin-api
soul-plugin-base
soul-plugin-context-path
soul-plugin-divide
soul-plugin-global
soul-plugin-httpclient
soul-plugin-hystrix
soul-plugin-monitor
soul-plugin-ratelimiter
soul-plugin-resilience4j
soul-plugin-rewrite
soul-plugin-sentinel
soul-plugin-sign
soul-plugin-sofa
soul-plugin-springcloud
soul-plugin-tars
soul-plugin-waf
</code></pre></li></ol><p>拿 <code>soul-plugin-divide</code> 项目举例, 刚刚提到的 DividePlugin 与 DividePluginDataHandler 就在其中. 并且项目里还有节点信息缓存管理器 UpstreamCacheManager, 负载均衡策略类 LoadBalance 等等.</p><h1 id=divideplugin>DividePlugin</h1><p>DividePlugin 的作用是匹配 Http 请求, 既然有 Http 请求自然也有转发下游和返回响应, 所以这里我们会分析到三个插件: DividePlugin、WebClientPlugin、WebClientResponsePlugin.</p><p>首先来看 DividePlugin 中 <code>doExecute()</code> 具体实现, 这里我只保留了核心点:</p><pre><code class=language-java>@Override
protected Mono&lt;Void&gt; doExecute(final ServerWebExchange exchange, final SoulPluginChain chain, final SelectorData selector, final RuleData rule) {
  final SoulContext soulContext = exchange.getAttribute(Constants.CONTEXT);
  final DivideRuleHandle ruleHandle = GsonUtils.getInstance().fromJson(rule.getHandle(), DivideRuleHandle.class);
  // 通过选择器ID, 在缓存中得到服务节点集群
  final List&lt;DivideUpstream&gt; upstreamList = UpstreamCacheManager.getInstance().findUpstreamListBySelectorId(selector.getId());
    // 调用负载均衡方法并传入策略类型, 得到唯一节点
  DivideUpstream divideUpstream = LoadBalanceUtils.selector(upstreamList, ruleHandle.getLoadBalance(), ip);
    // 获得节点的真实url, 并放入 exchange 上下文中
  String domain = buildDomain(divideUpstream);
  String realURL = buildRealURL(domain, soulContext, exchange);
  exchange.getAttributes().put(Constants.HTTP_URL, realURL);
  // 继续调用下个插件
  return chain.execute(exchange);
}
</code></pre><p>可以看到, 在执行完 DividePlugin 的 <code>doExecute()</code> 方法后, 我们的 ServerWebExchange 上下文中已经有了下游服务节点的真实路径, 接下来只要请求它就搞定. 不过先别着急, 这里的负载均衡策略也是关键点, 接着分析下.</p><h2 id=负载均衡>负载均衡</h2><p>Soul网关的负载均衡如何执行, 不止涉及到各种策略 (hasn、随机、轮询), 也涉及到 &ldquo;权重分数&rdquo; 这个概念, 管理后台的具体配置如下:</p><p><img src=/img/shenyu/blog1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptNDY5NTY4NTk1,size_16,color_FFFFFF,t_70.png alt></p><p><img src=/img/shenyu/blog1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptNDY5NTY4NTk1,size_16,color_FFFFFF,t_70-20210118110416590.png alt></p><p><img src=/img/shenyu/blog1/image-20210118113516468.png alt=image-20210118113516468></p><p>展示完后台配置, 我们具体看看各个策略的代码实现.</p><h2 id=hash>Hash</h2><pre><code class=language-java>public DivideUpstream doSelect(final List&lt;DivideUpstream&gt; upstreamList, final String ip) {
  final ConcurrentSkipListMap&lt;Long, DivideUpstream&gt; treeMap = new ConcurrentSkipListMap&lt;&gt;();
  for (DivideUpstream address : upstreamList) {
    // 每个节点*VIRTUAL_NODE_NUM(默认5), 使hash更加均匀
    for (int i = 0; i &lt; VIRTUAL_NODE_NUM; i++) {
      long addressHash = hash(&quot;SOUL-&quot; + address.getUpstreamUrl() + &quot;-HASH-&quot; + i);
      treeMap.put(addressHash, address);
    }
  }
  // 从当前ip得到一个hash值, 并比对treemap(有序), 找到大于此hash值的位置
  long hash = hash(String.valueOf(ip));
  SortedMap&lt;Long, DivideUpstream&gt; lastRing = treeMap.tailMap(hash);
  // 只要服务节点不增减, 同一个ip得到的节点就可以保持不变
  if (!lastRing.isEmpty()) {
    return lastRing.get(lastRing.firstKey());
  }
  return treeMap.firstEntry().getValue();
}
</code></pre><p>hash算法的负载均衡, 并没有使用到 &ldquo;权重分数&rdquo; 这个概念, 也就是说针对每个未知的 IP 各个节点被访问的可能性是一致的. (当然, 同一个 IP 多次调用只会访问同个节点)</p><h2 id=randomloadbalance>RandomLoadBalance</h2><pre><code class=language-java>public DivideUpstream doSelect(final List&lt;DivideUpstream&gt; upstreamList, final String ip) {
  // 总个数
  int length = upstreamList.size();
  // 总权重
  int totalWeight = 0;
  // 权重是否都一样
  boolean sameWeight = true;
  for (int i = 0; i &lt; length; i++) {
    int weight = upstreamList.get(i).getWeight();
    // 累计总权重
    totalWeight += weight;
    if (sameWeight &amp;&amp; i &gt; 0
        &amp;&amp; weight != upstreamList.get(i - 1).getWeight()) {
      // 计算所有权重是否一样
      sameWeight = false;
    }
  }
  if (totalWeight &gt; 0 &amp;&amp; !sameWeight) {
    // 如果权重不相同且权重大于0则按总权重数随机
    int offset = RANDOM.nextInt(totalWeight);
    // 并确定随机值落在哪个片断上
    for (DivideUpstream divideUpstream : upstreamList) {
      offset -= divideUpstream.getWeight();
      if (offset &lt; 0) {
        return divideUpstream;
      }
    }
  }
  // 如果权重相同或权重为0则均等随机
  return upstreamList.get(RANDOM.nextInt(length));
}
</code></pre><p>当使用 <code>random</code> 规则时, 所有节点权重分累加并随机得到数字, 看具体是落在那个节点的权重片段上; 如果分数0或者相同则很直接的随机集群长度即可.</p><h2 id=roundrobinloadbalance>RoundRobinLoadBalance</h2><pre><code class=language-java>public DivideUpstream doSelect(final List&lt;DivideUpstream&gt; upstreamList, final String ip) {
  String key = upstreamList.get(0).getUpstreamUrl();
  ConcurrentMap&lt;String, WeightedRoundRobin&gt; map = methodWeightMap.get(key);
  if (map == null) {
    methodWeightMap.putIfAbsent(key, new ConcurrentHashMap&lt;&gt;(16));
    map = methodWeightMap.get(key);
  }
  int totalWeight = 0;
  long maxCurrent = Long.MIN_VALUE;
  long now = System.currentTimeMillis();
  DivideUpstream selectedInvoker = null;
  WeightedRoundRobin selectedWRR = null;
  for (DivideUpstream upstream : upstreamList) {
    String rKey = upstream.getUpstreamUrl();
    // 取出节点在缓存中的信息
    WeightedRoundRobin weightedRoundRobin = map.get(rKey);
    int weight = upstream.getWeight();
    if (weightedRoundRobin == null) {
      weightedRoundRobin = new WeightedRoundRobin();
      weightedRoundRobin.setWeight(weight);
      map.putIfAbsent(rKey, weightedRoundRobin);
    }
    if (weight != weightedRoundRobin.getWeight()) {
      weightedRoundRobin.setWeight(weight);
    }
    // 这里是第一个关键: 缓存中的分数增加当前节点权重分
    long cur = weightedRoundRobin.increaseCurrent();
    weightedRoundRobin.setLastUpdate(now);
    // 选择缓存分值高的节点
    if (cur &gt; maxCurrent) {
      maxCurrent = cur;
      selectedInvoker = upstream;
      selectedWRR = weightedRoundRobin;
    }
    totalWeight += weight;
  }
  if (!updateLock.get() &amp;&amp; upstreamList.size() != map.size() &amp;&amp; updateLock.compareAndSet(false, true)) {
    try {
      ConcurrentMap&lt;String, WeightedRoundRobin&gt; newMap = new ConcurrentHashMap&lt;&gt;(map);
      newMap.entrySet().removeIf(item -&gt; now - item.getValue().getLastUpdate() &gt; recyclePeriod);
      methodWeightMap.put(key, newMap);
    } finally {
      updateLock.set(false);
    }
  }
  if (selectedInvoker != null) {
    // 这里是第二个关键: 缓存中的分数, 减少总节点权重分
    selectedWRR.sel(totalWeight);
    return selectedInvoker;
  }
  return upstreamList.get(0);
}
</code></pre><p>这个算法有点复杂, 我解释下核心计算权重的方面:</p><ul><li>两个分值分别为2、100的节点进入, 缓存中保留它们各自, 分值从0开始</li><li>经过for循环后, 两个节点在缓存中的分值会以自身为基数增加, 假设后面步骤不进行, 则缓存第一次为2、100, 第二次为4、200, 依次类推.</li><li>关键的第三步, 选出节点缓存中分值最高的, 进行&rdquo;处罚&rdquo;措施, 减少所有节点的累计分值, 即102.</li></ul><p>根据这个算法的步骤, 一直没有被选中的节点, 作为&rdquo;成长奖励&rdquo;, 会持续以自身为基数自增; 而被选中的节点, 作为&rdquo;惩罚&rdquo;, 会减少其他节点的权重分之和.</p><p>可以预见, 权重分小的节点, 要自增到很久之后, 才会等来自身被选中的一刻, 然而那一刻它被惩罚的力度会非常大, 导致它一朝回到解放前, 又要开始漫长的积蓄力量. 而权重分大的节点, 每次被选上的惩罚力度很小, 即使多次后分数太低没被选上, 他的奖励分数(自身)也特别高, 一次增加就远远超越其他节点.</p><h2 id=webclientplugin>WebClientPlugin</h2><p>经过 DividePlugin 插件的调用后, 下游服务节点路径被确定, 接着就是 WebClientPlugin 插件发挥作用了. 它直接实现了 SoulPlugin 接口并实现了 <code>execute()</code> 方法 (仅保留核心代码):</p><pre><code class=language-java>public Mono&lt;Void&gt; execute(final ServerWebExchange exchange, final SoulPluginChain chain) {
  String urlPath = exchange.getAttribute(Constants.HTTP_URL);
  // 请求类型: Get请求orPost请求等
  HttpMethod method = HttpMethod.valueOf(exchange.getRequest().getMethodValue());
  // 构建一个请求对象空壳, 注入请求类型和URL
  WebClient.RequestBodySpec requestBodySpec = webClient.method(method).uri(urlPath);
  return handleRequestBody(requestBodySpec, exchange, timeout, chain);
}

private Mono&lt;Void&gt; handleRequestBody(final WebClient.RequestBodySpec requestBodySpec,
                                         final ServerWebExchange exchange,
                                         final long timeout,
                                         final SoulPluginChain chain) {
  return requestBodySpec.headers(httpHeaders -&gt; {
    // 补充上下文中请求头... 后面也是补充些属性, 不赘述
    httpHeaders.addAll(exchange.getRequest().getHeaders());
    httpHeaders.remove(HttpHeaders.HOST);
  })
    .contentType(buildMediaType(exchange))
    .body(BodyInserters.fromDataBuffers(exchange.getRequest().getBody()))
    // 开始异步http调用下游服务
    .exchange()
    .doOnError(e -&gt; log.error(e.getMessage()))
    .timeout(Duration.ofMillis(timeout))
    // 回调接收返回值
    .flatMap(e -&gt; doNext(e, exchange, chain));
}

// 这里是异步的回调方法, 在另一个线程中工作
private Mono&lt;Void&gt; doNext(final ClientResponse res, final ServerWebExchange exchange, final SoulPluginChain chain) {
  // ...
  // 继续完成剩下的插件链调用
  return chain.execute(exchange);
}
</code></pre><p>简单看下 <code>handleRequestBody()</code> 中 <code>exchange()</code> 这个方法的实现, 这里有关键的Http调用:</p><pre><code class=language-java>class DefaultWebClient implements WebClient {
  @Override
  public Mono&lt;ClientResponse&gt; exchange() {
    ClientRequest request = (this.inserter != null ?
                             initRequestBuilder().body(this.inserter).build() :
                             initRequestBuilder().build());
    // 这里是关键调用, 会走到 spring-web-reactive
    return Mono.defer(() -&gt; exchangeFunction.exchange(request)
                      .checkpoint(&quot;Request to &quot; + this.httpMethod.name() + &quot; &quot; + this.uri + &quot; [DefaultWebClient]&quot;)
                      .switchIfEmpty(NO_HTTP_CLIENT_RESPONSE_ERROR));
  }
}
</code></pre><p>总结下, 经过 WebClientPlugin 的处理会异步调用下游服务, 等待响应后再在另一个线程中, 执行后续的插件链调用.</p><h2 id=webclientresponseclient>WebClientResponseClient</h2><p>最后插件链走到 WebClientResponseClient 这一环, 封装响应信息:</p><pre><code class=language-java>public Mono&lt;Void&gt; execute(final ServerWebExchange exchange, final SoulPluginChain chain) {
  return chain.execute(exchange).then(Mono.defer(() -&gt; {
    // 获取上下文中存放的响应信息
    ServerHttpResponse response = exchange.getResponse();
    ClientResponse clientResponse = exchange.getAttribute(Constants.CLIENT_RESPONSE_ATTR);
    if (Objects.isNull(clientResponse)
        || response.getStatusCode() == HttpStatus.BAD_GATEWAY
        || response.getStatusCode() == HttpStatus.INTERNAL_SERVER_ERROR) {
      Object error = SoulResultWarp.error(SoulResultEnum.SERVICE_RESULT_ERROR.getCode(), SoulResultEnum.SERVICE_RESULT_ERROR.getMsg(), null);
      return WebFluxResultUtils.result(exchange, error);
    } else if (response.getStatusCode() == HttpStatus.GATEWAY_TIMEOUT) {
      Object error = SoulResultWarp.error(SoulResultEnum.SERVICE_TIMEOUT.getCode(), SoulResultEnum.SERVICE_TIMEOUT.getMsg(), null);
      return WebFluxResultUtils.result(exchange, error);
    }
    // 各种拼装
    response.setStatusCode(clientResponse.statusCode());
    response.getCookies().putAll(clientResponse.cookies());
    response.getHeaders().putAll(clientResponse.headers().asHttpHeaders());
    return response.writeWith(clientResponse.body(BodyExtractors.toDataBuffers()));
  }));
}
</code></pre></article><div class=-show-mobile><nav class=ss-pagination-next><a class=link-prev href=/blog/shenyu_source_learning_01/><span class=text>Prev:</span>
<span class=text>ShenYuLearning(1) Environment Configuration</span></a>
<a class=link-next href=/blog/shenyu_source_learning_02_divide_plugin/><span class=text>Next:</span>
<span class=text>ShenYuLearning(2) Use Divide Plugin</span></a></nav></div></main><aside class=ss-layout-aside><div class=ss-card><h2 class=card-title>Related</h2><ul class=ss-aside-related><li><a href=/blog/shenyu_source_learning_01/>ShenYuLearning(1) Environment Configuration</a></li><li><a href=/news/shenyu-2.3.0/>【Soul gateway release milestone version 2.3.0】New support for grpc, tars and sofa protocols!</a></li></ul></div><div class="ss-aside-tags ss-card"><h2 class=card-title>Tag
<span class=card-extra></span></h2><ul class=tag-list><li class=tag><a href=/tags/apache/>Apache</a></li><li class=tag><a href=/tags/apache-shenyu/>Apache ShenYu</a></li><li class=tag><a href=/tags/code-conduct/>Code Conduct</a></li><li class=tag><a href=/tags/committer/>Committer</a></li><li class=tag><a href=/tags/contributor/>Contributor</a></li><li class=tag><a href=/tags/dreamcode/>DreamCode</a></li><li class=tag><a href=/tags/gateway/>GateWay</a></li><li class=tag><a href=/tags/icla/>ICLA</a></li><li class=tag><a href=/tags/issue-pr/>Issue-PR</a></li><li class=tag><a href=/tags/reactor/>Reactor</a></li><li class=tag><a href=/tags/subscribe-email/>Subscribe-Email</a></li><li class=tag><a href=/tags/two-fa/>Two-FA</a></li><li class=tag><a href=/tags/vote-committer/>Vote-Committer</a></li></ul></div></aside></div><footer class=ss-footer><div class=container><div class=links><div class="cate  -show-mobile"><h2 class=cate-title>Apache</h2><a class=link href=https://www.apache.org/>Foundation</a>
<a class=link href=https://github.com/apache/incubator-shenyu/issues>GitHub Issue Tracker</a>
<a class=link href=https://www.apache.org/licenses/>License</a>
<a class=link href=https://www.apache.org/security/>Security</a>
<a class=link href=http://www.apache.org/events/current-event>Events</a>
<a class=link href=http://www.apache.org/foundation/sponsorship.html>Sponsorship</a>
<a class=link href=http://www.apache.org/foundation/thanks.html>Thanks</a></div><div class=cate><h2 class=cate-title>Resources</h2><a class=link href=https://github.com/apache/incubator-shenyu>Github</a>
<a class=link href=/projects/shenyu/overview/>Documentation</a></div><div class=cate><h2 class=cate-title>Get Involved</h2><a class=link href=https://github.com/apache/incubator-shenyu/issues/new>Feedback</a>
<a class=link href=/community>Community</a>
<a class=link href=/news>News</a>
<a class=link href=/awesome>Awesome</a></div><div class=cate><h2 class=cate-title>Subscribe mailing list</h2><a class=link href=/community/subscribe-email/>How to subscribe</a>
<a class=link href=mailto://dev-subscribe@shenyu.apache.org>Subscribe Mail</a>
<a class=link href=https://lists.apache.org/list.html?dev@shenyu.apache.org>Mail Archive</a></div></div><div class=qrcode><div><img class=qrcode-img src=/img/qrcode/WechatIMG127.jpeg><p class=qrcode-desc>Wechat Official Account</p></div></div></div><div class=copyright><p>Copyright © 2021 The Apache Software Foundation. Licensed under the Apache License, Version 2.0.
Apache ShenYu, Apache Incubator, Apache, the Apache feather logo, the Apache ShenYu logo and the Apache Incubator project logo are trademarks of The Apache Software Foundation.
Apache ShenYu is an effort undergoing incubation at The Apache Software Foundation (ASF), sponsored by the Apache Incubator.
Incubation is required of all newly accepted projects until a further review indicates that the infrastructure, communications, and decision making process have stabilized in a manner consistent with other successful ASF projects.
While incubation status is not necessarily a reflection of the completeness or stability of the code,
it does indicate that the project has yet to be fully endorsed by the ASF.</p></div></footer></body></html>