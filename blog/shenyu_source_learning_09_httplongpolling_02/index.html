<!doctype html><html><head><title>Apache ShenYu Gateway Learns Http Long Polling Analysis 02 · Apache ShenYu</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="The girl on the prairie"><meta name=generator content="Hugo 0.55.5"><link rel="shortcut icon" href=/img/favicon.png type=image/png><link href=https://unpkg.com/purecss@1.0.0/build/base-min.css rel=stylesheet><link href=/css/main.css rel=stylesheet><link href=/css/zoom-image.css rel=stylesheet><script src=/js/iconfont.js></script><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script><script>window.SITE_LANGUAGE="en"</script><script src=/js/app.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-187960192-2','auto');ga('send','pageview');}</script></head><body><header class=ss-header><nav class=navbar role=navigation aria-label="main navigation"><div class=navbar-brand><a class=logo-link style=font-size:25px;margin-right:50px href=/><img class=logo src=/img/logo/apache-shenyu.png></a><div class=-show-mobile><a id=mobile-menu-icon><svg class="icon" aria-hidden="true"><use xlink:href="#icon-menu"/></svg></a><nav id=mobile-menu><div id=js-menu-search-mobile class=navbar-search-mobile><input class=input placeholder=Search><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div><a href=/projects/shenyu/download/><span>Download</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/projects/shenyu/overview/><span>Documentation</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/community/subscribe-email/><span>Community</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/news/><span>News</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/awesome/><span>Awesome</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/blog/shenyu_source_learning_09_httplongpolling_02/><span>中文</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-transfer"/></svg></a></nav></div></div><div class="navbar-menu -hidden-mobile"><div class=navbar-start><a class=navbar-item href=/projects/shenyu/download/>Download</a>
<a class=navbar-item href=/projects/shenyu/overview/>Documentation</a>
<a class=navbar-item href=/community/subscribe-email/>Community</a>
<a class=navbar-item href=/news/>News</a>
<a class=navbar-item href=/awesome/>Awesome</a>
<span class="navbar-item nav-hover"><a>Links</a><div class=dropdown-menu><a class=dropdown-item href=https://www.apache.org/>Apache Software Foundation</a>
<a class=dropdown-item href=https://github.com/apache/incubator-shenyu/issues>GitHub Issue Tracker</a>
<a class=dropdown-item href=https://www.apache.org/>License</a>
<a class=dropdown-item href=http://www.apache.org/events/current-event>Apache Events</a>
<a class=dropdown-item href=https://www.apache.org/licenses/>Security</a>
<a class=dropdown-item href=http://www.apache.org/foundation/sponsorship.html>Sponsor and Donate</a>
<a class=dropdown-item href=http://www.apache.org/foundation/thanks.html>Thanks</a></div></span></div><div class=navbar-end><div class=navbar-item><div id=js-menu-search class=navbar-search><input class=input placeholder=Search><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div></div><div class=navbar-item><a class=translation href=/zh/blog/shenyu_source_learning_09_httplongpolling_02/>中</a></div></div></div></nav></header><div class=ss-layout-container><main class="ss-layout-main -card"><div class=ss-meta><h1 class=title>Apache ShenYu Gateway Learns Http Long Polling Analysis 02</h1><div class=meta>2021-01-27 ·
zhuming ·
<span class=tags><a class=tag href=/tags/apache-shenyu/ rel=tag>#Apache ShenYu</a></span></div></div><article class=typo><h2 id=后台与网关数据同步-http长轮询篇>后台与网关数据同步 (Http长轮询篇)</h2><p>长轮询分析的最后一篇, 总结网关端的长轮询的实现, 以及数据流动方式.</p><p>网关端长轮询的流程总体也分两个模块: 一是启动时拉取, 二是轮询监听变化</p><h2 id=网关启动时拉取数据>网关启动时拉取数据</h2><p>网关启动后, 会调用后台提供的接口拉取数据, 并将数据发送到各个插件的数据处理类中</p><p>下面展示下网关启动拉取数据的处理流程:
<img src=/img/shenyu/blog1/01.png alt=01></p><p>这几个处理步骤被分散到下面这些类的方法协作中:</p><p><img src=/img/shenyu/blog1/02.png alt=02></p><p>HttpSyncDataService#start: 网关启动时, HttpSyncDataService 初始化会调用 <code>start()</code> 方法, 该方法会调用后台拉取数据, 并开启多个线程进行轮询监听 (这块在下个模块分析)</p><pre><code class=language-java>public class HttpSyncDataService implements SyncDataService, AutoCloseable {
  
  private void start() {
    // 防止二次调用的CAS操作
    if (RUNNING.compareAndSet(false, true)) {
      // 这里是本次流程的重点, 调用拉取数据的方法
      this.fetchGroupConfig(ConfigGroupEnum.values());
      int threadSize = serverList.size();
      // 这里将在下个模块分析, 会根据后台集群开启线程轮询监听
      this.executor = new ThreadPoolExecutor(threadSize, threadSize, 60L, TimeUnit.SECONDS,
                                             new LinkedBlockingQueue&lt;&gt;(),
                                             SoulThreadFactory.create(&quot;http-long-polling&quot;, true));
      this.serverList.forEach(server -&gt; this.executor.execute(new HttpLongPollingTask(server)));
    } else {
      log.info(&quot;Apache ShenYu http long polling was started, executor=[{}]&quot;, executor);
    }
  }
}
</code></pre><p>HttpSyncDataService#fetchGroupConfig: 作用仅是根据数据类型, 循环多次调用拉取数据方法(针对同一个后台会请求多次, 每次拉取某一种数据类型的信息), 这里的数据类型指的是 plugin、rule、selector 等</p><pre><code class=language-java>private void fetchGroupConfig(final ConfigGroupEnum... groups) throws SoulException {
  for (int index = 0; index &lt; this.serverList.size(); index++) {
    String server = serverList.get(index);
    try {
            // 根据传入的数据类型枚举, 多次调用拉取数据方法
      this.doFetchGroupConfig(server, groups);
      break;
    } catch (SoulException e) {
      if (index &gt;= serverList.size() - 1) {
        throw e;
      }
      log.warn(&quot;fetch config fail, try another one: {}&quot;, serverList.get(index + 1));
    }
  }
}
</code></pre><p>HttpSyncDataService#doFetchGroupConfig: 请求后台的 <code>/configs/fetch</code> 接口, 拿到某个类型的数据, 并更新缓存. 更新缓存前会检测是否变动, 如果变动则结束, <strong>数据未发生变动则睡眠30s</strong> (由于是第一次启动, 数据为空的情况下肯定会更新缓存, 所以会直接结束)</p><pre><code class=language-java>private void doFetchGroupConfig(final String server, final ConfigGroupEnum... groups) {
  StringBuilder params = new StringBuilder();
  for (ConfigGroupEnum groupKey : groups) {
    params.append(&quot;groupKeys&quot;).append(&quot;=&quot;).append(groupKey.name()).append(&quot;&amp;&quot;);
  }
  // 具体请求路径, 拉取后台数据
  String url = server + &quot;/configs/fetch?&quot; + StringUtils.removeEnd(params.toString(), &quot;&amp;&quot;);
  log.info(&quot;request configs: [{}]&quot;, url);
  String json = null;
  try {
    json = this.httpClient.getForObject(url, String.class);
  } catch (RestClientException e) {
    String message = String.format(&quot;fetch config fail from server[%s], %s&quot;, url, e.getMessage());
    log.warn(message);
    throw new SoulException(message, e);
  }
  // 修改缓存信息
  boolean updated = this.updateCacheWithJson(json);
  // 判断是否修改, 修改则直接结束
  if (updated) {
    log.info(&quot;get latest configs: [{}]&quot;, json);
    return;
  }
  log.info(&quot;The config of the server[{}] has not been updated or is out of date. Wait for 30s to listen for changes again.&quot;, server);
  ThreadUtils.sleep(TimeUnit.SECONDS, 30);
}
</code></pre><p>HttpSyncDataService#updateCacheWithJson: 取出响应信息中的 <code>data</code> , 即变化的数据信息, 传给数据刷新工厂 DataRefreshFactory</p><pre><code class=language-java>private DataRefreshFactory factory;

public HttpSyncDataService(...){
  this.factory = new DataRefreshFactory(pluginDataSubscriber, metaDataSubscribers, authDataSubscribers);
}

private boolean updateCacheWithJson(final String json) {
  JsonObject jsonObject = GSON.fromJson(json, JsonObject.class);
  JsonObject data = jsonObject.getAsJsonObject(&quot;data&quot;);
  return factory.executor(data);
}
</code></pre><p>DataRefreshFactory#executor: 将数据发送给各类数据刷新类 (这里没有去区别信息类型, 而是通知所有数据刷新类, 可考虑优化)</p><pre><code class=language-java>public final class DataRefreshFactory {

  private static final EnumMap&lt;ConfigGroupEnum, DataRefresh&gt; ENUM_MAP = new EnumMap&lt;&gt;(ConfigGroupEnum.class);

  public DataRefreshFactory(final PluginDataSubscriber pluginDataSubscriber,
                              final List&lt;MetaDataSubscriber&gt; metaDataSubscribers,
                              final List&lt;AuthDataSubscriber&gt; authDataSubscribers) {
    // 注入各类型订阅器到 MAP 中
    ENUM_MAP.put(ConfigGroupEnum.PLUGIN, new PluginDataRefresh(pluginDataSubscriber));
    ENUM_MAP.put(ConfigGroupEnum.SELECTOR, new SelectorDataRefresh(pluginDataSubscriber));
    ENUM_MAP.put(ConfigGroupEnum.RULE, new RuleDataRefresh(pluginDataSubscriber));
    ENUM_MAP.put(ConfigGroupEnum.APP_AUTH, new AppAuthDataRefresh(authDataSubscribers));
    ENUM_MAP.put(ConfigGroupEnum.META_DATA, new MetaDataRefresh(metaDataSubscribers));
  }
  
  public boolean executor(final JsonObject data) {
    final boolean[] success = {false};
    // Tureen: 所有数据类型的 DataRefresh 全调用
    ENUM_MAP.values().parallelStream().forEach(dataRefresh -&gt; success[0] = dataRefresh.refresh(data));
    return success[0];
  } 
}
</code></pre><p>AbstractDataRefresh#refresh: 判断是否要更新缓存, 若更新则调用各类型的 <code>refresh()</code> 方法</p><pre><code class=language-java>@Override
public Boolean refresh(final JsonObject data) {
  boolean updated = false;
  JsonObject jsonObject = convert(data);
  if (null != jsonObject) {
    ConfigData&lt;T&gt; result = fromJson(jsonObject);
    if (this.updateCacheIfNeed(result)) {
      updated = true;
      // Turren: 调用 refresh
      refresh(result.getData());
    }
  }
  return updated;
}
</code></pre><p>PluginDataRefresh#refresh: 调用 plugin 的订阅器, 接下来会通知所有扩展插件的相关事件变动</p><pre><code class=language-java>@Override
protected void refresh(final List&lt;PluginData&gt; data) {
  if (CollectionUtils.isEmpty(data)) {
    log.info(&quot;clear all plugin data cache&quot;);
    pluginDataSubscriber.refreshPluginDataAll();
  } else {
    pluginDataSubscriber.refreshPluginDataAll();
    // Turren: http同步, 调用插件数据订阅器
    data.forEach(pluginDataSubscriber::onSubscribe);
  }
}
</code></pre><h2 id=网关轮询监听变化>网关轮询监听变化</h2><p>网关启动时, 同时也开启了线程做后台监听请求, 监听请求做了while死循环来轮询, 在后台端会劫持住请求, 这块在后台总结中有具体分析 (<a href=https://blog.csdn.net/zm469568595/article/details/113207367>后台与网关数据同步 (Http长轮询篇 &lt;二&gt;)</a>)</p><p>下面展示下网关监听数据变动的整体流程:</p><p><img src=/img/shenyu/blog1/03.png alt=03></p><p>对应的实际代码实现如下:</p><p><img src=/img/shenyu/blog1/04.png alt=04></p><p><strong>网关端监听的流程实现都在 HttpSyncDataService 类中, 在最后会经由 <code>doFetchGroupConfig()</code> 传到到各类订阅器, 后面的流程与启动时的一致</strong></p><p>HttpSyncDataService#start: 启动线程执行 HttpLongPollingTask 这个 Runnable</p><p>HttpLongPollingTask#run: 开启循环调用轮询方法.</p><pre><code class=language-java>@Override
public void run() {
  while (RUNNING.get()) {
    for (int time = 1; time &lt;= retryTimes; time++) {
      try {
        doLongPolling(server);
      } catch (Exception e) {
        if (time &lt; retryTimes) {
          log.warn(&quot;Long polling failed, tried {} times, {} times left, will be suspended for a while! {}&quot;,
                   time, retryTimes - time, e.getMessage());
          ThreadUtils.sleep(TimeUnit.SECONDS, 5);
          continue;
        }
        log.error(&quot;Long polling failed, try again after 5 minutes!&quot;, e);
        ThreadUtils.sleep(TimeUnit.MINUTES, 5);
      }
    }
  }
}
</code></pre><p>HttpLongPollingTask#doLongPolling: 得到监听请求的响应结果, 如果返回值中有变化的类型, 则调用数据拉取方法.</p><pre><code class=language-java>private void doLongPolling(final String server) {
  // 从缓存中获取数据
  MultiValueMap&lt;String, String&gt; params = new LinkedMultiValueMap&lt;&gt;(8);
  for (ConfigGroupEnum group : ConfigGroupEnum.values()) {
    ConfigData&lt;?&gt; cacheConfig = factory.cacheConfigData(group);
    String value = String.join(&quot;,&quot;, cacheConfig.getMd5(), String.valueOf(cacheConfig.getLastModifyTime()));
    params.put(group.name(), Lists.newArrayList(value));
  }
  // 构建 http 请求信息
  HttpHeaders headers = new HttpHeaders();
  headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);
  HttpEntity httpEntity = new HttpEntity(params, headers);
  String listenerUrl = server + &quot;/configs/listener&quot;;
  log.debug(&quot;request listener configs: [{}]&quot;, listenerUrl);
  JsonArray groupJson = null;
  try {
    String json = this.httpClient.postForEntity(listenerUrl, httpEntity, String.class).getBody();
    groupJson = GSON.fromJson(json, JsonObject.class).getAsJsonArray(&quot;data&quot;);
  } catch (RestClientException e) {
    String message = String.format(&quot;listener configs fail, server:[%s], %s&quot;, server, e.getMessage());
    throw new SoulException(message, e);
  }
  // 得到变化的类型
  if (groupJson != null) {
    ConfigGroupEnum[] changedGroups = GSON.fromJson(groupJson, ConfigGroupEnum[].class);
    if (ArrayUtils.isNotEmpty(changedGroups)) {
      log.info(&quot;Group config changed: {}&quot;, Arrays.toString(changedGroups));
      // 拉取后台对应类型的数据
      this.doFetchGroupConfig(server, changedGroups);
    }
  }
}
</code></pre><p>LongPollingClient#doFetchGroupConfig:</p><p>之前的启动里分析了这块的代码, 它与启动里最不同的点是, <strong>如果拉取的数据与缓存比对后, 发现没有变化则睡眠30s, 会导致下次的监听延后30s</strong>.</p><p>什么意思呢? 如果网关去 <code>fetch</code> 后台的数据, 拿回来比对后发现被骗了! 啥变化也没有, 就等30s 再启动下次监听, 这个期间如果后台发生数据变化肯定是没法通知到网关的.</p><p>网关为什么这么做? 自然是为了防止大量的循环的无用拉取, 如果后台出现问题不断的通知数据变动, 但实际没有任何变动, 那么网关不延迟就会与后台产生大量无用的 网络IO 与 数据交换</p></article><div class=-show-mobile><nav class=ss-pagination-next><a class=link-prev href=/blog/shenyu_source_learning_17_http/><span class=text>Prev:</span>
<span class=text>Apache ShenYu Gateway Learning Http Request Adventure</span></a>
<a class=link-next href=/blog/shenyu_source_learning_12_sign/><span class=text>Next:</span>
<span class=text>Apache ShenYu Gateway Learning Sign Plugin</span></a></nav></div></main><aside class=ss-layout-aside><div class=ss-card><h2 class=card-title>Related</h2><ul class=ss-aside-related><li><a href=/blog/shenyu_source_learning_17_http/>Apache ShenYu Gateway Learning Http Request Adventure</a></li><li><a href=/blog/shenyu_source_learning_14_nacos/>Apache ShenYu Gateway Learns Nacos Data Synchronization</a></li><li><a href=/blog/shenyu_source_learning_08_httplongpolling_01/>Apache ShenYu Gateway Learns Http Long Polling Analysis 01</a></li><li><a href=/blog/shenyu_source_learning_10_websocket/>Apache ShenYu Gateway Learns WebSocket Data Synchronization Analysis</a></li><li><a href=/blog/shenyu_source_learning_15_plugin_chain/>Apache ShenYu Gateway Learning Plugin Chain Implementation</a></li></ul></div><div class="ss-aside-tags ss-card"><h2 class=card-title>Tag
<span class=card-extra></span></h2><ul class=tag-list><li class=tag><a href=/tags/apache/>Apache</a></li><li class=tag><a href=/tags/apache-shenyu/>Apache ShenYu</a></li><li class=tag><a href=/tags/code-conduct/>Code Conduct</a></li><li class=tag><a href=/tags/committer/>Committer</a></li><li class=tag><a href=/tags/contributor/>Contributor</a></li><li class=tag><a href=/tags/dreamcode/>DreamCode</a></li><li class=tag><a href=/tags/gateway/>GateWay</a></li><li class=tag><a href=/tags/icla/>ICLA</a></li><li class=tag><a href=/tags/issue-pr/>Issue-PR</a></li><li class=tag><a href=/tags/reactor/>Reactor</a></li><li class=tag><a href=/tags/subscribe-email/>Subscribe-Email</a></li><li class=tag><a href=/tags/two-fa/>Two-FA</a></li><li class=tag><a href=/tags/vote-committer/>Vote-Committer</a></li></ul></div></aside></div><footer class=ss-footer><div class=container><div class=links><div class="cate  -show-mobile"><h2 class=cate-title>Apache</h2><a class=link href=https://www.apache.org/>Foundation</a>
<a class=link href=https://github.com/apache/incubator-shenyu/issues>GitHub Issue Tracker</a>
<a class=link href=https://www.apache.org/licenses/>License</a>
<a class=link href=https://www.apache.org/security/>Security</a>
<a class=link href=http://www.apache.org/events/current-event>Events</a>
<a class=link href=http://www.apache.org/foundation/sponsorship.html>Sponsorship</a>
<a class=link href=http://www.apache.org/foundation/thanks.html>Thanks</a></div><div class=cate><h2 class=cate-title>Resources</h2><a class=link href=https://github.com/apache/incubator-shenyu>Github</a>
<a class=link href=/projects/shenyu/overview/>Documentation</a></div><div class=cate><h2 class=cate-title>Get Involved</h2><a class=link href=https://github.com/apache/incubator-shenyu/issues/new>Feedback</a>
<a class=link href=/community>Community</a>
<a class=link href=/news>News</a>
<a class=link href=/awesome>Awesome</a></div><div class=cate><h2 class=cate-title>Subscribe mailing list</h2><a class=link href=/community/subscribe-email/>How to subscribe</a>
<a class=link href=mailto://dev-subscribe@shenyu.apache.org>Subscribe Mail</a>
<a class=link href=https://lists.apache.org/list.html?dev@shenyu.apache.org>Mail Archive</a></div></div><div class=qrcode><div><img class=qrcode-img src=/img/qrcode/WechatIMG127.jpeg><p class=qrcode-desc>Wechat Official Account</p></div></div></div><div class=copyright><p>Copyright © 2021 The Apache Software Foundation. Licensed under the Apache License, Version 2.0.
Apache ShenYu, Apache Incubator, Apache, the Apache feather logo, the Apache ShenYu logo and the Apache Incubator project logo are trademarks of The Apache Software Foundation.
Apache ShenYu is an effort undergoing incubation at The Apache Software Foundation (ASF), sponsored by the Apache Incubator.
Incubation is required of all newly accepted projects until a further review indicates that the infrastructure, communications, and decision making process have stabilized in a manner consistent with other successful ASF projects.
While incubation status is not necessarily a reflection of the completeness or stability of the code,
it does indicate that the project has yet to be fully endorsed by the ASF.</p></div></footer></body></html>