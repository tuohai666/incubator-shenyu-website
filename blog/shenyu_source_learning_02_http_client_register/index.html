<!doctype html><html><head><title>Apache ShenYu Gateway Learning (2) HTTP Client Access Source Code Parsing · Apache ShenYu</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="The girl on the prairie"><meta name=generator content="Hugo 0.55.5"><link rel="shortcut icon" href=/img/favicon.png type=image/png><link href=https://unpkg.com/purecss@1.0.0/build/base-min.css rel=stylesheet><link href=/css/main.css rel=stylesheet><link href=/css/zoom-image.css rel=stylesheet><script src=/js/iconfont.js></script><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script><script>window.SITE_LANGUAGE="en"</script><script src=/js/app.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-187960192-2','auto');ga('send','pageview');}</script></head><body><header class=ss-header><nav class=navbar role=navigation aria-label="main navigation"><div class=navbar-brand><a class=logo-link style=font-size:25px;margin-right:50px href=/><img class=logo src=/img/logo/apache-shenyu.png></a><div class=-show-mobile><a id=mobile-menu-icon><svg class="icon" aria-hidden="true"><use xlink:href="#icon-menu"/></svg></a><nav id=mobile-menu><div id=js-menu-search-mobile class=navbar-search-mobile><input class=input placeholder=Search><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div><a href=/projects/shenyu/download/><span>Download</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/projects/shenyu/overview/><span>Documentation</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/community/subscribe-email/><span>Community</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/news/><span>News</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/awesome/><span>Awesome</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/blog/shenyu_source_learning_02_http_client_register/><span>中文</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-transfer"/></svg></a></nav></div></div><div class="navbar-menu -hidden-mobile"><div class=navbar-start><a class=navbar-item href=/projects/shenyu/download/>Download</a>
<a class=navbar-item href=/projects/shenyu/overview/>Documentation</a>
<a class=navbar-item href=/community/subscribe-email/>Community</a>
<a class=navbar-item href=/news/>News</a>
<a class=navbar-item href=/awesome/>Awesome</a>
<span class="navbar-item nav-hover"><a>Links</a><div class=dropdown-menu><a class=dropdown-item href=https://www.apache.org/>Apache Software Foundation</a>
<a class=dropdown-item href=https://github.com/apache/incubator-shenyu/issues>GitHub Issue Tracker</a>
<a class=dropdown-item href=https://www.apache.org/>License</a>
<a class=dropdown-item href=http://www.apache.org/events/current-event>Apache Events</a>
<a class=dropdown-item href=https://www.apache.org/licenses/>Security</a>
<a class=dropdown-item href=http://www.apache.org/foundation/sponsorship.html>Sponsor and Donate</a>
<a class=dropdown-item href=http://www.apache.org/foundation/thanks.html>Thanks</a></div></span></div><div class=navbar-end><div class=navbar-item><div id=js-menu-search class=navbar-search><input class=input placeholder=Search><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div></div><div class=navbar-item><a class=translation href=/zh/blog/shenyu_source_learning_02_http_client_register/>中</a></div></div></div></nav></header><div class=ss-layout-container><main class="ss-layout-main -card"><div class=ss-meta><h1 class=title>Apache ShenYu Gateway Learning (2) HTTP Client Access Source Code Parsing</h1><div class=meta>2021-01-18 ·
fanjinpeng ·
<span class=tags><a class=tag href=/tags/apache-shenyu/ rel=tag>#Apache ShenYu</a></span></div></div><article class=typo><h1 id=http-用户接入-shenyu网关注册逻辑分析>HTTP 用户接入 ShenYu网关注册逻辑分析</h1><h2 id=1-注册入口>1. 注册入口</h2><p>HTTP 用户接入 ShenYu网关时，会调用 soul-admin 一个接口，把需要 ShenYu网关管理的接口注册，今天就具体看看到底干了点儿啥。</p><p>先看下调用的接口信息如下：</p><pre><code class=language-java>// SpringMvcClientBeanPostProcessor.java
/**
 * Instantiates a new ShenYuclient bean post processor.
 *
 * @param soulSpringMvcConfig the Apache ShenYu spring mvc config
 */
public SpringMvcClientBeanPostProcessor(final SoulSpringMvcConfig soulSpringMvcConfig) {
    ValidateUtils.validate(soulSpringMvcConfig);
    this.soulSpringMvcConfig = soulSpringMvcConfig;
    url = soulSpringMvcConfig.getAdminUrl() + &quot;/soul-client/springmvc-register&quot;;
    executorService = new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;&gt;());
}
</code></pre><h2 id=2-springmvc-register-接口逻辑>2. springmvc-register 接口逻辑</h2><p>全局搜索 &ldquo;springmvc-register&rdquo;，找到 soul-admin 模块下的 SoulClientController，看到这里，对于经常写 CRUD 的我们是不是很熟悉？哈哈~</p><pre><code class=language-java>// SoulClientController.java
/**
 * Register spring mvc string.
 *
 * @param springMvcRegisterDTO the spring mvc register dto
 * @return the string
 */
@PostMapping(&quot;/springmvc-register&quot;)
public String registerSpringMvc(@RequestBody final SpringMvcRegisterDTO springMvcRegisterDTO) {
    return soulClientRegisterService.registerSpringMvc(springMvcRegisterDTO);
}
</code></pre><p>Service 层实现类：</p><pre><code class=language-java>// SoulClientRegisterServiceImpl.java
@Override
@Transactional
public String registerSpringMvc(final SpringMvcRegisterDTO dto) {
    if (dto.isRegisterMetaData()) {
        MetaDataDO exist = metaDataMapper.findByPath(dto.getPath());
        if (Objects.isNull(exist)) {
            saveSpringMvcMetaData(dto);
        }
    }
    String selectorId = handlerSpringMvcSelector(dto);
    handlerSpringMvcRule(selectorId, dto);
    return SoulResultMessage.SUCCESS;
}
</code></pre><p>dto.isRegisterMetaData() 这个是否注册元数据信息的判断，不知道什么时候用，存疑 //TODO，先往下走。</p><h3 id=2-1-先看看这个方法-handlerspringmvcselector-处理-selector>2.1 先看看这个方法 handlerSpringMvcSelector，处理 Selector。</h3><pre><code class=language-java>// SoulClientRegisterServiceImpl.java
private String handlerSpringMvcSelector(final SpringMvcRegisterDTO dto) {
    String contextPath = dto.getContext();
    // 根据 contextPath 到数据库里查询，是否已经注册过。
    SelectorDO selectorDO = selectorService.findByName(contextPath);
    String selectorId;
    String uri = String.join(&quot;:&quot;, dto.getHost(), String.valueOf(dto.getPort()));
    if (Objects.isNull(selectorDO)) {
        // 还没有注册过
        selectorId = registerSelector(contextPath, dto.getRpcType(), dto.getAppName(), uri);
    } else {
        // 已经注册过，业务系统重启了会到这里
        selectorId = selectorDO.getId();
        //update upstream
        String handle = selectorDO.getHandle();
        String handleAdd;
        DivideUpstream addDivideUpstream = buildDivideUpstream(uri);
        SelectorData selectorData = selectorService.buildByName(contextPath);
        if (StringUtils.isBlank(handle)) {
            handleAdd = GsonUtils.getInstance().toJson(Collections.singletonList(addDivideUpstream));
        } else {
            List&lt;DivideUpstream&gt; exist = GsonUtils.getInstance().fromList(handle, DivideUpstream.class);
            for (DivideUpstream upstream : exist) {
                if (upstream.getUpstreamUrl().equals(addDivideUpstream.getUpstreamUrl())) {
                    return selectorId;
                }
            }
            exist.add(addDivideUpstream);
            handleAdd = GsonUtils.getInstance().toJson(exist);
        }
        selectorDO.setHandle(handleAdd);
        selectorData.setHandle(handleAdd);
        // update db
        selectorMapper.updateSelective(selectorDO);
        // submit upstreamCheck
        upstreamCheckService.submit(contextPath, addDivideUpstream);
        // publish change event.
        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.SELECTOR, DataEventTypeEnum.UPDATE,
                Collections.singletonList(selectorData)));
    }
    return selectorId;
}
</code></pre><h4 id=2-1-1-第一次接入-shenyu网关>2.1.1 第一次接入 ShenYu网关</h4><p>新接入的，到数据库里肯定查不到 selectorDO，进入 registerSelector 方法，仔细看看到底往哪些数据库表中插数据了。</p><pre><code class=language-java>// SoulClientRegisterServiceImpl.java
private String registerSelector(final String contextPath, final String rpcType, final String appName, final String uri) {
    SelectorDTO selectorDTO = SelectorDTO.builder()
            .name(contextPath)
            .type(SelectorTypeEnum.CUSTOM_FLOW.getCode())
            .matchMode(MatchModeEnum.AND.getCode())
            .enabled(Boolean.TRUE)
            .loged(Boolean.TRUE)
            .continued(Boolean.TRUE)
            .sort(1)
            .build();
    if (RpcTypeEnum.DUBBO.getName().equals(rpcType)) {
        selectorDTO.setPluginId(getPluginId(PluginEnum.DUBBO.getName()));
    } else if (RpcTypeEnum.SPRING_CLOUD.getName().equals(rpcType)) {
        selectorDTO.setPluginId(getPluginId(PluginEnum.SPRING_CLOUD.getName()));
        selectorDTO.setHandle(GsonUtils.getInstance().toJson(buildSpringCloudSelectorHandle(appName)));
    } else if (RpcTypeEnum.SOFA.getName().equals(rpcType)) {
        selectorDTO.setPluginId(getPluginId(PluginEnum.SOFA.getName()));
        selectorDTO.setHandle(appName);
    } else if (RpcTypeEnum.TARS.getName().equals(rpcType)) {
        selectorDTO.setPluginId(getPluginId(PluginEnum.TARS.getName()));
        selectorDTO.setHandle(appName);
    } else {
        //is divide
        DivideUpstream divideUpstream = buildDivideUpstream(uri);
        String handler = GsonUtils.getInstance().toJson(Collections.singletonList(divideUpstream));
        selectorDTO.setHandle(handler);
        selectorDTO.setPluginId(getPluginId(PluginEnum.DIVIDE.getName()));
        upstreamCheckService.submit(selectorDTO.getName(), divideUpstream);
    }
    SelectorConditionDTO selectorConditionDTO = new SelectorConditionDTO();
    selectorConditionDTO.setParamType(ParamTypeEnum.URI.getName());
    selectorConditionDTO.setParamName(&quot;/&quot;);
    selectorConditionDTO.setOperator(OperatorEnum.MATCH.getAlias());
    selectorConditionDTO.setParamValue(contextPath + &quot;/**&quot;);
    selectorDTO.setSelectorConditions(Collections.singletonList(selectorConditionDTO));
    return selectorService.register(selectorDTO);
}
</code></pre><p>看到这么多 if else，是不是很兴奋，小伙伴们可以想想怎么优化掉这么多 if else，PR 搞起来 ^ - ^。</p><p>写了这么多，无非是封装 SelectorDTO 对象，最后调用 selectorService.register(selectorDTO) 入库，继续跟进去。</p><pre><code class=language-java>// SelectorServiceImpl.java
@Override
public String register(final SelectorDTO selectorDTO) {
    SelectorDO selectorDO = SelectorDO.buildSelectorDO(selectorDTO);
    List&lt;SelectorConditionDTO&gt; selectorConditionDTOs = selectorDTO.getSelectorConditions();
    if (StringUtils.isEmpty(selectorDTO.getId())) {
        selectorMapper.insertSelective(selectorDO);
        selectorConditionDTOs.forEach(selectorConditionDTO -&gt; {
            selectorConditionDTO.setSelectorId(selectorDO.getId());
            // 这里在 for 循环里调用 dao 层插入数据，是不是可以考虑挪出去一次性批量插入？
            selectorConditionMapper.insertSelective(SelectorConditionDO
                    .buildSelectorConditionDO(selectorConditionDTO));
        });
    }
    publishEvent(selectorDO, selectorConditionDTOs);
    return selectorDO.getId();
}
</code></pre><p>看到这里有2条入库方法，分别向 selector 和 selector_condition 表中插入了数据。这里我们先不具体追究表结构及业务意义，后面补上。</p><p>publishEvent 方法，涉及到 ApplicationEventPublisher 接口，是观察者模式的一个实现，发布事件后通过监听器完成后续操作，这里先按下不表，后续单写一篇文章分析。</p><h4 id=2-1-2-已经接入-shenyu网关>2.1.2 已经接入 ShenYu网关</h4><p>就跟盗梦空间似的，我们回退2层梦境，回到插入数据的另一个分支，可以想见，就是，已经接入过 ShenYu网关的系统重启，或新节点启动走的逻辑。</p><p>把前面的代码再贴过来：</p><pre><code class=language-java>// SoulClientRegisterServiceImpl.java
private String handlerSpringMvcSelector(final SpringMvcRegisterDTO dto) {
    String contextPath = dto.getContext();
    // 根据 contextPath 到数据库里查询，是否已经注册过。
    SelectorDO selectorDO = selectorService.findByName(contextPath);
    String selectorId;
    String uri = String.join(&quot;:&quot;, dto.getHost(), String.valueOf(dto.getPort()));
    if (Objects.isNull(selectorDO)) {
        // 还没有注册过
        selectorId = registerSelector(contextPath, dto.getRpcType(), dto.getAppName(), uri);
    } else {
        // 已接入的业务系统重启，或新节点启动，会到这里
        selectorId = selectorDO.getId();
        //update upstream
        // handle 字段存储这个接口真实节点信息，可能存在多台机器需要负载均衡的场景
        String handle = selectorDO.getHandle();
        String handleAdd;
        DivideUpstream addDivideUpstream = buildDivideUpstream(uri);
        SelectorData selectorData = selectorService.buildByName(contextPath);
        if (StringUtils.isBlank(handle)) {
            // 这个接口虽然之前注册过，但第1个服务器节点接入 ShenYu时会进来
            handleAdd = GsonUtils.getInstance().toJson(Collections.singletonList(addDivideUpstream));
        } else {
            // 如果已经至少有1个服务器节点已接入，会进到这里，判断是否是同一个节点（使用 upstreamUrl 区分），如果相同直接返回
            List&lt;DivideUpstream&gt; exist = GsonUtils.getInstance().fromList(handle, DivideUpstream.class);
            for (DivideUpstream upstream : exist) {
                if (upstream.getUpstreamUrl().equals(addDivideUpstream.getUpstreamUrl())) {
                    return selectorId;
                }
            }
            // 如果不是同一个节点，把新节点加入到 handle 字段中
            exist.add(addDivideUpstream);
            handleAdd = GsonUtils.getInstance().toJson(exist);
        }
        selectorDO.setHandle(handleAdd);
        selectorData.setHandle(handleAdd);
        // update db 更新数据库
        selectorMapper.updateSelective(selectorDO);
        // submit upstreamCheck
        upstreamCheckService.submit(contextPath, addDivideUpstream);
        // publish change event.
        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.SELECTOR, DataEventTypeEnum.UPDATE,
                Collections.singletonList(selectorData)));
    }
    return selectorId;
}
</code></pre><p>因为还没有研究数据库表结构设计，根据已知部分猜测，1个 selector 对应一个 divide 插件，这个插件以 contextPath 为标识（在这里就是 &ldquo;/http&rdquo;），一个 contextPath 可以部署多个服务器节点，这些节点信息已 json 形式保存在 handle 字段中。</p><pre><code class=language-json>// handle/handleAdd 数据格式
[
    {
        &quot;upstreamHost&quot;: &quot;localhost&quot;,
        &quot;protocol&quot;: &quot;http://&quot;,
        &quot;upstreamUrl&quot;: &quot;10.0.0.12:8188&quot;,
        &quot;weight&quot;: 50,
        &quot;status&quot;: true,
        &quot;timestamp&quot;: 0,
        &quot;warmup&quot;: 0
    }
]
</code></pre><p>下面紧接着就是更新数据库 updateSelective。</p><p>upstreamCheckService.submit(contextPath, addDivideUpstream); 把真实服务器节点信息缓存在一个 Map(UPSTREAM_MAP) 里，有定时任务定期探活，如果发现服务节点宕机了，就把他剔除出去，防止把请求发送到已经宕机的节点上。</p><p>然后就是 eventPublisher.publishEvent()，跟前面的 publishEvent 方法一样，发布事件后通过监听器完成后续操作（简单介绍下，这里是通过与 ShenYu网关建立的 websocket 长连接发送数据 SelectorData 修改的消息，ShenYu网关根据消息修改数据，这个具体改的什么数据，怎么修改的，后面分析）。</p><p>到这里终于把 handlerSpringMvcSelector 这个方法分析完了。</p><h3 id=2-2-再来看看这个方法-handlerspringmvcrule-处理-rule>2.2 再来看看这个方法 handlerSpringMvcRule，处理 Rule。</h3><pre><code class=language-java>// SoulClientRegisterServiceImpl.java
private void handlerSpringMvcRule(final String selectorId, final SpringMvcRegisterDTO dto) {
    RuleDO ruleDO = ruleMapper.findByName(dto.getRuleName());
    if (Objects.isNull(ruleDO)) {
        registerRule(selectorId, dto.getPath(), dto.getRpcType(), dto.getRuleName());
    }
}
</code></pre><p>首先拿着规则名字，到 rule 表里捞数据，如果捞到了表名已经注册过了，无操作。</p><p>看下数据库数据，就是业务系统下的接口地址。</p><pre><code class=language-bash>mysql&gt; use soul;
Database changed

mysql&gt; select * from rule where name = '/http/order/findById' \G
*************************** 1. row ***************************
          id: 1349650371868782592
 selector_id: 1349650371302551552
  match_mode: 0
        name: /http/order/findById
     enabled: 1
       loged: 1
        sort: 1
      handle: {&quot;loadBalance&quot;:&quot;random&quot;,&quot;retry&quot;:0,&quot;timeout&quot;:3000}
date_created: 2021-01-14 17:31:39
date_updated: 2021-01-14 17:31:39
1 row in set (0.00 sec)
</code></pre><p>如果没捞到数据，注册这个规则。</p><pre><code class=language-java>// SoulClientRegisterServiceImpl.java
private void registerRule(final String selectorId, final String path, final String rpcType, final String ruleName) {
    RuleHandle ruleHandle = RuleHandleFactory.ruleHandle(RpcTypeEnum.acquireByName(rpcType), path);
    RuleDTO ruleDTO = RuleDTO.builder()
            .selectorId(selectorId)
            .name(ruleName)
            .matchMode(MatchModeEnum.AND.getCode())
            .enabled(Boolean.TRUE)
            .loged(Boolean.TRUE)
            .sort(1)
            .handle(ruleHandle.toJson())
            .build();
    RuleConditionDTO ruleConditionDTO = RuleConditionDTO.builder()
            .paramType(ParamTypeEnum.URI.getName())
            .paramName(&quot;/&quot;)
            .paramValue(path)
            .build();
    if (path.indexOf(&quot;*&quot;) &gt; 1) {
        ruleConditionDTO.setOperator(OperatorEnum.MATCH.getAlias());
    } else {
        ruleConditionDTO.setOperator(OperatorEnum.EQ.getAlias());
    }
    ruleDTO.setRuleConditions(Collections.singletonList(ruleConditionDTO));
    ruleService.register(ruleDTO);
}
</code></pre><p>第1行，根据 rpcType(&ldquo;http&rdquo;) 获取其对应的 RuleHandle，这里，默认内置3种类型，我们这里的是 HTTP，对应 DivideRuleHandle。</p><pre><code class=language-java>// RuleHandleFactory.java
public final class RuleHandleFactory {

    /**
     * The RpcType to RuleHandle class map.
     */
    private static final Map&lt;RpcTypeEnum, Class&lt;? extends RuleHandle&gt;&gt; RPC_TYPE_TO_RULE_HANDLE_CLASS = new ConcurrentHashMap&lt;&gt;();

    /**
     * The default RuleHandle.
     */
    private static final Class&lt;? extends RuleHandle&gt; DEFAULT_RULE_HANDLE = SpringCloudRuleHandle.class;

    static {
        RPC_TYPE_TO_RULE_HANDLE_CLASS.put(RpcTypeEnum.HTTP, DivideRuleHandle.class);
        RPC_TYPE_TO_RULE_HANDLE_CLASS.put(RpcTypeEnum.DUBBO, DubboRuleHandle.class);
        RPC_TYPE_TO_RULE_HANDLE_CLASS.put(RpcTypeEnum.SOFA, SofaRuleHandle.class);
    }

    /**
     * Get a RuleHandle object with given rpc type and path.
     * @param rpcType   rpc type.
     * @param path      path.
     * @return          RuleHandle object.
     */
    public static RuleHandle ruleHandle(final RpcTypeEnum rpcType, final String path) {
        if (Objects.isNull(rpcType)) {
            return null;
        }
        Class&lt;? extends RuleHandle&gt; clazz = RPC_TYPE_TO_RULE_HANDLE_CLASS.getOrDefault(rpcType, DEFAULT_RULE_HANDLE);
        try {
            return clazz.newInstance().createDefault(path);
        } catch (InstantiationException | IllegalAccessException e) {
            throw new SoulException(
                    String.format(&quot;Init RuleHandle failed with rpc type: %s, rule class: %s, exception: %s&quot;,
                            rpcType,
                            clazz.getSimpleName(),
                            e.getMessage()));
        }
    }
}
</code></pre><p>下面构造 RuleDTO 对象，注册规则。</p><pre><code class=language-java>// RuleServiceImpl.java
@Override
public String register(final RuleDTO ruleDTO) {
    RuleDO ruleDO = RuleDO.buildRuleDO(ruleDTO);
    List&lt;RuleConditionDTO&gt; ruleConditions = ruleDTO.getRuleConditions();
    if (StringUtils.isEmpty(ruleDTO.getId())) {
        ruleMapper.insertSelective(ruleDO);
        ruleConditions.forEach(ruleConditionDTO -&gt; {
            ruleConditionDTO.setRuleId(ruleDO.getId());
            // 这里在 for 循环里调用 dao 层插入数据，是不是可以考虑挪出去一次性批量插入？
            ruleConditionMapper.insertSelective(RuleConditionDO
                    .buildRuleConditionDO(ruleConditionDTO));
        });
    }
    publishEvent(ruleDO, ruleConditions);
    return ruleDO.getId();
}
</code></pre><p>分别向 rule 和 rule_condition 表中插入数据。</p><p>publishEvent() 方法，通过 websocket 长连接，向 ShenYu网关发送 RuleData 数据。</p><h2 id=3-总结>3.总结</h2><p>到这里，调用 &ldquo;/soul-client/springmvc-register&rdquo; 接口逻辑分析完了，我们总结下：</p><ul><li>处理 selector<ul><li>新增或修改 selector、selector_condition 表数据，持久化到 MySQL。</li><li>通过 websocket 向 ShenYu网关发送数据改动信息。</li></ul></li><li>处理 rule<ul><li>新增或修改 rule、rule_condition 表数据，持久化到 MySQL。</li><li>通过 websocket 向 ShenYu网关发送数据改动信息。</li></ul></li></ul><p>其中表结构及字段含义还需进一步学习和研究，websocket 发送给 ShenYu网关后，网关做了什么处理也需要后续分析。</p><p>到这里，HTTP 用户接入 ShenYu网关注册逻辑就分析完了。</p><p>如果在工作中你有使用网关的需求，或是个人有学习网关的追求，欢迎来跟我一起分析和学习，ShenYu网关，你值得拥有。</p></article><div class=-show-mobile><nav class=ss-pagination-next><a class=link-prev href=/blog/shenyu_source_larning_02_divide_plugin_source/><span class=text>Prev:</span>
<span class=text>ShenYuLearning(2) How Does The Divide Plugin Forward Http Requests</span></a>
<a class=link-next href=/blog/shenyu_source_learning_13_zookeeper_01/><span class=text>Next:</span>
<span class=text>Apache ShenYu Gateway Learns Zookeeper Data Synchronization 01</span></a></nav></div></main><aside class=ss-layout-aside><div class=ss-card><h2 class=card-title>Related</h2><ul class=ss-aside-related><li><a href=/blog/shenyu_source_larning_02_divide_plugin_source/>ShenYuLearning(2) How Does The Divide Plugin Forward Http Requests</a></li><li><a href=/blog/shenyu_source_learning_02_divide_plugin/>ShenYuLearning(2) Use Divide Plugin</a></li><li><a href=/blog/shenyu_source_learning_05_plugin/>Apache ShenYu Gateway learning plugin chain and load balancing analysis</a></li><li><a href=/blog/shenyu_source_learning_01/>ShenYuLearning(1) Environment Configuration</a></li><li><a href=/news/shenyu-2.3.0/>【Soul gateway release milestone version 2.3.0】New support for grpc, tars and sofa protocols!</a></li></ul></div><div class="ss-aside-tags ss-card"><h2 class=card-title>Tag
<span class=card-extra></span></h2><ul class=tag-list><li class=tag><a href=/tags/apache/>Apache</a></li><li class=tag><a href=/tags/apache-shenyu/>Apache ShenYu</a></li><li class=tag><a href=/tags/code-conduct/>Code Conduct</a></li><li class=tag><a href=/tags/committer/>Committer</a></li><li class=tag><a href=/tags/contributor/>Contributor</a></li><li class=tag><a href=/tags/dreamcode/>DreamCode</a></li><li class=tag><a href=/tags/gateway/>GateWay</a></li><li class=tag><a href=/tags/icla/>ICLA</a></li><li class=tag><a href=/tags/issue-pr/>Issue-PR</a></li><li class=tag><a href=/tags/reactor/>Reactor</a></li><li class=tag><a href=/tags/subscribe-email/>Subscribe-Email</a></li><li class=tag><a href=/tags/two-fa/>Two-FA</a></li><li class=tag><a href=/tags/vote-committer/>Vote-Committer</a></li></ul></div></aside></div><footer class=ss-footer><div class=container><div class=links><div class="cate  -show-mobile"><h2 class=cate-title>Apache</h2><a class=link href=https://www.apache.org/>Foundation</a>
<a class=link href=https://github.com/apache/incubator-shenyu/issues>GitHub Issue Tracker</a>
<a class=link href=https://www.apache.org/licenses/>License</a>
<a class=link href=https://www.apache.org/security/>Security</a>
<a class=link href=http://www.apache.org/events/current-event>Events</a>
<a class=link href=http://www.apache.org/foundation/sponsorship.html>Sponsorship</a>
<a class=link href=http://www.apache.org/foundation/thanks.html>Thanks</a></div><div class=cate><h2 class=cate-title>Resources</h2><a class=link href=https://github.com/apache/incubator-shenyu>Github</a>
<a class=link href=/projects/shenyu/overview/>Documentation</a></div><div class=cate><h2 class=cate-title>Get Involved</h2><a class=link href=https://github.com/apache/incubator-shenyu/issues/new>Feedback</a>
<a class=link href=/community>Community</a>
<a class=link href=/news>News</a>
<a class=link href=/awesome>Awesome</a></div><div class=cate><h2 class=cate-title>Subscribe mailing list</h2><a class=link href=/community/subscribe-email/>How to subscribe</a>
<a class=link href=mailto://dev-subscribe@shenyu.apache.org>Subscribe Mail</a>
<a class=link href=https://lists.apache.org/list.html?dev@shenyu.apache.org>Mail Archive</a></div></div><div class=qrcode><div><img class=qrcode-img src=/img/qrcode/WechatIMG127.jpeg><p class=qrcode-desc>Wechat Official Account</p></div></div></div><div class=copyright><p>Copyright © 2021 The Apache Software Foundation. Licensed under the Apache License, Version 2.0.
Apache ShenYu, Apache Incubator, Apache, the Apache feather logo, the Apache ShenYu logo and the Apache Incubator project logo are trademarks of The Apache Software Foundation.
Apache ShenYu is an effort undergoing incubation at The Apache Software Foundation (ASF), sponsored by the Apache Incubator.
Incubation is required of all newly accepted projects until a further review indicates that the infrastructure, communications, and decision making process have stabilized in a manner consistent with other successful ASF projects.
While incubation status is not necessarily a reflection of the completeness or stability of the code,
it does indicate that the project has yet to be fully endorsed by the ASF.</p></div></footer></body></html>